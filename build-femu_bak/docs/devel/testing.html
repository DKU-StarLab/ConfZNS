
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Testing in QEMU &#8212; QEMU  documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="QTest Device Emulation Testing Framework" href="qtest.html" />
    <link rel="prev" title="QEMU and the stable process" href="stable-process.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="testing-in-qemu">
<h1>Testing in QEMU<a class="headerlink" href="#testing-in-qemu" title="Permalink to this headline">¶</a></h1>
<p>This document describes the testing infrastructure in QEMU.</p>
<div class="section" id="testing-with-make-check">
<h2>Testing with “make check”<a class="headerlink" href="#testing-with-make-check" title="Permalink to this headline">¶</a></h2>
<p>The “make check” testing family includes most of the C based tests in QEMU. For
a quick help, run <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">check-help</span></code> from the source tree.</p>
<p>The usual way to run these tests is:</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">check</span>
</pre></div>
</div>
<p>which includes QAPI schema tests, unit tests, QTests and some iotests.
Different sub-types of “make check” tests will be explained below.</p>
<p>Before running tests, it is best to build QEMU programs first. Some tests
expect the executables to exist and will fail with obscure messages if they
cannot find them.</p>
<div class="section" id="unit-tests">
<h3>Unit tests<a class="headerlink" href="#unit-tests" title="Permalink to this headline">¶</a></h3>
<p>Unit tests, which can be invoked with <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">check-unit</span></code>, are simple C tests
that typically link to individual QEMU object files and exercise them by
calling exported functions.</p>
<p>If you are writing new code in QEMU, consider adding a unit test, especially
for utility modules that are relatively stateless or have few dependencies. To
add a new unit test:</p>
<ol class="arabic">
<li><p class="first">Create a new source file. For example, <code class="docutils literal notranslate"><span class="pre">tests/foo-test.c</span></code>.</p>
</li>
<li><p class="first">Write the test. Normally you would include the header file which exports
the module API, then verify the interface behaves as expected from your
test. The test code should be organized with the glib testing framework.
Copying and modifying an existing test is usually a good idea.</p>
</li>
<li><p class="first">Add the test to <code class="docutils literal notranslate"><span class="pre">tests/meson.build</span></code>. The unit tests are listed in a
dictionary called <code class="docutils literal notranslate"><span class="pre">tests</span></code>.  The values are any additional sources and
dependencies to be linked with the test.  For a simple test whose source
is in <code class="docutils literal notranslate"><span class="pre">tests/foo-test.c</span></code>, it is enough to add an entry like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="o">...</span>
  <span class="s1">&#39;foo-test&#39;</span><span class="p">:</span> <span class="p">[],</span>
  <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ol>
<p>Since unit tests don’t require environment variables, the simplest way to debug
a unit test failure is often directly invoking it or even running it under
<code class="docutils literal notranslate"><span class="pre">gdb</span></code>. However there can still be differences in behavior between <code class="docutils literal notranslate"><span class="pre">make</span></code>
invocations and your manual run, due to <code class="docutils literal notranslate"><span class="pre">$MALLOC_PERTURB_</span></code> environment
variable (which affects memory reclamation and catches invalid pointers better)
and gtester options. If necessary, you can run</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">check</span><span class="o">-</span><span class="n">unit</span> <span class="n">V</span><span class="o">=</span><span class="mi">1</span>
</pre></div>
</div>
<p>and copy the actual command line which executes the unit test, then run
it from the command line.</p>
</div>
<div class="section" id="qtest">
<h3>QTest<a class="headerlink" href="#qtest" title="Permalink to this headline">¶</a></h3>
<p>QTest is a device emulation testing framework.  It can be very useful to test
device models; it could also control certain aspects of QEMU (such as virtual
clock stepping), with a special purpose “qtest” protocol.  Refer to
<a class="reference internal" href="qtest.html"><span class="doc">QTest Device Emulation Testing Framework</span></a> for more details.</p>
<p>QTest cases can be executed with</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">check</span><span class="o">-</span><span class="n">qtest</span>
</pre></div>
</div>
</div>
<div class="section" id="qapi-schema-tests">
<h3>QAPI schema tests<a class="headerlink" href="#qapi-schema-tests" title="Permalink to this headline">¶</a></h3>
<p>The QAPI schema tests validate the QAPI parser used by QMP, by feeding
predefined input to the parser and comparing the result with the reference
output.</p>
<p>The input/output data is managed under the <code class="docutils literal notranslate"><span class="pre">tests/qapi-schema</span></code> directory.
Each test case includes four files that have a common base name:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">${casename}.json</span></code> - the file contains the JSON input for feeding the
parser</li>
<li><code class="docutils literal notranslate"><span class="pre">${casename}.out</span></code> - the file contains the expected stdout from the parser</li>
<li><code class="docutils literal notranslate"><span class="pre">${casename}.err</span></code> - the file contains the expected stderr from the parser</li>
<li><code class="docutils literal notranslate"><span class="pre">${casename}.exit</span></code> - the expected error code</li>
</ul>
</div></blockquote>
<p>Consider adding a new QAPI schema test when you are making a change on the QAPI
parser (either fixing a bug or extending/modifying the syntax). To do this:</p>
<ol class="arabic simple">
<li>Add four files for the new case as explained above. For example:</li>
</ol>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">$EDITOR</span> <span class="pre">tests/qapi-schema/foo.{json,out,err,exit}</span></code>.</div></blockquote>
<ol class="arabic simple" start="2">
<li>Add the new test in <code class="docutils literal notranslate"><span class="pre">tests/Makefile.include</span></code>. For example:</li>
</ol>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">qapi-schema</span> <span class="pre">+=</span> <span class="pre">foo.json</span></code></div></blockquote>
</div>
<div class="section" id="check-block">
<h3>check-block<a class="headerlink" href="#check-block" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">check-block</span></code> runs a subset of the block layer iotests (the tests that
are in the “auto” group in <code class="docutils literal notranslate"><span class="pre">tests/qemu-iotests/group</span></code>).
See the “QEMU iotests” section below for more information.</p>
</div>
<div class="section" id="gcc-gcov-support">
<h3>GCC gcov support<a class="headerlink" href="#gcc-gcov-support" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">gcov</span></code> is a GCC tool to analyze the testing coverage by
instrumenting the tested code. To use it, configure QEMU with
<code class="docutils literal notranslate"><span class="pre">--enable-gcov</span></code> option and build. Then run <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">check</span></code> as usual.</p>
<p>If you want to gather coverage information on a single test the <code class="docutils literal notranslate"><span class="pre">make</span>
<span class="pre">clean-gcda</span></code> target can be used to delete any existing coverage
information before running a single test.</p>
<p>You can generate a HTML coverage report by executing <code class="docutils literal notranslate"><span class="pre">make</span>
<span class="pre">coverage-html</span></code> which will create
<code class="docutils literal notranslate"><span class="pre">meson-logs/coveragereport/index.html</span></code>.</p>
<p>Further analysis can be conducted by running the <code class="docutils literal notranslate"><span class="pre">gcov</span></code> command
directly on the various .gcda output files. Please read the <code class="docutils literal notranslate"><span class="pre">gcov</span></code>
documentation for more information.</p>
</div>
</div>
<div class="section" id="qemu-iotests">
<h2>QEMU iotests<a class="headerlink" href="#qemu-iotests" title="Permalink to this headline">¶</a></h2>
<p>QEMU iotests, under the directory <code class="docutils literal notranslate"><span class="pre">tests/qemu-iotests</span></code>, is the testing
framework widely used to test block layer related features. It is higher level
than “make check” tests and 99% of the code is written in bash or Python
scripts.  The testing success criteria is golden output comparison, and the
test files are named with numbers.</p>
<p>To run iotests, make sure QEMU is built successfully, then switch to the
<code class="docutils literal notranslate"><span class="pre">tests/qemu-iotests</span></code> directory under the build directory, and run <code class="docutils literal notranslate"><span class="pre">./check</span></code>
with desired arguments from there.</p>
<p>By default, “raw” format and “file” protocol is used; all tests will be
executed, except the unsupported ones. You can override the format and protocol
with arguments:</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># test with qcow2 format</span>
<span class="o">./</span><span class="n">check</span> <span class="o">-</span><span class="n">qcow2</span>
<span class="c1"># or test a different protocol</span>
<span class="o">./</span><span class="n">check</span> <span class="o">-</span><span class="n">nbd</span>
</pre></div>
</div>
<p>It’s also possible to list test numbers explicitly:</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># run selected cases with qcow2 format</span>
<span class="o">./</span><span class="n">check</span> <span class="o">-</span><span class="n">qcow2</span> <span class="mi">001</span> <span class="mi">030</span> <span class="mi">153</span>
</pre></div>
</div>
<p>Cache mode can be selected with the “-c” option, which may help reveal bugs
that are specific to certain cache mode.</p>
<p>More options are supported by the <code class="docutils literal notranslate"><span class="pre">./check</span></code> script, run <code class="docutils literal notranslate"><span class="pre">./check</span> <span class="pre">-h</span></code> for
help.</p>
<div class="section" id="writing-a-new-test-case">
<h3>Writing a new test case<a class="headerlink" href="#writing-a-new-test-case" title="Permalink to this headline">¶</a></h3>
<p>Consider writing a tests case when you are making any changes to the block
layer. An iotest case is usually the choice for that. There are already many
test cases, so it is possible that extending one of them may achieve the goal
and save the boilerplate to create one.  (Unfortunately, there isn’t a 100%
reliable way to find a related one out of hundreds of tests.  One approach is
using <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">grep</span></code>.)</p>
<p>Usually an iotest case consists of two files. One is an executable that
produces output to stdout and stderr, the other is the expected reference
output. They are given the same number in file names. E.g. Test script <code class="docutils literal notranslate"><span class="pre">055</span></code>
and reference output <code class="docutils literal notranslate"><span class="pre">055.out</span></code>.</p>
<p>In rare cases, when outputs differ between cache mode <code class="docutils literal notranslate"><span class="pre">none</span></code> and others, a
<code class="docutils literal notranslate"><span class="pre">.out.nocache</span></code> file is added. In other cases, when outputs differ between
image formats, more than one <code class="docutils literal notranslate"><span class="pre">.out</span></code> files are created ending with the
respective format names, e.g. <code class="docutils literal notranslate"><span class="pre">178.out.qcow2</span></code> and <code class="docutils literal notranslate"><span class="pre">178.out.raw</span></code>.</p>
<p>There isn’t a hard rule about how to write a test script, but a new test is
usually a (copy and) modification of an existing case.  There are a few
commonly used ways to create a test:</p>
<ul class="simple">
<li>A Bash script. It will make use of several environmental variables related
to the testing procedure, and could source a group of <code class="docutils literal notranslate"><span class="pre">common.*</span></code> libraries
for some common helper routines.</li>
<li>A Python unittest script. Import <code class="docutils literal notranslate"><span class="pre">iotests</span></code> and create a subclass of
<code class="docutils literal notranslate"><span class="pre">iotests.QMPTestCase</span></code>, then call <code class="docutils literal notranslate"><span class="pre">iotests.main</span></code> method. The downside of
this approach is that the output is too scarce, and the script is considered
harder to debug.</li>
<li>A simple Python script without using unittest module. This could also import
<code class="docutils literal notranslate"><span class="pre">iotests</span></code> for launching QEMU and utilities etc, but it doesn’t inherit
from <code class="docutils literal notranslate"><span class="pre">iotests.QMPTestCase</span></code> therefore doesn’t use the Python unittest
execution. This is a combination of 1 and 2.</li>
</ul>
<p>Pick the language per your preference since both Bash and Python have
comparable library support for invoking and interacting with QEMU programs. If
you opt for Python, it is strongly recommended to write Python 3 compatible
code.</p>
<p>Both Python and Bash frameworks in iotests provide helpers to manage test
images. They can be used to create and clean up images under the test
directory. If no I/O or any protocol specific feature is needed, it is often
more convenient to use the pseudo block driver, <code class="docutils literal notranslate"><span class="pre">null-co://</span></code>, as the test
image, which doesn’t require image creation or cleaning up. Avoid system-wide
devices or files whenever possible, such as <code class="docutils literal notranslate"><span class="pre">/dev/null</span></code> or <code class="docutils literal notranslate"><span class="pre">/dev/zero</span></code>.
Otherwise, image locking implications have to be considered.  For example,
another application on the host may have locked the file, possibly leading to a
test failure.  If using such devices are explicitly desired, consider adding
<code class="docutils literal notranslate"><span class="pre">locking=off</span></code> option to disable image locking.</p>
</div>
</div>
<div class="section" id="docker-based-tests">
<span id="docker-ref"></span><h2>Docker based tests<a class="headerlink" href="#docker-based-tests" title="Permalink to this headline">¶</a></h2>
<div class="section" id="introduction">
<h3>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h3>
<p>The Docker testing framework in QEMU utilizes public Docker images to build and
test QEMU in predefined and widely accessible Linux environments.  This makes
it possible to expand the test coverage across distros, toolchain flavors and
library versions.</p>
</div>
<div class="section" id="prerequisites">
<h3>Prerequisites<a class="headerlink" href="#prerequisites" title="Permalink to this headline">¶</a></h3>
<p>Install “docker” with the system package manager and start the Docker service
on your development machine, then make sure you have the privilege to run
Docker commands. Typically it means setting up passwordless <code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">docker</span></code>
command or login as root. For example:</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span>$ sudo yum install docker
$ # or `apt-get install docker` for Ubuntu, etc.
$ sudo systemctl start docker
$ sudo docker ps
</pre></div>
</div>
<p>The last command should print an empty table, to verify the system is ready.</p>
<p>An alternative method to set up permissions is by adding the current user to
“docker” group and making the docker daemon socket file (by default
<code class="docutils literal notranslate"><span class="pre">/var/run/docker.sock</span></code>) accessible to the group:</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span>$ sudo groupadd docker
$ sudo usermod $USER -a -G docker
$ sudo chown :docker /var/run/docker.sock
</pre></div>
</div>
<p>Note that any one of above configurations makes it possible for the user to
exploit the whole host with Docker bind mounting or other privileged
operations.  So only do it on development machines.</p>
</div>
<div class="section" id="quickstart">
<h3>Quickstart<a class="headerlink" href="#quickstart" title="Permalink to this headline">¶</a></h3>
<p>From source tree, type <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">docker</span></code> to see the help. Testing can be started
without configuring or building QEMU (<code class="docutils literal notranslate"><span class="pre">configure</span></code> and <code class="docutils literal notranslate"><span class="pre">make</span></code> are done in
the container, with parameters defined by the make target):</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">docker</span><span class="o">-</span><span class="n">test</span><span class="o">-</span><span class="n">build</span><span class="nd">@min</span><span class="o">-</span><span class="n">glib</span>
</pre></div>
</div>
<p>This will create a container instance using the <code class="docutils literal notranslate"><span class="pre">min-glib</span></code> image (the image
is downloaded and initialized automatically), in which the <code class="docutils literal notranslate"><span class="pre">test-build</span></code> job
is executed.</p>
</div>
<div class="section" id="images">
<h3>Images<a class="headerlink" href="#images" title="Permalink to this headline">¶</a></h3>
<p>Along with many other images, the <code class="docutils literal notranslate"><span class="pre">min-glib</span></code> image is defined in a Dockerfile
in <code class="docutils literal notranslate"><span class="pre">tests/docker/dockerfiles/</span></code>, called <code class="docutils literal notranslate"><span class="pre">min-glib.docker</span></code>. <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">docker</span></code>
command will list all the available images.</p>
<p>To add a new image, simply create a new <code class="docutils literal notranslate"><span class="pre">.docker</span></code> file under the
<code class="docutils literal notranslate"><span class="pre">tests/docker/dockerfiles/</span></code> directory.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">.pre</span></code> script can be added beside the <code class="docutils literal notranslate"><span class="pre">.docker</span></code> file, which will be
executed before building the image under the build context directory. This is
mainly used to do necessary host side setup. One such setup is <code class="docutils literal notranslate"><span class="pre">binfmt_misc</span></code>,
for example, to make qemu-user powered cross build containers work.</p>
</div>
<div class="section" id="tests">
<h3>Tests<a class="headerlink" href="#tests" title="Permalink to this headline">¶</a></h3>
<p>Different tests are added to cover various configurations to build and test
QEMU.  Docker tests are the executables under <code class="docutils literal notranslate"><span class="pre">tests/docker</span></code> named
<code class="docutils literal notranslate"><span class="pre">test-*</span></code>. They are typically shell scripts and are built on top of a shell
library, <code class="docutils literal notranslate"><span class="pre">tests/docker/common.rc</span></code>, which provides helpers to find the QEMU
source and build it.</p>
<p>The full list of tests is printed in the <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">docker</span></code> help.</p>
</div>
<div class="section" id="tools">
<h3>Tools<a class="headerlink" href="#tools" title="Permalink to this headline">¶</a></h3>
<p>There are executables that are created to run in a specific Docker environment.
This makes it easy to write scripts that have heavy or special dependencies,
but are still very easy to use.</p>
<p>Currently the only tool is <code class="docutils literal notranslate"><span class="pre">travis</span></code>, which mimics the Travis-CI tests in a
container. It runs in the <code class="docutils literal notranslate"><span class="pre">travis</span></code> image:</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">docker</span><span class="o">-</span><span class="n">travis</span><span class="nd">@travis</span>
</pre></div>
</div>
</div>
<div class="section" id="debugging-a-docker-test-failure">
<h3>Debugging a Docker test failure<a class="headerlink" href="#debugging-a-docker-test-failure" title="Permalink to this headline">¶</a></h3>
<p>When CI tasks, maintainers or yourself report a Docker test failure, follow the
below steps to debug it:</p>
<ol class="arabic simple">
<li>Locally reproduce the failure with the reported command line. E.g. run
<code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">docker-test-mingw&#64;fedora</span> <span class="pre">J=8</span></code>.</li>
<li>Add “V=1” to the command line, try again, to see the verbose output.</li>
<li>Further add “DEBUG=1” to the command line. This will pause in a shell prompt
in the container right before testing starts. You could either manually
build QEMU and run tests from there, or press Ctrl-D to let the Docker
testing continue.</li>
<li>If you press Ctrl-D, the same building and testing procedure will begin, and
will hopefully run into the error again. After that, you will be dropped to
the prompt for debug.</li>
</ol>
</div>
<div class="section" id="options">
<h3>Options<a class="headerlink" href="#options" title="Permalink to this headline">¶</a></h3>
<p>Various options can be used to affect how Docker tests are done. The full
list is in the <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">docker</span></code> help text. The frequently used ones are:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">V=1</span></code>: the same as in top level <code class="docutils literal notranslate"><span class="pre">make</span></code>. It will be propagated to the
container and enable verbose output.</li>
<li><code class="docutils literal notranslate"><span class="pre">J=$N</span></code>: the number of parallel tasks in make commands in the container,
similar to the <code class="docutils literal notranslate"><span class="pre">-j</span> <span class="pre">$N</span></code> option in top level <code class="docutils literal notranslate"><span class="pre">make</span></code>. (The <code class="docutils literal notranslate"><span class="pre">-j</span></code> option in
top level <code class="docutils literal notranslate"><span class="pre">make</span></code> will not be propagated into the container.)</li>
<li><code class="docutils literal notranslate"><span class="pre">DEBUG=1</span></code>: enables debug. See the previous “Debugging a Docker test
failure” section.</li>
</ul>
</div>
</div>
<div class="section" id="thread-sanitizer">
<h2>Thread Sanitizer<a class="headerlink" href="#thread-sanitizer" title="Permalink to this headline">¶</a></h2>
<p>Thread Sanitizer (TSan) is a tool which can detect data races.  QEMU supports
building and testing with this tool.</p>
<p>For more information on TSan:</p>
<p><a class="reference external" href="https://github.com/google/sanitizers/wiki/ThreadSanitizerCppManual">https://github.com/google/sanitizers/wiki/ThreadSanitizerCppManual</a></p>
<div class="section" id="thread-sanitizer-in-docker">
<h3>Thread Sanitizer in Docker<a class="headerlink" href="#thread-sanitizer-in-docker" title="Permalink to this headline">¶</a></h3>
<p>TSan is currently supported in the ubuntu2004 docker.</p>
<p>The test-tsan test will build using TSan and then run make check.</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">docker</span><span class="o">-</span><span class="n">test</span><span class="o">-</span><span class="n">tsan</span><span class="nd">@ubuntu2004</span>
</pre></div>
</div>
<p>TSan warnings under docker are placed in files located at build/tsan/.</p>
<p>We recommend using DEBUG=1 to allow launching the test from inside the docker,
and to allow review of the warnings generated by TSan.</p>
</div>
<div class="section" id="building-and-testing-with-tsan">
<h3>Building and Testing with TSan<a class="headerlink" href="#building-and-testing-with-tsan" title="Permalink to this headline">¶</a></h3>
<p>It is possible to build and test with TSan, with a few additional steps.
These steps are normally done automatically in the docker.</p>
<p>There is a one time patch needed in clang-9 or clang-10 at this time:</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sed</span> <span class="o">-</span><span class="n">i</span> <span class="s1">&#39;s/^const/static const/g&#39;</span> \
    <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">llvm</span><span class="o">-</span><span class="mi">10</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">clang</span><span class="o">/</span><span class="mf">10.0</span><span class="o">.</span><span class="mi">0</span><span class="o">/</span><span class="n">include</span><span class="o">/</span><span class="n">sanitizer</span><span class="o">/</span><span class="n">tsan_interface</span><span class="o">.</span><span class="n">h</span>
</pre></div>
</div>
<p>To configure the build for TSan:</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">../</span><span class="n">configure</span> <span class="o">--</span><span class="n">enable</span><span class="o">-</span><span class="n">tsan</span> <span class="o">--</span><span class="n">cc</span><span class="o">=</span><span class="n">clang</span><span class="o">-</span><span class="mi">10</span> <span class="o">--</span><span class="n">cxx</span><span class="o">=</span><span class="n">clang</span><span class="o">++-</span><span class="mi">10</span> \
             <span class="o">--</span><span class="n">disable</span><span class="o">-</span><span class="n">werror</span> <span class="o">--</span><span class="n">extra</span><span class="o">-</span><span class="n">cflags</span><span class="o">=</span><span class="s2">&quot;-O0&quot;</span>
</pre></div>
</div>
<p>The runtime behavior of TSAN is controlled by the TSAN_OPTIONS environment
variable.</p>
<p>More information on the TSAN_OPTIONS can be found here:</p>
<p><a class="reference external" href="https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags">https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags</a></p>
<p>For example:</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">export</span> <span class="n">TSAN_OPTIONS</span><span class="o">=</span><span class="n">suppressions</span><span class="o">=&lt;</span><span class="n">path</span> <span class="n">to</span> <span class="n">qemu</span><span class="o">&gt;/</span><span class="n">tests</span><span class="o">/</span><span class="n">tsan</span><span class="o">/</span><span class="n">suppressions</span><span class="o">.</span><span class="n">tsan</span> \
                    <span class="n">detect_deadlocks</span><span class="o">=</span><span class="n">false</span> <span class="n">history_size</span><span class="o">=</span><span class="mi">7</span> <span class="n">exitcode</span><span class="o">=</span><span class="mi">0</span> \
                    <span class="n">log_path</span><span class="o">=&lt;</span><span class="n">build</span> <span class="n">path</span><span class="o">&gt;/</span><span class="n">tsan</span><span class="o">/</span><span class="n">tsan_warning</span>
</pre></div>
</div>
<p>The above exitcode=0 has TSan continue without error if any warnings are found.
This allows for running the test and then checking the warnings afterwards.
If you want TSan to stop and exit with error on warnings, use exitcode=66.</p>
</div>
<div class="section" id="tsan-suppressions">
<h3>TSan Suppressions<a class="headerlink" href="#tsan-suppressions" title="Permalink to this headline">¶</a></h3>
<p>Keep in mind that for any data race warning, although there might be a data race
detected by TSan, there might be no actual bug here.  TSan provides several
different mechanisms for suppressing warnings.  In general it is recommended
to fix the code if possible to eliminate the data race rather than suppress
the warning.</p>
<p>A few important files for suppressing warnings are:</p>
<p>tests/tsan/suppressions.tsan - Has TSan warnings we wish to suppress at runtime.
The comment on each suppression will typically indicate why we are
suppressing it.  More information on the file format can be found here:</p>
<p><a class="reference external" href="https://github.com/google/sanitizers/wiki/ThreadSanitizerSuppressions">https://github.com/google/sanitizers/wiki/ThreadSanitizerSuppressions</a></p>
<p>tests/tsan/blacklist.tsan - Has TSan warnings we wish to disable
at compile time for test or debug.
Add flags to configure to enable:</p>
<p>“–extra-cflags=-fsanitize-blacklist=&lt;src path&gt;/tests/tsan/blacklist.tsan”</p>
<p>More information on the file format can be found here under “Blacklist Format”:</p>
<p><a class="reference external" href="https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags">https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags</a></p>
</div>
<div class="section" id="tsan-annotations">
<h3>TSan Annotations<a class="headerlink" href="#tsan-annotations" title="Permalink to this headline">¶</a></h3>
<p>include/qemu/tsan.h defines annotations.  See this file for more descriptions
of the annotations themselves.  Annotations can be used to suppress
TSan warnings or give TSan more information so that it can detect proper
relationships between accesses of data.</p>
<p>Annotation examples can be found here:</p>
<p><a class="reference external" href="https://github.com/llvm/llvm-project/tree/master/compiler-rt/test/tsan/">https://github.com/llvm/llvm-project/tree/master/compiler-rt/test/tsan/</a></p>
<p>Good files to start with are: annotate_happens_before.cpp and ignore_race.cpp</p>
<p>The full set of annotations can be found here:</p>
<p><a class="reference external" href="https://github.com/llvm/llvm-project/blob/master/compiler-rt/lib/tsan/rtl/tsan_interface_ann.cpp">https://github.com/llvm/llvm-project/blob/master/compiler-rt/lib/tsan/rtl/tsan_interface_ann.cpp</a></p>
</div>
</div>
<div class="section" id="vm-testing">
<h2>VM testing<a class="headerlink" href="#vm-testing" title="Permalink to this headline">¶</a></h2>
<p>This test suite contains scripts that bootstrap various guest images that have
necessary packages to build QEMU. The basic usage is documented in <code class="docutils literal notranslate"><span class="pre">Makefile</span></code>
help which is displayed with <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">vm-help</span></code>.</p>
<div class="section" id="id1">
<h3>Quickstart<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>Run <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">vm-help</span></code> to list available make targets. Invoke a specific make
command to run build test in an image. For example, <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">vm-build-freebsd</span></code>
will build the source tree in the FreeBSD image. The command can be executed
from either the source tree or the build dir; if the former, <code class="docutils literal notranslate"><span class="pre">./configure</span></code> is
not needed. The command will then generate the test image in <code class="docutils literal notranslate"><span class="pre">./tests/vm/</span></code>
under the working directory.</p>
<p>Note: images created by the scripts accept a well-known RSA key pair for SSH
access, so they SHOULD NOT be exposed to external interfaces if you are
concerned about attackers taking control of the guest and potentially
exploiting a QEMU security bug to compromise the host.</p>
</div>
<div class="section" id="qemu-binaries">
<h3>QEMU binaries<a class="headerlink" href="#qemu-binaries" title="Permalink to this headline">¶</a></h3>
<p>By default, qemu-system-x86_64 is searched in $PATH to run the guest. If there
isn’t one, or if it is older than 2.10, the test won’t work. In this case,
provide the QEMU binary in env var: <code class="docutils literal notranslate"><span class="pre">QEMU=/path/to/qemu-2.10+</span></code>.</p>
<p>Likewise the path to qemu-img can be set in QEMU_IMG environment variable.</p>
</div>
<div class="section" id="make-jobs">
<h3>Make jobs<a class="headerlink" href="#make-jobs" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">-j$X</span></code> option in the make command line is not propagated into the VM,
specify <code class="docutils literal notranslate"><span class="pre">J=$X</span></code> to control the make jobs in the guest.</p>
</div>
<div class="section" id="debugging">
<h3>Debugging<a class="headerlink" href="#debugging" title="Permalink to this headline">¶</a></h3>
<p>Add <code class="docutils literal notranslate"><span class="pre">DEBUG=1</span></code> and/or <code class="docutils literal notranslate"><span class="pre">V=1</span></code> to the make command to allow interactive
debugging and verbose output. If this is not enough, see the next section.
<code class="docutils literal notranslate"><span class="pre">V=1</span></code> will be propagated down into the make jobs in the guest.</p>
</div>
<div class="section" id="manual-invocation">
<h3>Manual invocation<a class="headerlink" href="#manual-invocation" title="Permalink to this headline">¶</a></h3>
<p>Each guest script is an executable script with the same command line options.
For example to work with the netbsd guest, use <code class="docutils literal notranslate"><span class="pre">$QEMU_SRC/tests/vm/netbsd</span></code>:</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span>$ cd $QEMU_SRC/tests/vm

# To bootstrap the image
$ ./netbsd --build-image --image /var/tmp/netbsd.img
&lt;...&gt;

# To run an arbitrary command in guest (the output will not be echoed unless
# --debug is added)
$ ./netbsd --debug --image /var/tmp/netbsd.img uname -a

# To build QEMU in guest
$ ./netbsd --debug --image /var/tmp/netbsd.img --build-qemu $QEMU_SRC

# To get to an interactive shell
$ ./netbsd --interactive --image /var/tmp/netbsd.img sh
</pre></div>
</div>
</div>
<div class="section" id="adding-new-guests">
<h3>Adding new guests<a class="headerlink" href="#adding-new-guests" title="Permalink to this headline">¶</a></h3>
<p>Please look at existing guest scripts for how to add new guests.</p>
<p>Most importantly, create a subclass of BaseVM and implement <code class="docutils literal notranslate"><span class="pre">build_image()</span></code>
method and define <code class="docutils literal notranslate"><span class="pre">BUILD_SCRIPT</span></code>, then finally call <code class="docutils literal notranslate"><span class="pre">basevm.main()</span></code> from
the script’s <code class="docutils literal notranslate"><span class="pre">main()</span></code>.</p>
<ul class="simple">
<li>Usually in <code class="docutils literal notranslate"><span class="pre">build_image()</span></code>, a template image is downloaded from a
predefined URL. <code class="docutils literal notranslate"><span class="pre">BaseVM._download_with_cache()</span></code> takes care of the cache and
the checksum, so consider using it.</li>
<li>Once the image is downloaded, users, SSH server and QEMU build deps should
be set up:<ul>
<li>Root password set to <code class="docutils literal notranslate"><span class="pre">BaseVM.ROOT_PASS</span></code></li>
<li>User <code class="docutils literal notranslate"><span class="pre">BaseVM.GUEST_USER</span></code> is created, and password set to
<code class="docutils literal notranslate"><span class="pre">BaseVM.GUEST_PASS</span></code></li>
<li>SSH service is enabled and started on boot,
<code class="docutils literal notranslate"><span class="pre">$QEMU_SRC/tests/keys/id_rsa.pub</span></code> is added to ssh’s <code class="docutils literal notranslate"><span class="pre">authorized_keys</span></code>
file of both root and the normal user</li>
<li>DHCP client service is enabled and started on boot, so that it can
automatically configure the virtio-net-pci NIC and communicate with QEMU
user net (10.0.2.2)</li>
<li>Necessary packages are installed to untar the source tarball and build
QEMU</li>
</ul>
</li>
<li>Write a proper <code class="docutils literal notranslate"><span class="pre">BUILD_SCRIPT</span></code> template, which should be a shell script that
untars a raw virtio-blk block device, which is the tarball data blob of the
QEMU source tree, then configure/build it. Running “make check” is also
recommended.</li>
</ul>
</div>
</div>
<div class="section" id="image-fuzzer-testing">
<h2>Image fuzzer testing<a class="headerlink" href="#image-fuzzer-testing" title="Permalink to this headline">¶</a></h2>
<p>An image fuzzer was added to exercise format drivers. Currently only qcow2 is
supported. To start the fuzzer, run</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tests</span><span class="o">/</span><span class="n">image</span><span class="o">-</span><span class="n">fuzzer</span><span class="o">/</span><span class="n">runner</span><span class="o">.</span><span class="n">py</span> <span class="o">-</span><span class="n">c</span> <span class="s1">&#39;[[&quot;qemu-img&quot;, &quot;info&quot;, &quot;$test_img&quot;]]&#39;</span> <span class="o">/</span><span class="n">tmp</span><span class="o">/</span><span class="n">test</span> <span class="n">qcow2</span>
</pre></div>
</div>
<p>Alternatively, some command different from “qemu-img info” can be tested, by
changing the <code class="docutils literal notranslate"><span class="pre">-c</span></code> option.</p>
</div>
<div class="section" id="acceptance-tests-using-the-avocado-framework">
<h2>Acceptance tests using the Avocado Framework<a class="headerlink" href="#acceptance-tests-using-the-avocado-framework" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">tests/acceptance</span></code> directory hosts functional tests, also known
as acceptance level tests.  They’re usually higher level tests, and
may interact with external resources and with various guest operating
systems.</p>
<p>These tests are written using the Avocado Testing Framework (which must
be installed separately) in conjunction with a the <code class="docutils literal notranslate"><span class="pre">avocado_qemu.Test</span></code>
class, implemented at <code class="docutils literal notranslate"><span class="pre">tests/acceptance/avocado_qemu</span></code>.</p>
<p>Tests based on <code class="docutils literal notranslate"><span class="pre">avocado_qemu.Test</span></code> can easily:</p>
<blockquote>
<div><ul class="simple">
<li>Customize the command line arguments given to the convenience
<code class="docutils literal notranslate"><span class="pre">self.vm</span></code> attribute (a QEMUMachine instance)</li>
<li>Interact with the QEMU monitor, send QMP commands and check
their results</li>
<li>Interact with the guest OS, using the convenience console device
(which may be useful to assert the effectiveness and correctness of
command line arguments or QMP commands)</li>
<li>Interact with external data files that accompany the test itself
(see <code class="docutils literal notranslate"><span class="pre">self.get_data()</span></code>)</li>
<li>Download (and cache) remote data files, such as firmware and kernel
images</li>
<li>Have access to a library of guest OS images (by means of the
<code class="docutils literal notranslate"><span class="pre">avocado.utils.vmimage</span></code> library)</li>
<li>Make use of various other test related utilities available at the
test class itself and at the utility library:<ul>
<li><a class="reference external" href="http://avocado-framework.readthedocs.io/en/latest/api/test/avocado.html#avocado.Test">http://avocado-framework.readthedocs.io/en/latest/api/test/avocado.html#avocado.Test</a></li>
<li><a class="reference external" href="http://avocado-framework.readthedocs.io/en/latest/api/utils/avocado.utils.html">http://avocado-framework.readthedocs.io/en/latest/api/utils/avocado.utils.html</a></li>
</ul>
</li>
</ul>
</div></blockquote>
<div class="section" id="running-tests">
<h3>Running tests<a class="headerlink" href="#running-tests" title="Permalink to this headline">¶</a></h3>
<p>You can run the acceptance tests simply by executing:</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">check</span><span class="o">-</span><span class="n">acceptance</span>
</pre></div>
</div>
<p>This involves the automatic creation of Python virtual environment
within the build tree (at <code class="docutils literal notranslate"><span class="pre">tests/venv</span></code>) which will have all the
right dependencies, and will save tests results also within the
build tree (at <code class="docutils literal notranslate"><span class="pre">tests/results</span></code>).</p>
<p>Note: the build environment must be using a Python 3 stack, and have
the <code class="docutils literal notranslate"><span class="pre">venv</span></code> and <code class="docutils literal notranslate"><span class="pre">pip</span></code> packages installed.  If necessary, make sure
<code class="docutils literal notranslate"><span class="pre">configure</span></code> is called with <code class="docutils literal notranslate"><span class="pre">--python=</span></code> and that those modules are
available.  On Debian and Ubuntu based systems, depending on the
specific version, they may be on packages named <code class="docutils literal notranslate"><span class="pre">python3-venv</span></code> and
<code class="docutils literal notranslate"><span class="pre">python3-pip</span></code>.</p>
<p>The scripts installed inside the virtual environment may be used
without an “activation”.  For instance, the Avocado test runner
may be invoked by running:</p>
<blockquote>
<div><div class="code highlight-default notranslate"><div class="highlight"><pre><span></span>tests/venv/bin/avocado run $OPTION1 $OPTION2 tests/acceptance/
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="manual-installation">
<h3>Manual Installation<a class="headerlink" href="#manual-installation" title="Permalink to this headline">¶</a></h3>
<p>To manually install Avocado and its dependencies, run:</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pip</span> <span class="n">install</span> <span class="o">--</span><span class="n">user</span> <span class="n">avocado</span><span class="o">-</span><span class="n">framework</span>
</pre></div>
</div>
<p>Alternatively, follow the instructions on this link:</p>
<blockquote>
<div><a class="reference external" href="https://avocado-framework.readthedocs.io/en/latest/guides/user/chapters/installing.html">https://avocado-framework.readthedocs.io/en/latest/guides/user/chapters/installing.html</a></div></blockquote>
</div>
<div class="section" id="overview">
<h3>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">tests/acceptance/avocado_qemu</span></code> directory provides the
<code class="docutils literal notranslate"><span class="pre">avocado_qemu</span></code> Python module, containing the <code class="docutils literal notranslate"><span class="pre">avocado_qemu.Test</span></code>
class.  Here’s a simple usage example:</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">avocado_qemu</span> <span class="k">import</span> <span class="n">Test</span>


<span class="k">class</span> <span class="nc">Version</span><span class="p">(</span><span class="n">Test</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :avocado: tags=quick</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">test_qmp_human_info_version</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vm</span><span class="o">.</span><span class="n">launch</span><span class="p">()</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vm</span><span class="o">.</span><span class="n">command</span><span class="p">(</span><span class="s1">&#39;human-monitor-command&#39;</span><span class="p">,</span>
                              <span class="n">command_line</span><span class="o">=</span><span class="s1">&#39;info version&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertRegexpMatches</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;^(\d+\.\d+\.\d)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>To execute your test, run:</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">avocado</span> <span class="n">run</span> <span class="n">version</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>Tests may be classified according to a convention by using docstring
directives such as <code class="docutils literal notranslate"><span class="pre">:avocado:</span> <span class="pre">tags=TAG1,TAG2</span></code>.  To run all tests
in the current directory, tagged as “quick”, run:</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">avocado</span> <span class="n">run</span> <span class="o">-</span><span class="n">t</span> <span class="n">quick</span> <span class="o">.</span>
</pre></div>
</div>
</div>
<div class="section" id="the-avocado-qemu-test-base-test-class">
<h3>The <code class="docutils literal notranslate"><span class="pre">avocado_qemu.Test</span></code> base test class<a class="headerlink" href="#the-avocado-qemu-test-base-test-class" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">avocado_qemu.Test</span></code> class has a number of characteristics that
are worth being mentioned right away.</p>
<p>First of all, it attempts to give each test a ready to use QEMUMachine
instance, available at <code class="docutils literal notranslate"><span class="pre">self.vm</span></code>.  Because many tests will tweak the
QEMU command line, launching the QEMUMachine (by using <code class="docutils literal notranslate"><span class="pre">self.vm.launch()</span></code>)
is left to the test writer.</p>
<p>The base test class has also support for tests with more than one
QEMUMachine. The way to get machines is through the <code class="docutils literal notranslate"><span class="pre">self.get_vm()</span></code>
method which will return a QEMUMachine instance. The <code class="docutils literal notranslate"><span class="pre">self.get_vm()</span></code>
method accepts arguments that will be passed to the QEMUMachine creation
and also an optional <cite>name</cite> attribute so you can identify a specific
machine and get it more than once through the tests methods. A simple
and hypothetical example follows:</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">avocado_qemu</span> <span class="k">import</span> <span class="n">Test</span>


<span class="k">class</span> <span class="nc">MultipleMachines</span><span class="p">(</span><span class="n">Test</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :avocado: enable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">test_multiple_machines</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">first_machine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_vm</span><span class="p">()</span>
        <span class="n">second_machine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_vm</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_vm</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;third_machine&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">launch</span><span class="p">()</span>

        <span class="n">first_machine</span><span class="o">.</span><span class="n">launch</span><span class="p">()</span>
        <span class="n">second_machine</span><span class="o">.</span><span class="n">launch</span><span class="p">()</span>

        <span class="n">first_res</span> <span class="o">=</span> <span class="n">first_machine</span><span class="o">.</span><span class="n">command</span><span class="p">(</span>
            <span class="s1">&#39;human-monitor-command&#39;</span><span class="p">,</span>
            <span class="n">command_line</span><span class="o">=</span><span class="s1">&#39;info version&#39;</span><span class="p">)</span>

        <span class="n">second_res</span> <span class="o">=</span> <span class="n">second_machine</span><span class="o">.</span><span class="n">command</span><span class="p">(</span>
            <span class="s1">&#39;human-monitor-command&#39;</span><span class="p">,</span>
            <span class="n">command_line</span><span class="o">=</span><span class="s1">&#39;info version&#39;</span><span class="p">)</span>

        <span class="n">third_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_vm</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;third_machine&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">command</span><span class="p">(</span>
            <span class="s1">&#39;human-monitor-command&#39;</span><span class="p">,</span>
            <span class="n">command_line</span><span class="o">=</span><span class="s1">&#39;info version&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">assertEquals</span><span class="p">(</span><span class="n">first_res</span><span class="p">,</span> <span class="n">second_res</span><span class="p">,</span> <span class="n">third_res</span><span class="p">)</span>
</pre></div>
</div>
<p>At test “tear down”, <code class="docutils literal notranslate"><span class="pre">avocado_qemu.Test</span></code> handles all the QEMUMachines
shutdown.</p>
<div class="section" id="qemumachine">
<h4>QEMUMachine<a class="headerlink" href="#qemumachine" title="Permalink to this headline">¶</a></h4>
<p>The QEMUMachine API is already widely used in the Python iotests,
device-crash-test and other Python scripts.  It’s a wrapper around the
execution of a QEMU binary, giving its users:</p>
<blockquote>
<div><ul class="simple">
<li>the ability to set command line arguments to be given to the QEMU
binary</li>
<li>a ready to use QMP connection and interface, which can be used to
send commands and inspect its results, as well as asynchronous
events</li>
<li>convenience methods to set commonly used command line arguments in
a more succinct and intuitive way</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="qemu-binary-selection">
<h4>QEMU binary selection<a class="headerlink" href="#qemu-binary-selection" title="Permalink to this headline">¶</a></h4>
<p>The QEMU binary used for the <code class="docutils literal notranslate"><span class="pre">self.vm</span></code> QEMUMachine instance will
primarily depend on the value of the <code class="docutils literal notranslate"><span class="pre">qemu_bin</span></code> parameter.  If it’s
not explicitly set, its default value will be the result of a dynamic
probe in the same source tree.  A suitable binary will be one that
targets the architecture matching host machine.</p>
<p>Based on this description, test writers will usually rely on one of
the following approaches:</p>
<ol class="arabic simple">
<li>Set <code class="docutils literal notranslate"><span class="pre">qemu_bin</span></code>, and use the given binary</li>
<li>Do not set <code class="docutils literal notranslate"><span class="pre">qemu_bin</span></code>, and use a QEMU binary named like
“qemu-system-${arch}”, either in the current
working directory, or in the current source tree.</li>
</ol>
<p>The resulting <code class="docutils literal notranslate"><span class="pre">qemu_bin</span></code> value will be preserved in the
<code class="docutils literal notranslate"><span class="pre">avocado_qemu.Test</span></code> as an attribute with the same name.</p>
</div>
</div>
<div class="section" id="attribute-reference">
<h3>Attribute reference<a class="headerlink" href="#attribute-reference" title="Permalink to this headline">¶</a></h3>
<p>Besides the attributes and methods that are part of the base
<code class="docutils literal notranslate"><span class="pre">avocado.Test</span></code> class, the following attributes are available on any
<code class="docutils literal notranslate"><span class="pre">avocado_qemu.Test</span></code> instance.</p>
<div class="section" id="vm">
<h4>vm<a class="headerlink" href="#vm" title="Permalink to this headline">¶</a></h4>
<p>A QEMUMachine instance, initially configured according to the given
<code class="docutils literal notranslate"><span class="pre">qemu_bin</span></code> parameter.</p>
</div>
<div class="section" id="arch">
<h4>arch<a class="headerlink" href="#arch" title="Permalink to this headline">¶</a></h4>
<p>The architecture can be used on different levels of the stack, e.g. by
the framework or by the test itself.  At the framework level, it will
currently influence the selection of a QEMU binary (when one is not
explicitly given).</p>
<p>Tests are also free to use this attribute value, for their own needs.
A test may, for instance, use the same value when selecting the
architecture of a kernel or disk image to boot a VM with.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">arch</span></code> attribute will be set to the test parameter of the same
name.  If one is not given explicitly, it will either be set to
<code class="docutils literal notranslate"><span class="pre">None</span></code>, or, if the test is tagged with one (and only one)
<code class="docutils literal notranslate"><span class="pre">:avocado:</span> <span class="pre">tags=arch:VALUE</span></code> tag, it will be set to <code class="docutils literal notranslate"><span class="pre">VALUE</span></code>.</p>
</div>
<div class="section" id="machine">
<h4>machine<a class="headerlink" href="#machine" title="Permalink to this headline">¶</a></h4>
<p>The machine type that will be set to all QEMUMachine instances created
by the test.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">machine</span></code> attribute will be set to the test parameter of the same
name.  If one is not given explicitly, it will either be set to
<code class="docutils literal notranslate"><span class="pre">None</span></code>, or, if the test is tagged with one (and only one)
<code class="docutils literal notranslate"><span class="pre">:avocado:</span> <span class="pre">tags=machine:VALUE</span></code> tag, it will be set to <code class="docutils literal notranslate"><span class="pre">VALUE</span></code>.</p>
</div>
<div class="section" id="qemu-bin">
<h4>qemu_bin<a class="headerlink" href="#qemu-bin" title="Permalink to this headline">¶</a></h4>
<p>The preserved value of the <code class="docutils literal notranslate"><span class="pre">qemu_bin</span></code> parameter or the result of the
dynamic probe for a QEMU binary in the current working directory or
source tree.</p>
</div>
</div>
<div class="section" id="parameter-reference">
<h3>Parameter reference<a class="headerlink" href="#parameter-reference" title="Permalink to this headline">¶</a></h3>
<p>To understand how Avocado parameters are accessed by tests, and how
they can be passed to tests, please refer to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">avocado</span><span class="o">-</span><span class="n">framework</span><span class="o">.</span><span class="n">readthedocs</span><span class="o">.</span><span class="n">io</span><span class="o">/</span><span class="n">en</span><span class="o">/</span><span class="n">latest</span><span class="o">/</span><span class="n">guides</span><span class="o">/</span><span class="n">writer</span><span class="o">/</span><span class="n">chapters</span><span class="o">/</span><span class="n">writing</span><span class="o">.</span><span class="n">html</span><span class="c1">#accessing-test-parameters</span>
</pre></div>
</div>
<p>Parameter values can be easily seen in the log files, and will look
like the following:</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PARAMS</span> <span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">qemu_bin</span><span class="p">,</span> <span class="n">path</span><span class="o">=*</span><span class="p">,</span> <span class="n">default</span><span class="o">=./</span><span class="n">qemu</span><span class="o">-</span><span class="n">system</span><span class="o">-</span><span class="n">x86_64</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="s1">&#39;./qemu-system-x86_64</span>
</pre></div>
</div>
<div class="section" id="id2">
<h4>arch<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>The architecture that will influence the selection of a QEMU binary
(when one is not explicitly given).</p>
<p>Tests are also free to use this parameter value, for their own needs.
A test may, for instance, use the same value when selecting the
architecture of a kernel or disk image to boot a VM with.</p>
<p>This parameter has a direct relation with the <code class="docutils literal notranslate"><span class="pre">arch</span></code> attribute.  If
not given, it will default to None.</p>
</div>
<div class="section" id="id3">
<h4>machine<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>The machine type that will be set to all QEMUMachine instances created
by the test.</p>
</div>
<div class="section" id="id4">
<h4>qemu_bin<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>The exact QEMU binary to be used on QEMUMachine.</p>
</div>
</div>
<div class="section" id="uninstalling-avocado">
<h3>Uninstalling Avocado<a class="headerlink" href="#uninstalling-avocado" title="Permalink to this headline">¶</a></h3>
<p>If you’ve followed the manual installation instructions above, you can
easily uninstall Avocado.  Start by listing the packages you have
installed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pip</span> <span class="nb">list</span> <span class="o">--</span><span class="n">user</span>
</pre></div>
</div>
<p>And remove any package you want with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pip</span> <span class="n">uninstall</span> <span class="o">&lt;</span><span class="n">package_name</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>If you’ve used <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">check-acceptance</span></code>, the Python virtual environment where
Avocado is installed will be cleaned up as part of <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">check-clean</span></code>.</p>
</div>
</div>
<div class="section" id="testing-with-make-check-tcg">
<h2>Testing with “make check-tcg”<a class="headerlink" href="#testing-with-make-check-tcg" title="Permalink to this headline">¶</a></h2>
<p>The check-tcg tests are intended for simple smoke tests of both
linux-user and softmmu TCG functionality. However to build test
programs for guest targets you need to have cross compilers available.
If your distribution supports cross compilers you can do something as
simple as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">apt</span> <span class="n">install</span> <span class="n">gcc</span><span class="o">-</span><span class="n">aarch64</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">gnu</span>
</pre></div>
</div>
<p>The configure script will automatically pick up their presence.
Sometimes compilers have slightly odd names so the availability of
them can be prompted by passing in the appropriate configure option
for the architecture in question, for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$(configure) --cross-cc-aarch64=aarch64-cc
</pre></div>
</div>
<p>There is also a <code class="docutils literal notranslate"><span class="pre">--cross-cc-flags-ARCH</span></code> flag in case additional
compiler flags are needed to build for a given target.</p>
<p>If you have the ability to run containers as the user you can also
take advantage of the build systems “Docker” support. It will then use
containers to build any test case for an enabled guest where there is
no system compiler available. See <a class="reference internal" href="#docker-ref"><span class="std std-ref">Docker based tests</span></a> for details.</p>
<div class="section" id="running-subset-of-tests">
<h3>Running subset of tests<a class="headerlink" href="#running-subset-of-tests" title="Permalink to this headline">¶</a></h3>
<p>You can build the tests for one architecture:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>make build-tcg-tests-$TARGET
</pre></div>
</div>
<p>And run with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>make run-tcg-tests-$TARGET
</pre></div>
</div>
<p>Adding <code class="docutils literal notranslate"><span class="pre">V=1</span></code> to the invocation will show the details of how to
invoke QEMU for the test which is useful for debugging tests.</p>
</div>
<div class="section" id="tcg-test-dependencies">
<h3>TCG test dependencies<a class="headerlink" href="#tcg-test-dependencies" title="Permalink to this headline">¶</a></h3>
<p>The TCG tests are deliberately very light on dependencies and are
either totally bare with minimal gcc lib support (for softmmu tests)
or just glibc (for linux-user tests). This is because getting a cross
compiler to work with additional libraries can be challenging.</p>
</div>
<div class="section" id="other-tcg-tests">
<h3>Other TCG Tests<a class="headerlink" href="#other-tcg-tests" title="Permalink to this headline">¶</a></h3>
<p>There are a number of out-of-tree test suites that are used for more
extensive testing of processor features.</p>
<div class="section" id="kvm-unit-tests">
<h4>KVM Unit Tests<a class="headerlink" href="#kvm-unit-tests" title="Permalink to this headline">¶</a></h4>
<p>The KVM unit tests are designed to run as a Guest OS under KVM but
there is no reason why they can’t exercise the TCG as well. It
provides a minimal OS kernel with hooks for enabling the MMU as well
as reporting test results via a special device:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">git</span><span class="o">.</span><span class="n">kernel</span><span class="o">.</span><span class="n">org</span><span class="o">/</span><span class="n">pub</span><span class="o">/</span><span class="n">scm</span><span class="o">/</span><span class="n">virt</span><span class="o">/</span><span class="n">kvm</span><span class="o">/</span><span class="n">kvm</span><span class="o">-</span><span class="n">unit</span><span class="o">-</span><span class="n">tests</span><span class="o">.</span><span class="n">git</span>
</pre></div>
</div>
</div>
<div class="section" id="linux-test-project">
<h4>Linux Test Project<a class="headerlink" href="#linux-test-project" title="Permalink to this headline">¶</a></h4>
<p>The LTP is focused on exercising the syscall interface of a Linux
kernel. It checks that syscalls behave as documented and strives to
exercise as many corner cases as possible. It is a useful test suite
to run to exercise QEMU’s linux-user code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">linux</span><span class="o">-</span><span class="n">test</span><span class="o">-</span><span class="n">project</span><span class="o">.</span><span class="n">github</span><span class="o">.</span><span class="n">io</span><span class="o">/</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">QEMU</a></h1>



<p class="blurb">Developers Guide</p>






<div id="editpage">
  <ul>
    <li><a href="https://gitlab.com/qemu-project/qemu/-/blob/master/docs/devel/testing.rst">Page source</a></li>
  </ul>
</div><h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="build-system.html">The QEMU build system architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="kconfig.html">QEMU and Kconfig</a></li>
<li class="toctree-l1"><a class="reference internal" href="loads-stores.html">Load and Store APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="memory.html">The memory API</a></li>
<li class="toctree-l1"><a class="reference internal" href="migration.html">Migration</a></li>
<li class="toctree-l1"><a class="reference internal" href="atomics.html">Atomic operations in QEMU</a></li>
<li class="toctree-l1"><a class="reference internal" href="stable-process.html">QEMU and the stable process</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Testing in QEMU</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#testing-with-make-check">Testing with “make check”</a></li>
<li class="toctree-l2"><a class="reference internal" href="#qemu-iotests">QEMU iotests</a></li>
<li class="toctree-l2"><a class="reference internal" href="#docker-based-tests">Docker based tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="#thread-sanitizer">Thread Sanitizer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#vm-testing">VM testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="#image-fuzzer-testing">Image fuzzer testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="#acceptance-tests-using-the-avocado-framework">Acceptance tests using the Avocado Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="#testing-with-make-check-tcg">Testing with “make check-tcg”</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="qtest.html">QTest Device Emulation Testing Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="fuzzing.html">Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="decodetree.html">Decodetree Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="secure-coding-practices.html">Secure Coding Practices</a></li>
<li class="toctree-l1"><a class="reference internal" href="tcg.html">Translator Internals</a></li>
<li class="toctree-l1"><a class="reference internal" href="tcg-icount.html">TCG Instruction Counting</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi-thread-tcg.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi-thread-tcg.html#vcpu-scheduling">vCPU Scheduling</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi-thread-tcg.html#shared-data-structures">Shared Data Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="multi-thread-tcg.html#memory-consistency">Memory Consistency</a></li>
<li class="toctree-l1"><a class="reference internal" href="tcg-plugins.html">QEMU TCG Plugins</a></li>
<li class="toctree-l1"><a class="reference internal" href="bitops.html">Bitwise operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="reset.html">Reset in QEMU: the Resettable interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="s390-dasd-ipl.html">Booting from real channel-attached devices on s390x</a></li>
<li class="toctree-l1"><a class="reference internal" href="clocks.html">Modelling a clock tree in QEMU</a></li>
<li class="toctree-l1"><a class="reference internal" href="qom.html">The QEMU Object Model (QOM)</a></li>
<li class="toctree-l1"><a class="reference internal" href="block-coroutine-wrapper.html">block-coroutine-wrapper</a></li>
</ul>


<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, The QEMU Project Developers.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>