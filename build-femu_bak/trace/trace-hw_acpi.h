/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_ACPI_GENERATED_TRACERS_H
#define TRACE_HW_ACPI_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_MHP_ACPI_INVALID_SLOT_SELECTED_EVENT;
extern TraceEvent _TRACE_MHP_ACPI_EJECTING_INVALID_SLOT_EVENT;
extern TraceEvent _TRACE_MHP_ACPI_READ_ADDR_LO_EVENT;
extern TraceEvent _TRACE_MHP_ACPI_READ_ADDR_HI_EVENT;
extern TraceEvent _TRACE_MHP_ACPI_READ_SIZE_LO_EVENT;
extern TraceEvent _TRACE_MHP_ACPI_READ_SIZE_HI_EVENT;
extern TraceEvent _TRACE_MHP_ACPI_READ_PXM_EVENT;
extern TraceEvent _TRACE_MHP_ACPI_READ_FLAGS_EVENT;
extern TraceEvent _TRACE_MHP_ACPI_WRITE_SLOT_EVENT;
extern TraceEvent _TRACE_MHP_ACPI_WRITE_OST_EV_EVENT;
extern TraceEvent _TRACE_MHP_ACPI_WRITE_OST_STATUS_EVENT;
extern TraceEvent _TRACE_MHP_ACPI_CLEAR_INSERT_EVT_EVENT;
extern TraceEvent _TRACE_MHP_ACPI_CLEAR_REMOVE_EVT_EVENT;
extern TraceEvent _TRACE_MHP_ACPI_PC_DIMM_DELETED_EVENT;
extern TraceEvent _TRACE_MHP_ACPI_PC_DIMM_DELETE_FAILED_EVENT;
extern TraceEvent _TRACE_CPUHP_ACPI_INVALID_IDX_SELECTED_EVENT;
extern TraceEvent _TRACE_CPUHP_ACPI_READ_FLAGS_EVENT;
extern TraceEvent _TRACE_CPUHP_ACPI_WRITE_IDX_EVENT;
extern TraceEvent _TRACE_CPUHP_ACPI_WRITE_CMD_EVENT;
extern TraceEvent _TRACE_CPUHP_ACPI_READ_CMD_DATA_EVENT;
extern TraceEvent _TRACE_CPUHP_ACPI_READ_CMD_DATA2_EVENT;
extern TraceEvent _TRACE_CPUHP_ACPI_CPU_HAS_EVENTS_EVENT;
extern TraceEvent _TRACE_CPUHP_ACPI_CLEAR_INSERTING_EVT_EVENT;
extern TraceEvent _TRACE_CPUHP_ACPI_CLEAR_REMOVE_EVT_EVENT;
extern TraceEvent _TRACE_CPUHP_ACPI_EJECTING_INVALID_CPU_EVENT;
extern TraceEvent _TRACE_CPUHP_ACPI_EJECTING_CPU_EVENT;
extern TraceEvent _TRACE_CPUHP_ACPI_WRITE_OST_EV_EVENT;
extern TraceEvent _TRACE_CPUHP_ACPI_WRITE_OST_STATUS_EVENT;
extern TraceEvent _TRACE_ACPI_PCI_EJECT_SLOT_EVENT;
extern TraceEvent _TRACE_ACPI_PCI_UNPLUG_EVENT;
extern TraceEvent _TRACE_ACPI_PCI_UNPLUG_REQUEST_EVENT;
extern TraceEvent _TRACE_ACPI_PCI_UP_READ_EVENT;
extern TraceEvent _TRACE_ACPI_PCI_DOWN_READ_EVENT;
extern TraceEvent _TRACE_ACPI_PCI_FEATURES_READ_EVENT;
extern TraceEvent _TRACE_ACPI_PCI_RMV_READ_EVENT;
extern TraceEvent _TRACE_ACPI_PCI_SEL_READ_EVENT;
extern TraceEvent _TRACE_ACPI_PCI_EJ_WRITE_EVENT;
extern TraceEvent _TRACE_ACPI_PCI_SEL_WRITE_EVENT;
extern TraceEvent _TRACE_PIIX4_GPE_READB_EVENT;
extern TraceEvent _TRACE_PIIX4_GPE_WRITEB_EVENT;
extern TraceEvent _TRACE_TCO_TIMER_RELOAD_EVENT;
extern TraceEvent _TRACE_TCO_TIMER_EXPIRED_EVENT;
extern uint16_t _TRACE_MHP_ACPI_INVALID_SLOT_SELECTED_DSTATE;
extern uint16_t _TRACE_MHP_ACPI_EJECTING_INVALID_SLOT_DSTATE;
extern uint16_t _TRACE_MHP_ACPI_READ_ADDR_LO_DSTATE;
extern uint16_t _TRACE_MHP_ACPI_READ_ADDR_HI_DSTATE;
extern uint16_t _TRACE_MHP_ACPI_READ_SIZE_LO_DSTATE;
extern uint16_t _TRACE_MHP_ACPI_READ_SIZE_HI_DSTATE;
extern uint16_t _TRACE_MHP_ACPI_READ_PXM_DSTATE;
extern uint16_t _TRACE_MHP_ACPI_READ_FLAGS_DSTATE;
extern uint16_t _TRACE_MHP_ACPI_WRITE_SLOT_DSTATE;
extern uint16_t _TRACE_MHP_ACPI_WRITE_OST_EV_DSTATE;
extern uint16_t _TRACE_MHP_ACPI_WRITE_OST_STATUS_DSTATE;
extern uint16_t _TRACE_MHP_ACPI_CLEAR_INSERT_EVT_DSTATE;
extern uint16_t _TRACE_MHP_ACPI_CLEAR_REMOVE_EVT_DSTATE;
extern uint16_t _TRACE_MHP_ACPI_PC_DIMM_DELETED_DSTATE;
extern uint16_t _TRACE_MHP_ACPI_PC_DIMM_DELETE_FAILED_DSTATE;
extern uint16_t _TRACE_CPUHP_ACPI_INVALID_IDX_SELECTED_DSTATE;
extern uint16_t _TRACE_CPUHP_ACPI_READ_FLAGS_DSTATE;
extern uint16_t _TRACE_CPUHP_ACPI_WRITE_IDX_DSTATE;
extern uint16_t _TRACE_CPUHP_ACPI_WRITE_CMD_DSTATE;
extern uint16_t _TRACE_CPUHP_ACPI_READ_CMD_DATA_DSTATE;
extern uint16_t _TRACE_CPUHP_ACPI_READ_CMD_DATA2_DSTATE;
extern uint16_t _TRACE_CPUHP_ACPI_CPU_HAS_EVENTS_DSTATE;
extern uint16_t _TRACE_CPUHP_ACPI_CLEAR_INSERTING_EVT_DSTATE;
extern uint16_t _TRACE_CPUHP_ACPI_CLEAR_REMOVE_EVT_DSTATE;
extern uint16_t _TRACE_CPUHP_ACPI_EJECTING_INVALID_CPU_DSTATE;
extern uint16_t _TRACE_CPUHP_ACPI_EJECTING_CPU_DSTATE;
extern uint16_t _TRACE_CPUHP_ACPI_WRITE_OST_EV_DSTATE;
extern uint16_t _TRACE_CPUHP_ACPI_WRITE_OST_STATUS_DSTATE;
extern uint16_t _TRACE_ACPI_PCI_EJECT_SLOT_DSTATE;
extern uint16_t _TRACE_ACPI_PCI_UNPLUG_DSTATE;
extern uint16_t _TRACE_ACPI_PCI_UNPLUG_REQUEST_DSTATE;
extern uint16_t _TRACE_ACPI_PCI_UP_READ_DSTATE;
extern uint16_t _TRACE_ACPI_PCI_DOWN_READ_DSTATE;
extern uint16_t _TRACE_ACPI_PCI_FEATURES_READ_DSTATE;
extern uint16_t _TRACE_ACPI_PCI_RMV_READ_DSTATE;
extern uint16_t _TRACE_ACPI_PCI_SEL_READ_DSTATE;
extern uint16_t _TRACE_ACPI_PCI_EJ_WRITE_DSTATE;
extern uint16_t _TRACE_ACPI_PCI_SEL_WRITE_DSTATE;
extern uint16_t _TRACE_PIIX4_GPE_READB_DSTATE;
extern uint16_t _TRACE_PIIX4_GPE_WRITEB_DSTATE;
extern uint16_t _TRACE_TCO_TIMER_RELOAD_DSTATE;
extern uint16_t _TRACE_TCO_TIMER_EXPIRED_DSTATE;
#define TRACE_MHP_ACPI_INVALID_SLOT_SELECTED_ENABLED 1
#define TRACE_MHP_ACPI_EJECTING_INVALID_SLOT_ENABLED 1
#define TRACE_MHP_ACPI_READ_ADDR_LO_ENABLED 1
#define TRACE_MHP_ACPI_READ_ADDR_HI_ENABLED 1
#define TRACE_MHP_ACPI_READ_SIZE_LO_ENABLED 1
#define TRACE_MHP_ACPI_READ_SIZE_HI_ENABLED 1
#define TRACE_MHP_ACPI_READ_PXM_ENABLED 1
#define TRACE_MHP_ACPI_READ_FLAGS_ENABLED 1
#define TRACE_MHP_ACPI_WRITE_SLOT_ENABLED 1
#define TRACE_MHP_ACPI_WRITE_OST_EV_ENABLED 1
#define TRACE_MHP_ACPI_WRITE_OST_STATUS_ENABLED 1
#define TRACE_MHP_ACPI_CLEAR_INSERT_EVT_ENABLED 1
#define TRACE_MHP_ACPI_CLEAR_REMOVE_EVT_ENABLED 1
#define TRACE_MHP_ACPI_PC_DIMM_DELETED_ENABLED 1
#define TRACE_MHP_ACPI_PC_DIMM_DELETE_FAILED_ENABLED 1
#define TRACE_CPUHP_ACPI_INVALID_IDX_SELECTED_ENABLED 1
#define TRACE_CPUHP_ACPI_READ_FLAGS_ENABLED 1
#define TRACE_CPUHP_ACPI_WRITE_IDX_ENABLED 1
#define TRACE_CPUHP_ACPI_WRITE_CMD_ENABLED 1
#define TRACE_CPUHP_ACPI_READ_CMD_DATA_ENABLED 1
#define TRACE_CPUHP_ACPI_READ_CMD_DATA2_ENABLED 1
#define TRACE_CPUHP_ACPI_CPU_HAS_EVENTS_ENABLED 1
#define TRACE_CPUHP_ACPI_CLEAR_INSERTING_EVT_ENABLED 1
#define TRACE_CPUHP_ACPI_CLEAR_REMOVE_EVT_ENABLED 1
#define TRACE_CPUHP_ACPI_EJECTING_INVALID_CPU_ENABLED 1
#define TRACE_CPUHP_ACPI_EJECTING_CPU_ENABLED 1
#define TRACE_CPUHP_ACPI_WRITE_OST_EV_ENABLED 1
#define TRACE_CPUHP_ACPI_WRITE_OST_STATUS_ENABLED 1
#define TRACE_ACPI_PCI_EJECT_SLOT_ENABLED 1
#define TRACE_ACPI_PCI_UNPLUG_ENABLED 1
#define TRACE_ACPI_PCI_UNPLUG_REQUEST_ENABLED 1
#define TRACE_ACPI_PCI_UP_READ_ENABLED 1
#define TRACE_ACPI_PCI_DOWN_READ_ENABLED 1
#define TRACE_ACPI_PCI_FEATURES_READ_ENABLED 1
#define TRACE_ACPI_PCI_RMV_READ_ENABLED 1
#define TRACE_ACPI_PCI_SEL_READ_ENABLED 1
#define TRACE_ACPI_PCI_EJ_WRITE_ENABLED 1
#define TRACE_ACPI_PCI_SEL_WRITE_ENABLED 1
#define TRACE_PIIX4_GPE_READB_ENABLED 1
#define TRACE_PIIX4_GPE_WRITEB_ENABLED 1
#define TRACE_TCO_TIMER_RELOAD_ENABLED 1
#define TRACE_TCO_TIMER_EXPIRED_ENABLED 1
#include "qemu/log-for-trace.h"


#define TRACE_MHP_ACPI_INVALID_SLOT_SELECTED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MHP_ACPI_INVALID_SLOT_SELECTED) || \
    false)

static inline void _nocheck__trace_mhp_acpi_invalid_slot_selected(uint32_t slot)
{
    if (trace_event_get_state(TRACE_MHP_ACPI_INVALID_SLOT_SELECTED) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:mhp_acpi_invalid_slot_selected " "0x%"PRIx32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , slot);
    }
}

static inline void trace_mhp_acpi_invalid_slot_selected(uint32_t slot)
{
    if (true) {
        _nocheck__trace_mhp_acpi_invalid_slot_selected(slot);
    }
}

#define TRACE_MHP_ACPI_EJECTING_INVALID_SLOT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MHP_ACPI_EJECTING_INVALID_SLOT) || \
    false)

static inline void _nocheck__trace_mhp_acpi_ejecting_invalid_slot(uint32_t slot)
{
    if (trace_event_get_state(TRACE_MHP_ACPI_EJECTING_INVALID_SLOT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:mhp_acpi_ejecting_invalid_slot " "0x%"PRIx32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , slot);
    }
}

static inline void trace_mhp_acpi_ejecting_invalid_slot(uint32_t slot)
{
    if (true) {
        _nocheck__trace_mhp_acpi_ejecting_invalid_slot(slot);
    }
}

#define TRACE_MHP_ACPI_READ_ADDR_LO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MHP_ACPI_READ_ADDR_LO) || \
    false)

static inline void _nocheck__trace_mhp_acpi_read_addr_lo(uint32_t slot, uint32_t addr)
{
    if (trace_event_get_state(TRACE_MHP_ACPI_READ_ADDR_LO) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:mhp_acpi_read_addr_lo " "slot[0x%"PRIx32"] addr lo: 0x%"PRIx32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , slot, addr);
    }
}

static inline void trace_mhp_acpi_read_addr_lo(uint32_t slot, uint32_t addr)
{
    if (true) {
        _nocheck__trace_mhp_acpi_read_addr_lo(slot, addr);
    }
}

#define TRACE_MHP_ACPI_READ_ADDR_HI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MHP_ACPI_READ_ADDR_HI) || \
    false)

static inline void _nocheck__trace_mhp_acpi_read_addr_hi(uint32_t slot, uint32_t addr)
{
    if (trace_event_get_state(TRACE_MHP_ACPI_READ_ADDR_HI) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:mhp_acpi_read_addr_hi " "slot[0x%"PRIx32"] addr hi: 0x%"PRIx32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , slot, addr);
    }
}

static inline void trace_mhp_acpi_read_addr_hi(uint32_t slot, uint32_t addr)
{
    if (true) {
        _nocheck__trace_mhp_acpi_read_addr_hi(slot, addr);
    }
}

#define TRACE_MHP_ACPI_READ_SIZE_LO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MHP_ACPI_READ_SIZE_LO) || \
    false)

static inline void _nocheck__trace_mhp_acpi_read_size_lo(uint32_t slot, uint32_t size)
{
    if (trace_event_get_state(TRACE_MHP_ACPI_READ_SIZE_LO) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:mhp_acpi_read_size_lo " "slot[0x%"PRIx32"] size lo: 0x%"PRIx32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , slot, size);
    }
}

static inline void trace_mhp_acpi_read_size_lo(uint32_t slot, uint32_t size)
{
    if (true) {
        _nocheck__trace_mhp_acpi_read_size_lo(slot, size);
    }
}

#define TRACE_MHP_ACPI_READ_SIZE_HI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MHP_ACPI_READ_SIZE_HI) || \
    false)

static inline void _nocheck__trace_mhp_acpi_read_size_hi(uint32_t slot, uint32_t size)
{
    if (trace_event_get_state(TRACE_MHP_ACPI_READ_SIZE_HI) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:mhp_acpi_read_size_hi " "slot[0x%"PRIx32"] size hi: 0x%"PRIx32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , slot, size);
    }
}

static inline void trace_mhp_acpi_read_size_hi(uint32_t slot, uint32_t size)
{
    if (true) {
        _nocheck__trace_mhp_acpi_read_size_hi(slot, size);
    }
}

#define TRACE_MHP_ACPI_READ_PXM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MHP_ACPI_READ_PXM) || \
    false)

static inline void _nocheck__trace_mhp_acpi_read_pxm(uint32_t slot, uint32_t pxm)
{
    if (trace_event_get_state(TRACE_MHP_ACPI_READ_PXM) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:mhp_acpi_read_pxm " "slot[0x%"PRIx32"] proximity: 0x%"PRIx32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , slot, pxm);
    }
}

static inline void trace_mhp_acpi_read_pxm(uint32_t slot, uint32_t pxm)
{
    if (true) {
        _nocheck__trace_mhp_acpi_read_pxm(slot, pxm);
    }
}

#define TRACE_MHP_ACPI_READ_FLAGS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MHP_ACPI_READ_FLAGS) || \
    false)

static inline void _nocheck__trace_mhp_acpi_read_flags(uint32_t slot, uint32_t flags)
{
    if (trace_event_get_state(TRACE_MHP_ACPI_READ_FLAGS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:mhp_acpi_read_flags " "slot[0x%"PRIx32"] flags: 0x%"PRIx32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , slot, flags);
    }
}

static inline void trace_mhp_acpi_read_flags(uint32_t slot, uint32_t flags)
{
    if (true) {
        _nocheck__trace_mhp_acpi_read_flags(slot, flags);
    }
}

#define TRACE_MHP_ACPI_WRITE_SLOT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MHP_ACPI_WRITE_SLOT) || \
    false)

static inline void _nocheck__trace_mhp_acpi_write_slot(uint32_t slot)
{
    if (trace_event_get_state(TRACE_MHP_ACPI_WRITE_SLOT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:mhp_acpi_write_slot " "set active slot: 0x%"PRIx32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , slot);
    }
}

static inline void trace_mhp_acpi_write_slot(uint32_t slot)
{
    if (true) {
        _nocheck__trace_mhp_acpi_write_slot(slot);
    }
}

#define TRACE_MHP_ACPI_WRITE_OST_EV_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MHP_ACPI_WRITE_OST_EV) || \
    false)

static inline void _nocheck__trace_mhp_acpi_write_ost_ev(uint32_t slot, uint32_t ev)
{
    if (trace_event_get_state(TRACE_MHP_ACPI_WRITE_OST_EV) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:mhp_acpi_write_ost_ev " "slot[0x%"PRIx32"] OST EVENT: 0x%"PRIx32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , slot, ev);
    }
}

static inline void trace_mhp_acpi_write_ost_ev(uint32_t slot, uint32_t ev)
{
    if (true) {
        _nocheck__trace_mhp_acpi_write_ost_ev(slot, ev);
    }
}

#define TRACE_MHP_ACPI_WRITE_OST_STATUS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MHP_ACPI_WRITE_OST_STATUS) || \
    false)

static inline void _nocheck__trace_mhp_acpi_write_ost_status(uint32_t slot, uint32_t st)
{
    if (trace_event_get_state(TRACE_MHP_ACPI_WRITE_OST_STATUS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:mhp_acpi_write_ost_status " "slot[0x%"PRIx32"] OST STATUS: 0x%"PRIx32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , slot, st);
    }
}

static inline void trace_mhp_acpi_write_ost_status(uint32_t slot, uint32_t st)
{
    if (true) {
        _nocheck__trace_mhp_acpi_write_ost_status(slot, st);
    }
}

#define TRACE_MHP_ACPI_CLEAR_INSERT_EVT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MHP_ACPI_CLEAR_INSERT_EVT) || \
    false)

static inline void _nocheck__trace_mhp_acpi_clear_insert_evt(uint32_t slot)
{
    if (trace_event_get_state(TRACE_MHP_ACPI_CLEAR_INSERT_EVT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:mhp_acpi_clear_insert_evt " "slot[0x%"PRIx32"] clear insert event" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , slot);
    }
}

static inline void trace_mhp_acpi_clear_insert_evt(uint32_t slot)
{
    if (true) {
        _nocheck__trace_mhp_acpi_clear_insert_evt(slot);
    }
}

#define TRACE_MHP_ACPI_CLEAR_REMOVE_EVT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MHP_ACPI_CLEAR_REMOVE_EVT) || \
    false)

static inline void _nocheck__trace_mhp_acpi_clear_remove_evt(uint32_t slot)
{
    if (trace_event_get_state(TRACE_MHP_ACPI_CLEAR_REMOVE_EVT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:mhp_acpi_clear_remove_evt " "slot[0x%"PRIx32"] clear remove event" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , slot);
    }
}

static inline void trace_mhp_acpi_clear_remove_evt(uint32_t slot)
{
    if (true) {
        _nocheck__trace_mhp_acpi_clear_remove_evt(slot);
    }
}

#define TRACE_MHP_ACPI_PC_DIMM_DELETED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MHP_ACPI_PC_DIMM_DELETED) || \
    false)

static inline void _nocheck__trace_mhp_acpi_pc_dimm_deleted(uint32_t slot)
{
    if (trace_event_get_state(TRACE_MHP_ACPI_PC_DIMM_DELETED) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:mhp_acpi_pc_dimm_deleted " "slot[0x%"PRIx32"] pc-dimm deleted" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , slot);
    }
}

static inline void trace_mhp_acpi_pc_dimm_deleted(uint32_t slot)
{
    if (true) {
        _nocheck__trace_mhp_acpi_pc_dimm_deleted(slot);
    }
}

#define TRACE_MHP_ACPI_PC_DIMM_DELETE_FAILED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MHP_ACPI_PC_DIMM_DELETE_FAILED) || \
    false)

static inline void _nocheck__trace_mhp_acpi_pc_dimm_delete_failed(uint32_t slot)
{
    if (trace_event_get_state(TRACE_MHP_ACPI_PC_DIMM_DELETE_FAILED) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:mhp_acpi_pc_dimm_delete_failed " "slot[0x%"PRIx32"] pc-dimm delete failed" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , slot);
    }
}

static inline void trace_mhp_acpi_pc_dimm_delete_failed(uint32_t slot)
{
    if (true) {
        _nocheck__trace_mhp_acpi_pc_dimm_delete_failed(slot);
    }
}

#define TRACE_CPUHP_ACPI_INVALID_IDX_SELECTED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPUHP_ACPI_INVALID_IDX_SELECTED) || \
    false)

static inline void _nocheck__trace_cpuhp_acpi_invalid_idx_selected(uint32_t idx)
{
    if (trace_event_get_state(TRACE_CPUHP_ACPI_INVALID_IDX_SELECTED) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:cpuhp_acpi_invalid_idx_selected " "0x%"PRIx32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , idx);
    }
}

static inline void trace_cpuhp_acpi_invalid_idx_selected(uint32_t idx)
{
    if (true) {
        _nocheck__trace_cpuhp_acpi_invalid_idx_selected(idx);
    }
}

#define TRACE_CPUHP_ACPI_READ_FLAGS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPUHP_ACPI_READ_FLAGS) || \
    false)

static inline void _nocheck__trace_cpuhp_acpi_read_flags(uint32_t idx, uint8_t flags)
{
    if (trace_event_get_state(TRACE_CPUHP_ACPI_READ_FLAGS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:cpuhp_acpi_read_flags " "idx[0x%"PRIx32"] flags: 0x%"PRIx8 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , idx, flags);
    }
}

static inline void trace_cpuhp_acpi_read_flags(uint32_t idx, uint8_t flags)
{
    if (true) {
        _nocheck__trace_cpuhp_acpi_read_flags(idx, flags);
    }
}

#define TRACE_CPUHP_ACPI_WRITE_IDX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPUHP_ACPI_WRITE_IDX) || \
    false)

static inline void _nocheck__trace_cpuhp_acpi_write_idx(uint32_t idx)
{
    if (trace_event_get_state(TRACE_CPUHP_ACPI_WRITE_IDX) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:cpuhp_acpi_write_idx " "set active cpu idx: 0x%"PRIx32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , idx);
    }
}

static inline void trace_cpuhp_acpi_write_idx(uint32_t idx)
{
    if (true) {
        _nocheck__trace_cpuhp_acpi_write_idx(idx);
    }
}

#define TRACE_CPUHP_ACPI_WRITE_CMD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPUHP_ACPI_WRITE_CMD) || \
    false)

static inline void _nocheck__trace_cpuhp_acpi_write_cmd(uint32_t idx, uint8_t cmd)
{
    if (trace_event_get_state(TRACE_CPUHP_ACPI_WRITE_CMD) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:cpuhp_acpi_write_cmd " "idx[0x%"PRIx32"] cmd: 0x%"PRIx8 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , idx, cmd);
    }
}

static inline void trace_cpuhp_acpi_write_cmd(uint32_t idx, uint8_t cmd)
{
    if (true) {
        _nocheck__trace_cpuhp_acpi_write_cmd(idx, cmd);
    }
}

#define TRACE_CPUHP_ACPI_READ_CMD_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPUHP_ACPI_READ_CMD_DATA) || \
    false)

static inline void _nocheck__trace_cpuhp_acpi_read_cmd_data(uint32_t idx, uint32_t data)
{
    if (trace_event_get_state(TRACE_CPUHP_ACPI_READ_CMD_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:cpuhp_acpi_read_cmd_data " "idx[0x%"PRIx32"] data: 0x%"PRIx32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , idx, data);
    }
}

static inline void trace_cpuhp_acpi_read_cmd_data(uint32_t idx, uint32_t data)
{
    if (true) {
        _nocheck__trace_cpuhp_acpi_read_cmd_data(idx, data);
    }
}

#define TRACE_CPUHP_ACPI_READ_CMD_DATA2_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPUHP_ACPI_READ_CMD_DATA2) || \
    false)

static inline void _nocheck__trace_cpuhp_acpi_read_cmd_data2(uint32_t idx, uint32_t data)
{
    if (trace_event_get_state(TRACE_CPUHP_ACPI_READ_CMD_DATA2) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:cpuhp_acpi_read_cmd_data2 " "idx[0x%"PRIx32"] data: 0x%"PRIx32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , idx, data);
    }
}

static inline void trace_cpuhp_acpi_read_cmd_data2(uint32_t idx, uint32_t data)
{
    if (true) {
        _nocheck__trace_cpuhp_acpi_read_cmd_data2(idx, data);
    }
}

#define TRACE_CPUHP_ACPI_CPU_HAS_EVENTS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPUHP_ACPI_CPU_HAS_EVENTS) || \
    false)

static inline void _nocheck__trace_cpuhp_acpi_cpu_has_events(uint32_t idx, bool ins, bool rm)
{
    if (trace_event_get_state(TRACE_CPUHP_ACPI_CPU_HAS_EVENTS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:cpuhp_acpi_cpu_has_events " "idx[0x%"PRIx32"] inserting: %d, removing: %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , idx, ins, rm);
    }
}

static inline void trace_cpuhp_acpi_cpu_has_events(uint32_t idx, bool ins, bool rm)
{
    if (true) {
        _nocheck__trace_cpuhp_acpi_cpu_has_events(idx, ins, rm);
    }
}

#define TRACE_CPUHP_ACPI_CLEAR_INSERTING_EVT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPUHP_ACPI_CLEAR_INSERTING_EVT) || \
    false)

static inline void _nocheck__trace_cpuhp_acpi_clear_inserting_evt(uint32_t idx)
{
    if (trace_event_get_state(TRACE_CPUHP_ACPI_CLEAR_INSERTING_EVT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:cpuhp_acpi_clear_inserting_evt " "idx[0x%"PRIx32"]" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , idx);
    }
}

static inline void trace_cpuhp_acpi_clear_inserting_evt(uint32_t idx)
{
    if (true) {
        _nocheck__trace_cpuhp_acpi_clear_inserting_evt(idx);
    }
}

#define TRACE_CPUHP_ACPI_CLEAR_REMOVE_EVT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPUHP_ACPI_CLEAR_REMOVE_EVT) || \
    false)

static inline void _nocheck__trace_cpuhp_acpi_clear_remove_evt(uint32_t idx)
{
    if (trace_event_get_state(TRACE_CPUHP_ACPI_CLEAR_REMOVE_EVT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:cpuhp_acpi_clear_remove_evt " "idx[0x%"PRIx32"]" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , idx);
    }
}

static inline void trace_cpuhp_acpi_clear_remove_evt(uint32_t idx)
{
    if (true) {
        _nocheck__trace_cpuhp_acpi_clear_remove_evt(idx);
    }
}

#define TRACE_CPUHP_ACPI_EJECTING_INVALID_CPU_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPUHP_ACPI_EJECTING_INVALID_CPU) || \
    false)

static inline void _nocheck__trace_cpuhp_acpi_ejecting_invalid_cpu(uint32_t idx)
{
    if (trace_event_get_state(TRACE_CPUHP_ACPI_EJECTING_INVALID_CPU) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:cpuhp_acpi_ejecting_invalid_cpu " "0x%"PRIx32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , idx);
    }
}

static inline void trace_cpuhp_acpi_ejecting_invalid_cpu(uint32_t idx)
{
    if (true) {
        _nocheck__trace_cpuhp_acpi_ejecting_invalid_cpu(idx);
    }
}

#define TRACE_CPUHP_ACPI_EJECTING_CPU_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPUHP_ACPI_EJECTING_CPU) || \
    false)

static inline void _nocheck__trace_cpuhp_acpi_ejecting_cpu(uint32_t idx)
{
    if (trace_event_get_state(TRACE_CPUHP_ACPI_EJECTING_CPU) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:cpuhp_acpi_ejecting_cpu " "0x%"PRIx32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , idx);
    }
}

static inline void trace_cpuhp_acpi_ejecting_cpu(uint32_t idx)
{
    if (true) {
        _nocheck__trace_cpuhp_acpi_ejecting_cpu(idx);
    }
}

#define TRACE_CPUHP_ACPI_WRITE_OST_EV_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPUHP_ACPI_WRITE_OST_EV) || \
    false)

static inline void _nocheck__trace_cpuhp_acpi_write_ost_ev(uint32_t slot, uint32_t ev)
{
    if (trace_event_get_state(TRACE_CPUHP_ACPI_WRITE_OST_EV) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:cpuhp_acpi_write_ost_ev " "idx[0x%"PRIx32"] OST EVENT: 0x%"PRIx32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , slot, ev);
    }
}

static inline void trace_cpuhp_acpi_write_ost_ev(uint32_t slot, uint32_t ev)
{
    if (true) {
        _nocheck__trace_cpuhp_acpi_write_ost_ev(slot, ev);
    }
}

#define TRACE_CPUHP_ACPI_WRITE_OST_STATUS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CPUHP_ACPI_WRITE_OST_STATUS) || \
    false)

static inline void _nocheck__trace_cpuhp_acpi_write_ost_status(uint32_t slot, uint32_t st)
{
    if (trace_event_get_state(TRACE_CPUHP_ACPI_WRITE_OST_STATUS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:cpuhp_acpi_write_ost_status " "idx[0x%"PRIx32"] OST STATUS: 0x%"PRIx32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , slot, st);
    }
}

static inline void trace_cpuhp_acpi_write_ost_status(uint32_t slot, uint32_t st)
{
    if (true) {
        _nocheck__trace_cpuhp_acpi_write_ost_status(slot, st);
    }
}

#define TRACE_ACPI_PCI_EJECT_SLOT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_PCI_EJECT_SLOT) || \
    false)

static inline void _nocheck__trace_acpi_pci_eject_slot(unsigned bsel, unsigned slot)
{
    if (trace_event_get_state(TRACE_ACPI_PCI_EJECT_SLOT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:acpi_pci_eject_slot " "bsel: %u slot: %u" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bsel, slot);
    }
}

static inline void trace_acpi_pci_eject_slot(unsigned bsel, unsigned slot)
{
    if (true) {
        _nocheck__trace_acpi_pci_eject_slot(bsel, slot);
    }
}

#define TRACE_ACPI_PCI_UNPLUG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_PCI_UNPLUG) || \
    false)

static inline void _nocheck__trace_acpi_pci_unplug(int bsel, int slot)
{
    if (trace_event_get_state(TRACE_ACPI_PCI_UNPLUG) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:acpi_pci_unplug " "bsel: %d slot: %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bsel, slot);
    }
}

static inline void trace_acpi_pci_unplug(int bsel, int slot)
{
    if (true) {
        _nocheck__trace_acpi_pci_unplug(bsel, slot);
    }
}

#define TRACE_ACPI_PCI_UNPLUG_REQUEST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_PCI_UNPLUG_REQUEST) || \
    false)

static inline void _nocheck__trace_acpi_pci_unplug_request(int bsel, int slot)
{
    if (trace_event_get_state(TRACE_ACPI_PCI_UNPLUG_REQUEST) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:acpi_pci_unplug_request " "bsel: %d slot: %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bsel, slot);
    }
}

static inline void trace_acpi_pci_unplug_request(int bsel, int slot)
{
    if (true) {
        _nocheck__trace_acpi_pci_unplug_request(bsel, slot);
    }
}

#define TRACE_ACPI_PCI_UP_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_PCI_UP_READ) || \
    false)

static inline void _nocheck__trace_acpi_pci_up_read(uint32_t val)
{
    if (trace_event_get_state(TRACE_ACPI_PCI_UP_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:acpi_pci_up_read " "%" PRIu32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , val);
    }
}

static inline void trace_acpi_pci_up_read(uint32_t val)
{
    if (true) {
        _nocheck__trace_acpi_pci_up_read(val);
    }
}

#define TRACE_ACPI_PCI_DOWN_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_PCI_DOWN_READ) || \
    false)

static inline void _nocheck__trace_acpi_pci_down_read(uint32_t val)
{
    if (trace_event_get_state(TRACE_ACPI_PCI_DOWN_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:acpi_pci_down_read " "%" PRIu32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , val);
    }
}

static inline void trace_acpi_pci_down_read(uint32_t val)
{
    if (true) {
        _nocheck__trace_acpi_pci_down_read(val);
    }
}

#define TRACE_ACPI_PCI_FEATURES_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_PCI_FEATURES_READ) || \
    false)

static inline void _nocheck__trace_acpi_pci_features_read(uint32_t val)
{
    if (trace_event_get_state(TRACE_ACPI_PCI_FEATURES_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:acpi_pci_features_read " "%" PRIu32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , val);
    }
}

static inline void trace_acpi_pci_features_read(uint32_t val)
{
    if (true) {
        _nocheck__trace_acpi_pci_features_read(val);
    }
}

#define TRACE_ACPI_PCI_RMV_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_PCI_RMV_READ) || \
    false)

static inline void _nocheck__trace_acpi_pci_rmv_read(uint32_t val)
{
    if (trace_event_get_state(TRACE_ACPI_PCI_RMV_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:acpi_pci_rmv_read " "%" PRIu32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , val);
    }
}

static inline void trace_acpi_pci_rmv_read(uint32_t val)
{
    if (true) {
        _nocheck__trace_acpi_pci_rmv_read(val);
    }
}

#define TRACE_ACPI_PCI_SEL_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_PCI_SEL_READ) || \
    false)

static inline void _nocheck__trace_acpi_pci_sel_read(uint32_t val)
{
    if (trace_event_get_state(TRACE_ACPI_PCI_SEL_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:acpi_pci_sel_read " "%" PRIu32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , val);
    }
}

static inline void trace_acpi_pci_sel_read(uint32_t val)
{
    if (true) {
        _nocheck__trace_acpi_pci_sel_read(val);
    }
}

#define TRACE_ACPI_PCI_EJ_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_PCI_EJ_WRITE) || \
    false)

static inline void _nocheck__trace_acpi_pci_ej_write(uint64_t addr, uint64_t data)
{
    if (trace_event_get_state(TRACE_ACPI_PCI_EJ_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:acpi_pci_ej_write " "0x%" PRIx64 " <== %" PRIu64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, data);
    }
}

static inline void trace_acpi_pci_ej_write(uint64_t addr, uint64_t data)
{
    if (true) {
        _nocheck__trace_acpi_pci_ej_write(addr, data);
    }
}

#define TRACE_ACPI_PCI_SEL_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ACPI_PCI_SEL_WRITE) || \
    false)

static inline void _nocheck__trace_acpi_pci_sel_write(uint64_t addr, uint64_t data)
{
    if (trace_event_get_state(TRACE_ACPI_PCI_SEL_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:acpi_pci_sel_write " "0x%" PRIx64 " <== %" PRIu64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, data);
    }
}

static inline void trace_acpi_pci_sel_write(uint64_t addr, uint64_t data)
{
    if (true) {
        _nocheck__trace_acpi_pci_sel_write(addr, data);
    }
}

#define TRACE_PIIX4_GPE_READB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PIIX4_GPE_READB) || \
    false)

static inline void _nocheck__trace_piix4_gpe_readb(uint64_t addr, unsigned width, uint64_t val)
{
    if (trace_event_get_state(TRACE_PIIX4_GPE_READB) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:piix4_gpe_readb " "addr: 0x%" PRIx64 " width: %d ==> 0x%" PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, width, val);
    }
}

static inline void trace_piix4_gpe_readb(uint64_t addr, unsigned width, uint64_t val)
{
    if (true) {
        _nocheck__trace_piix4_gpe_readb(addr, width, val);
    }
}

#define TRACE_PIIX4_GPE_WRITEB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PIIX4_GPE_WRITEB) || \
    false)

static inline void _nocheck__trace_piix4_gpe_writeb(uint64_t addr, unsigned width, uint64_t val)
{
    if (trace_event_get_state(TRACE_PIIX4_GPE_WRITEB) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:piix4_gpe_writeb " "addr: 0x%" PRIx64 " width: %d <== 0x%" PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, width, val);
    }
}

static inline void trace_piix4_gpe_writeb(uint64_t addr, unsigned width, uint64_t val)
{
    if (true) {
        _nocheck__trace_piix4_gpe_writeb(addr, width, val);
    }
}

#define TRACE_TCO_TIMER_RELOAD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_TCO_TIMER_RELOAD) || \
    false)

static inline void _nocheck__trace_tco_timer_reload(int ticks, int msec)
{
    if (trace_event_get_state(TRACE_TCO_TIMER_RELOAD) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:tco_timer_reload " "ticks=%d (%d ms)" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , ticks, msec);
    }
}

static inline void trace_tco_timer_reload(int ticks, int msec)
{
    if (true) {
        _nocheck__trace_tco_timer_reload(ticks, msec);
    }
}

#define TRACE_TCO_TIMER_EXPIRED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_TCO_TIMER_EXPIRED) || \
    false)

static inline void _nocheck__trace_tco_timer_expired(int timeouts_no, bool strap, bool no_reboot)
{
    if (trace_event_get_state(TRACE_TCO_TIMER_EXPIRED) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:tco_timer_expired " "timeouts_no=%d no_reboot=%d/%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , timeouts_no, strap, no_reboot);
    }
}

static inline void trace_tco_timer_expired(int timeouts_no, bool strap, bool no_reboot)
{
    if (true) {
        _nocheck__trace_tco_timer_expired(timeouts_no, strap, no_reboot);
    }
}
#endif /* TRACE_HW_ACPI_GENERATED_TRACERS_H */
