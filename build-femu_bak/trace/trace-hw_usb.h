/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_USB_GENERATED_TRACERS_H
#define TRACE_HW_USB_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_USB_PACKET_STATE_CHANGE_EVENT;
extern TraceEvent _TRACE_USB_PACKET_STATE_FAULT_EVENT;
extern TraceEvent _TRACE_USB_PORT_CLAIM_EVENT;
extern TraceEvent _TRACE_USB_PORT_ATTACH_EVENT;
extern TraceEvent _TRACE_USB_PORT_DETACH_EVENT;
extern TraceEvent _TRACE_USB_PORT_RELEASE_EVENT;
extern TraceEvent _TRACE_USB_OHCI_EXIT_EVENT;
extern TraceEvent _TRACE_USB_OHCI_ISO_TD_READ_FAILED_EVENT;
extern TraceEvent _TRACE_USB_OHCI_ISO_TD_HEAD_EVENT;
extern TraceEvent _TRACE_USB_OHCI_ISO_TD_HEAD_OFFSET_EVENT;
extern TraceEvent _TRACE_USB_OHCI_ISO_TD_RELATIVE_FRAME_NUMBER_NEG_EVENT;
extern TraceEvent _TRACE_USB_OHCI_ISO_TD_RELATIVE_FRAME_NUMBER_BIG_EVENT;
extern TraceEvent _TRACE_USB_OHCI_ISO_TD_BAD_DIRECTION_EVENT;
extern TraceEvent _TRACE_USB_OHCI_ISO_TD_BAD_BP_BE_EVENT;
extern TraceEvent _TRACE_USB_OHCI_ISO_TD_BAD_CC_NOT_ACCESSED_EVENT;
extern TraceEvent _TRACE_USB_OHCI_ISO_TD_BAD_CC_OVERRUN_EVENT;
extern TraceEvent _TRACE_USB_OHCI_ISO_TD_SO_EVENT;
extern TraceEvent _TRACE_USB_OHCI_ISO_TD_DATA_OVERRUN_EVENT;
extern TraceEvent _TRACE_USB_OHCI_ISO_TD_DATA_UNDERRUN_EVENT;
extern TraceEvent _TRACE_USB_OHCI_ISO_TD_NAK_EVENT;
extern TraceEvent _TRACE_USB_OHCI_ISO_TD_BAD_RESPONSE_EVENT;
extern TraceEvent _TRACE_USB_OHCI_PORT_ATTACH_EVENT;
extern TraceEvent _TRACE_USB_OHCI_PORT_DETACH_EVENT;
extern TraceEvent _TRACE_USB_OHCI_PORT_WAKEUP_EVENT;
extern TraceEvent _TRACE_USB_OHCI_PORT_SUSPEND_EVENT;
extern TraceEvent _TRACE_USB_OHCI_PORT_RESET_EVENT;
extern TraceEvent _TRACE_USB_OHCI_REMOTE_WAKEUP_EVENT;
extern TraceEvent _TRACE_USB_OHCI_RESET_EVENT;
extern TraceEvent _TRACE_USB_OHCI_START_EVENT;
extern TraceEvent _TRACE_USB_OHCI_RESUME_EVENT;
extern TraceEvent _TRACE_USB_OHCI_STOP_EVENT;
extern TraceEvent _TRACE_USB_OHCI_SET_CTL_EVENT;
extern TraceEvent _TRACE_USB_OHCI_TD_UNDERRUN_EVENT;
extern TraceEvent _TRACE_USB_OHCI_TD_DEV_ERROR_EVENT;
extern TraceEvent _TRACE_USB_OHCI_TD_NAK_EVENT;
extern TraceEvent _TRACE_USB_OHCI_TD_STALL_EVENT;
extern TraceEvent _TRACE_USB_OHCI_TD_BABBLE_EVENT;
extern TraceEvent _TRACE_USB_OHCI_TD_BAD_DEVICE_RESPONSE_EVENT;
extern TraceEvent _TRACE_USB_OHCI_TD_READ_ERROR_EVENT;
extern TraceEvent _TRACE_USB_OHCI_TD_BAD_DIRECTION_EVENT;
extern TraceEvent _TRACE_USB_OHCI_TD_SKIP_ASYNC_EVENT;
extern TraceEvent _TRACE_USB_OHCI_TD_PKT_HDR_EVENT;
extern TraceEvent _TRACE_USB_OHCI_TD_PKT_SHORT_EVENT;
extern TraceEvent _TRACE_USB_OHCI_TD_PKT_FULL_EVENT;
extern TraceEvent _TRACE_USB_OHCI_TD_TOO_MANY_PENDING_EVENT;
extern TraceEvent _TRACE_USB_OHCI_TD_PACKET_STATUS_EVENT;
extern TraceEvent _TRACE_USB_OHCI_ED_READ_ERROR_EVENT;
extern TraceEvent _TRACE_USB_OHCI_ED_PKT_EVENT;
extern TraceEvent _TRACE_USB_OHCI_ED_PKT_FLAGS_EVENT;
extern TraceEvent _TRACE_USB_OHCI_HCCA_READ_ERROR_EVENT;
extern TraceEvent _TRACE_USB_OHCI_MEM_READ_UNALIGNED_EVENT;
extern TraceEvent _TRACE_USB_OHCI_MEM_READ_BAD_OFFSET_EVENT;
extern TraceEvent _TRACE_USB_OHCI_MEM_WRITE_UNALIGNED_EVENT;
extern TraceEvent _TRACE_USB_OHCI_MEM_WRITE_BAD_OFFSET_EVENT;
extern TraceEvent _TRACE_USB_OHCI_PROCESS_LISTS_EVENT;
extern TraceEvent _TRACE_USB_OHCI_SET_FRAME_INTERVAL_EVENT;
extern TraceEvent _TRACE_USB_OHCI_HUB_POWER_UP_EVENT;
extern TraceEvent _TRACE_USB_OHCI_HUB_POWER_DOWN_EVENT;
extern TraceEvent _TRACE_USB_OHCI_INIT_TIME_EVENT;
extern TraceEvent _TRACE_USB_OHCI_DIE_EVENT;
extern TraceEvent _TRACE_USB_OHCI_ASYNC_COMPLETE_EVENT;
extern TraceEvent _TRACE_USB_EHCI_RESET_EVENT;
extern TraceEvent _TRACE_USB_EHCI_UNREALIZE_EVENT;
extern TraceEvent _TRACE_USB_EHCI_OPREG_READ_EVENT;
extern TraceEvent _TRACE_USB_EHCI_OPREG_WRITE_EVENT;
extern TraceEvent _TRACE_USB_EHCI_OPREG_CHANGE_EVENT;
extern TraceEvent _TRACE_USB_EHCI_PORTSC_READ_EVENT;
extern TraceEvent _TRACE_USB_EHCI_PORTSC_WRITE_EVENT;
extern TraceEvent _TRACE_USB_EHCI_PORTSC_CHANGE_EVENT;
extern TraceEvent _TRACE_USB_EHCI_USBSTS_EVENT;
extern TraceEvent _TRACE_USB_EHCI_STATE_EVENT;
extern TraceEvent _TRACE_USB_EHCI_QH_PTRS_EVENT;
extern TraceEvent _TRACE_USB_EHCI_QH_FIELDS_EVENT;
extern TraceEvent _TRACE_USB_EHCI_QH_BITS_EVENT;
extern TraceEvent _TRACE_USB_EHCI_QTD_PTRS_EVENT;
extern TraceEvent _TRACE_USB_EHCI_QTD_FIELDS_EVENT;
extern TraceEvent _TRACE_USB_EHCI_QTD_BITS_EVENT;
extern TraceEvent _TRACE_USB_EHCI_ITD_EVENT;
extern TraceEvent _TRACE_USB_EHCI_SITD_EVENT;
extern TraceEvent _TRACE_USB_EHCI_PORT_ATTACH_EVENT;
extern TraceEvent _TRACE_USB_EHCI_PORT_DETACH_EVENT;
extern TraceEvent _TRACE_USB_EHCI_PORT_RESET_EVENT;
extern TraceEvent _TRACE_USB_EHCI_PORT_SUSPEND_EVENT;
extern TraceEvent _TRACE_USB_EHCI_PORT_WAKEUP_EVENT;
extern TraceEvent _TRACE_USB_EHCI_PORT_RESUME_EVENT;
extern TraceEvent _TRACE_USB_EHCI_QUEUE_ACTION_EVENT;
extern TraceEvent _TRACE_USB_EHCI_PACKET_ACTION_EVENT;
extern TraceEvent _TRACE_USB_EHCI_IRQ_EVENT;
extern TraceEvent _TRACE_USB_EHCI_GUEST_BUG_EVENT;
extern TraceEvent _TRACE_USB_EHCI_DOORBELL_RING_EVENT;
extern TraceEvent _TRACE_USB_EHCI_DOORBELL_ACK_EVENT;
extern TraceEvent _TRACE_USB_EHCI_DMA_ERROR_EVENT;
extern TraceEvent _TRACE_USB_UHCI_RESET_EVENT;
extern TraceEvent _TRACE_USB_UHCI_EXIT_EVENT;
extern TraceEvent _TRACE_USB_UHCI_SCHEDULE_START_EVENT;
extern TraceEvent _TRACE_USB_UHCI_SCHEDULE_STOP_EVENT;
extern TraceEvent _TRACE_USB_UHCI_FRAME_START_EVENT;
extern TraceEvent _TRACE_USB_UHCI_FRAME_STOP_BANDWIDTH_EVENT;
extern TraceEvent _TRACE_USB_UHCI_FRAME_LOOP_STOP_IDLE_EVENT;
extern TraceEvent _TRACE_USB_UHCI_FRAME_LOOP_CONTINUE_EVENT;
extern TraceEvent _TRACE_USB_UHCI_MMIO_READW_EVENT;
extern TraceEvent _TRACE_USB_UHCI_MMIO_WRITEW_EVENT;
extern TraceEvent _TRACE_USB_UHCI_QUEUE_ADD_EVENT;
extern TraceEvent _TRACE_USB_UHCI_QUEUE_DEL_EVENT;
extern TraceEvent _TRACE_USB_UHCI_PACKET_ADD_EVENT;
extern TraceEvent _TRACE_USB_UHCI_PACKET_LINK_ASYNC_EVENT;
extern TraceEvent _TRACE_USB_UHCI_PACKET_UNLINK_ASYNC_EVENT;
extern TraceEvent _TRACE_USB_UHCI_PACKET_CANCEL_EVENT;
extern TraceEvent _TRACE_USB_UHCI_PACKET_COMPLETE_SUCCESS_EVENT;
extern TraceEvent _TRACE_USB_UHCI_PACKET_COMPLETE_SHORTXFER_EVENT;
extern TraceEvent _TRACE_USB_UHCI_PACKET_COMPLETE_STALL_EVENT;
extern TraceEvent _TRACE_USB_UHCI_PACKET_COMPLETE_BABBLE_EVENT;
extern TraceEvent _TRACE_USB_UHCI_PACKET_COMPLETE_ERROR_EVENT;
extern TraceEvent _TRACE_USB_UHCI_PACKET_DEL_EVENT;
extern TraceEvent _TRACE_USB_UHCI_QH_LOAD_EVENT;
extern TraceEvent _TRACE_USB_UHCI_TD_LOAD_EVENT;
extern TraceEvent _TRACE_USB_UHCI_TD_QUEUE_EVENT;
extern TraceEvent _TRACE_USB_UHCI_TD_NEXTQH_EVENT;
extern TraceEvent _TRACE_USB_UHCI_TD_ASYNC_EVENT;
extern TraceEvent _TRACE_USB_UHCI_TD_COMPLETE_EVENT;
extern TraceEvent _TRACE_USB_XHCI_RESET_EVENT;
extern TraceEvent _TRACE_USB_XHCI_EXIT_EVENT;
extern TraceEvent _TRACE_USB_XHCI_RUN_EVENT;
extern TraceEvent _TRACE_USB_XHCI_STOP_EVENT;
extern TraceEvent _TRACE_USB_XHCI_CAP_READ_EVENT;
extern TraceEvent _TRACE_USB_XHCI_OPER_READ_EVENT;
extern TraceEvent _TRACE_USB_XHCI_PORT_READ_EVENT;
extern TraceEvent _TRACE_USB_XHCI_RUNTIME_READ_EVENT;
extern TraceEvent _TRACE_USB_XHCI_DOORBELL_READ_EVENT;
extern TraceEvent _TRACE_USB_XHCI_OPER_WRITE_EVENT;
extern TraceEvent _TRACE_USB_XHCI_PORT_WRITE_EVENT;
extern TraceEvent _TRACE_USB_XHCI_RUNTIME_WRITE_EVENT;
extern TraceEvent _TRACE_USB_XHCI_DOORBELL_WRITE_EVENT;
extern TraceEvent _TRACE_USB_XHCI_IRQ_INTX_EVENT;
extern TraceEvent _TRACE_USB_XHCI_IRQ_MSI_EVENT;
extern TraceEvent _TRACE_USB_XHCI_IRQ_MSIX_EVENT;
extern TraceEvent _TRACE_USB_XHCI_IRQ_MSIX_USE_EVENT;
extern TraceEvent _TRACE_USB_XHCI_IRQ_MSIX_UNUSE_EVENT;
extern TraceEvent _TRACE_USB_XHCI_QUEUE_EVENT_EVENT;
extern TraceEvent _TRACE_USB_XHCI_FETCH_TRB_EVENT;
extern TraceEvent _TRACE_USB_XHCI_PORT_RESET_EVENT;
extern TraceEvent _TRACE_USB_XHCI_PORT_LINK_EVENT;
extern TraceEvent _TRACE_USB_XHCI_PORT_NOTIFY_EVENT;
extern TraceEvent _TRACE_USB_XHCI_SLOT_ENABLE_EVENT;
extern TraceEvent _TRACE_USB_XHCI_SLOT_DISABLE_EVENT;
extern TraceEvent _TRACE_USB_XHCI_SLOT_ADDRESS_EVENT;
extern TraceEvent _TRACE_USB_XHCI_SLOT_CONFIGURE_EVENT;
extern TraceEvent _TRACE_USB_XHCI_SLOT_EVALUATE_EVENT;
extern TraceEvent _TRACE_USB_XHCI_SLOT_RESET_EVENT;
extern TraceEvent _TRACE_USB_XHCI_EP_ENABLE_EVENT;
extern TraceEvent _TRACE_USB_XHCI_EP_DISABLE_EVENT;
extern TraceEvent _TRACE_USB_XHCI_EP_SET_DEQUEUE_EVENT;
extern TraceEvent _TRACE_USB_XHCI_EP_KICK_EVENT;
extern TraceEvent _TRACE_USB_XHCI_EP_STOP_EVENT;
extern TraceEvent _TRACE_USB_XHCI_EP_RESET_EVENT;
extern TraceEvent _TRACE_USB_XHCI_EP_STATE_EVENT;
extern TraceEvent _TRACE_USB_XHCI_XFER_START_EVENT;
extern TraceEvent _TRACE_USB_XHCI_XFER_ASYNC_EVENT;
extern TraceEvent _TRACE_USB_XHCI_XFER_NAK_EVENT;
extern TraceEvent _TRACE_USB_XHCI_XFER_RETRY_EVENT;
extern TraceEvent _TRACE_USB_XHCI_XFER_SUCCESS_EVENT;
extern TraceEvent _TRACE_USB_XHCI_XFER_ERROR_EVENT;
extern TraceEvent _TRACE_USB_XHCI_UNIMPLEMENTED_EVENT;
extern TraceEvent _TRACE_USB_XHCI_ENFORCED_LIMIT_EVENT;
extern TraceEvent _TRACE_USB_DWC2_UPDATE_IRQ_EVENT;
extern TraceEvent _TRACE_USB_DWC2_RAISE_GLOBAL_IRQ_EVENT;
extern TraceEvent _TRACE_USB_DWC2_LOWER_GLOBAL_IRQ_EVENT;
extern TraceEvent _TRACE_USB_DWC2_RAISE_HOST_IRQ_EVENT;
extern TraceEvent _TRACE_USB_DWC2_LOWER_HOST_IRQ_EVENT;
extern TraceEvent _TRACE_USB_DWC2_SOF_EVENT;
extern TraceEvent _TRACE_USB_DWC2_BUS_START_EVENT;
extern TraceEvent _TRACE_USB_DWC2_BUS_STOP_EVENT;
extern TraceEvent _TRACE_USB_DWC2_FIND_DEVICE_EVENT;
extern TraceEvent _TRACE_USB_DWC2_PORT_DISABLED_EVENT;
extern TraceEvent _TRACE_USB_DWC2_DEVICE_FOUND_EVENT;
extern TraceEvent _TRACE_USB_DWC2_DEVICE_NOT_FOUND_EVENT;
extern TraceEvent _TRACE_USB_DWC2_HANDLE_PACKET_EVENT;
extern TraceEvent _TRACE_USB_DWC2_MEMORY_READ_EVENT;
extern TraceEvent _TRACE_USB_DWC2_PACKET_STATUS_EVENT;
extern TraceEvent _TRACE_USB_DWC2_PACKET_ERROR_EVENT;
extern TraceEvent _TRACE_USB_DWC2_ASYNC_PACKET_EVENT;
extern TraceEvent _TRACE_USB_DWC2_MEMORY_WRITE_EVENT;
extern TraceEvent _TRACE_USB_DWC2_PACKET_DONE_EVENT;
extern TraceEvent _TRACE_USB_DWC2_PACKET_NEXT_EVENT;
extern TraceEvent _TRACE_USB_DWC2_ATTACH_EVENT;
extern TraceEvent _TRACE_USB_DWC2_ATTACH_SPEED_EVENT;
extern TraceEvent _TRACE_USB_DWC2_DETACH_EVENT;
extern TraceEvent _TRACE_USB_DWC2_CHILD_DETACH_EVENT;
extern TraceEvent _TRACE_USB_DWC2_WAKEUP_EVENT;
extern TraceEvent _TRACE_USB_DWC2_ASYNC_PACKET_COMPLETE_EVENT;
extern TraceEvent _TRACE_USB_DWC2_WORK_BH_EVENT;
extern TraceEvent _TRACE_USB_DWC2_WORK_BH_SERVICE_EVENT;
extern TraceEvent _TRACE_USB_DWC2_WORK_BH_NEXT_EVENT;
extern TraceEvent _TRACE_USB_DWC2_ENABLE_CHAN_EVENT;
extern TraceEvent _TRACE_USB_DWC2_GLBREG_READ_EVENT;
extern TraceEvent _TRACE_USB_DWC2_GLBREG_WRITE_EVENT;
extern TraceEvent _TRACE_USB_DWC2_FSZREG_READ_EVENT;
extern TraceEvent _TRACE_USB_DWC2_FSZREG_WRITE_EVENT;
extern TraceEvent _TRACE_USB_DWC2_HREG0_READ_EVENT;
extern TraceEvent _TRACE_USB_DWC2_HREG0_WRITE_EVENT;
extern TraceEvent _TRACE_USB_DWC2_HREG1_READ_EVENT;
extern TraceEvent _TRACE_USB_DWC2_HREG1_WRITE_EVENT;
extern TraceEvent _TRACE_USB_DWC2_PCGREG_READ_EVENT;
extern TraceEvent _TRACE_USB_DWC2_PCGREG_WRITE_EVENT;
extern TraceEvent _TRACE_USB_DWC2_HREG2_READ_EVENT;
extern TraceEvent _TRACE_USB_DWC2_HREG2_WRITE_EVENT;
extern TraceEvent _TRACE_USB_DWC2_HREG0_ACTION_EVENT;
extern TraceEvent _TRACE_USB_DWC2_WAKEUP_ENDPOINT_EVENT;
extern TraceEvent _TRACE_USB_DWC2_WORK_TIMER_EVENT;
extern TraceEvent _TRACE_USB_DWC2_RESET_ENTER_EVENT;
extern TraceEvent _TRACE_USB_DWC2_RESET_HOLD_EVENT;
extern TraceEvent _TRACE_USB_DWC2_RESET_EXIT_EVENT;
extern TraceEvent _TRACE_USB_DESC_DEVICE_EVENT;
extern TraceEvent _TRACE_USB_DESC_DEVICE_QUALIFIER_EVENT;
extern TraceEvent _TRACE_USB_DESC_CONFIG_EVENT;
extern TraceEvent _TRACE_USB_DESC_OTHER_SPEED_CONFIG_EVENT;
extern TraceEvent _TRACE_USB_DESC_STRING_EVENT;
extern TraceEvent _TRACE_USB_DESC_BOS_EVENT;
extern TraceEvent _TRACE_USB_DESC_MSOS_EVENT;
extern TraceEvent _TRACE_USB_SET_ADDR_EVENT;
extern TraceEvent _TRACE_USB_SET_CONFIG_EVENT;
extern TraceEvent _TRACE_USB_SET_INTERFACE_EVENT;
extern TraceEvent _TRACE_USB_CLEAR_DEVICE_FEATURE_EVENT;
extern TraceEvent _TRACE_USB_SET_DEVICE_FEATURE_EVENT;
extern TraceEvent _TRACE_USB_HUB_RESET_EVENT;
extern TraceEvent _TRACE_USB_HUB_CONTROL_EVENT;
extern TraceEvent _TRACE_USB_HUB_GET_PORT_STATUS_EVENT;
extern TraceEvent _TRACE_USB_HUB_SET_PORT_FEATURE_EVENT;
extern TraceEvent _TRACE_USB_HUB_CLEAR_PORT_FEATURE_EVENT;
extern TraceEvent _TRACE_USB_HUB_ATTACH_EVENT;
extern TraceEvent _TRACE_USB_HUB_DETACH_EVENT;
extern TraceEvent _TRACE_USB_HUB_STATUS_REPORT_EVENT;
extern TraceEvent _TRACE_USB_MSD_RESET_EVENT;
extern TraceEvent _TRACE_USB_MSD_MAXLUN_EVENT;
extern TraceEvent _TRACE_USB_MSD_SEND_STATUS_EVENT;
extern TraceEvent _TRACE_USB_MSD_DATA_IN_EVENT;
extern TraceEvent _TRACE_USB_MSD_DATA_OUT_EVENT;
extern TraceEvent _TRACE_USB_MSD_PACKET_ASYNC_EVENT;
extern TraceEvent _TRACE_USB_MSD_PACKET_COMPLETE_EVENT;
extern TraceEvent _TRACE_USB_MSD_CMD_SUBMIT_EVENT;
extern TraceEvent _TRACE_USB_MSD_CMD_COMPLETE_EVENT;
extern TraceEvent _TRACE_USB_MSD_CMD_CANCEL_EVENT;
extern TraceEvent _TRACE_USB_UAS_RESET_EVENT;
extern TraceEvent _TRACE_USB_UAS_COMMAND_EVENT;
extern TraceEvent _TRACE_USB_UAS_RESPONSE_EVENT;
extern TraceEvent _TRACE_USB_UAS_SENSE_EVENT;
extern TraceEvent _TRACE_USB_UAS_READ_READY_EVENT;
extern TraceEvent _TRACE_USB_UAS_WRITE_READY_EVENT;
extern TraceEvent _TRACE_USB_UAS_XFER_DATA_EVENT;
extern TraceEvent _TRACE_USB_UAS_SCSI_DATA_EVENT;
extern TraceEvent _TRACE_USB_UAS_SCSI_COMPLETE_EVENT;
extern TraceEvent _TRACE_USB_UAS_TMF_ABORT_TASK_EVENT;
extern TraceEvent _TRACE_USB_UAS_TMF_LOGICAL_UNIT_RESET_EVENT;
extern TraceEvent _TRACE_USB_UAS_TMF_UNSUPPORTED_EVENT;
extern TraceEvent _TRACE_USB_MTP_RESET_EVENT;
extern TraceEvent _TRACE_USB_MTP_COMMAND_EVENT;
extern TraceEvent _TRACE_USB_MTP_SUCCESS_EVENT;
extern TraceEvent _TRACE_USB_MTP_ERROR_EVENT;
extern TraceEvent _TRACE_USB_MTP_DATA_IN_EVENT;
extern TraceEvent _TRACE_USB_MTP_XFER_EVENT;
extern TraceEvent _TRACE_USB_MTP_NAK_EVENT;
extern TraceEvent _TRACE_USB_MTP_STALL_EVENT;
extern TraceEvent _TRACE_USB_MTP_OP_GET_DEVICE_INFO_EVENT;
extern TraceEvent _TRACE_USB_MTP_OP_OPEN_SESSION_EVENT;
extern TraceEvent _TRACE_USB_MTP_OP_CLOSE_SESSION_EVENT;
extern TraceEvent _TRACE_USB_MTP_OP_GET_STORAGE_IDS_EVENT;
extern TraceEvent _TRACE_USB_MTP_OP_GET_STORAGE_INFO_EVENT;
extern TraceEvent _TRACE_USB_MTP_OP_GET_NUM_OBJECTS_EVENT;
extern TraceEvent _TRACE_USB_MTP_OP_GET_OBJECT_HANDLES_EVENT;
extern TraceEvent _TRACE_USB_MTP_OP_GET_OBJECT_INFO_EVENT;
extern TraceEvent _TRACE_USB_MTP_OP_GET_OBJECT_EVENT;
extern TraceEvent _TRACE_USB_MTP_OP_GET_PARTIAL_OBJECT_EVENT;
extern TraceEvent _TRACE_USB_MTP_OP_UNKNOWN_EVENT;
extern TraceEvent _TRACE_USB_MTP_OBJECT_ALLOC_EVENT;
extern TraceEvent _TRACE_USB_MTP_OBJECT_FREE_EVENT;
extern TraceEvent _TRACE_USB_MTP_ADD_CHILD_EVENT;
extern TraceEvent _TRACE_USB_MTP_FILE_MONITOR_EVENT_EVENT;
extern TraceEvent _TRACE_USB_HOST_OPEN_STARTED_EVENT;
extern TraceEvent _TRACE_USB_HOST_OPEN_HOSTFD_EVENT;
extern TraceEvent _TRACE_USB_HOST_OPEN_SUCCESS_EVENT;
extern TraceEvent _TRACE_USB_HOST_OPEN_FAILURE_EVENT;
extern TraceEvent _TRACE_USB_HOST_CLOSE_EVENT;
extern TraceEvent _TRACE_USB_HOST_ATTACH_KERNEL_EVENT;
extern TraceEvent _TRACE_USB_HOST_DETACH_KERNEL_EVENT;
extern TraceEvent _TRACE_USB_HOST_SET_ADDRESS_EVENT;
extern TraceEvent _TRACE_USB_HOST_SET_CONFIG_EVENT;
extern TraceEvent _TRACE_USB_HOST_SET_INTERFACE_EVENT;
extern TraceEvent _TRACE_USB_HOST_CLAIM_INTERFACE_EVENT;
extern TraceEvent _TRACE_USB_HOST_RELEASE_INTERFACE_EVENT;
extern TraceEvent _TRACE_USB_HOST_REQ_CONTROL_EVENT;
extern TraceEvent _TRACE_USB_HOST_REQ_DATA_EVENT;
extern TraceEvent _TRACE_USB_HOST_REQ_COMPLETE_EVENT;
extern TraceEvent _TRACE_USB_HOST_REQ_EMULATED_EVENT;
extern TraceEvent _TRACE_USB_HOST_REQ_CANCELED_EVENT;
extern TraceEvent _TRACE_USB_HOST_ISO_START_EVENT;
extern TraceEvent _TRACE_USB_HOST_ISO_STOP_EVENT;
extern TraceEvent _TRACE_USB_HOST_ISO_OUT_OF_BUFS_EVENT;
extern TraceEvent _TRACE_USB_HOST_RESET_EVENT;
extern TraceEvent _TRACE_USB_HOST_AUTO_SCAN_ENABLED_EVENT;
extern TraceEvent _TRACE_USB_HOST_AUTO_SCAN_DISABLED_EVENT;
extern TraceEvent _TRACE_USB_HOST_PARSE_CONFIG_EVENT;
extern TraceEvent _TRACE_USB_HOST_PARSE_INTERFACE_EVENT;
extern TraceEvent _TRACE_USB_HOST_PARSE_ENDPOINT_EVENT;
extern TraceEvent _TRACE_USB_HOST_PARSE_ERROR_EVENT;
extern TraceEvent _TRACE_USB_HOST_REMOTE_WAKEUP_REMOVED_EVENT;
extern TraceEvent _TRACE_USB_SERIAL_RESET_EVENT;
extern TraceEvent _TRACE_USB_SERIAL_HANDLE_CONTROL_EVENT;
extern TraceEvent _TRACE_USB_SERIAL_UNSUPPORTED_PARITY_EVENT;
extern TraceEvent _TRACE_USB_SERIAL_UNSUPPORTED_STOPBITS_EVENT;
extern TraceEvent _TRACE_USB_SERIAL_UNSUPPORTED_CONTROL_EVENT;
extern TraceEvent _TRACE_USB_SERIAL_UNSUPPORTED_DATA_BITS_EVENT;
extern TraceEvent _TRACE_USB_SERIAL_BAD_TOKEN_EVENT;
extern TraceEvent _TRACE_USB_SERIAL_SET_BAUD_EVENT;
extern TraceEvent _TRACE_USB_SERIAL_SET_DATA_EVENT;
extern TraceEvent _TRACE_USB_SERIAL_SET_FLOW_CONTROL_EVENT;
extern TraceEvent _TRACE_USB_SERIAL_SET_XONXOFF_EVENT;
extern uint16_t _TRACE_USB_PACKET_STATE_CHANGE_DSTATE;
extern uint16_t _TRACE_USB_PACKET_STATE_FAULT_DSTATE;
extern uint16_t _TRACE_USB_PORT_CLAIM_DSTATE;
extern uint16_t _TRACE_USB_PORT_ATTACH_DSTATE;
extern uint16_t _TRACE_USB_PORT_DETACH_DSTATE;
extern uint16_t _TRACE_USB_PORT_RELEASE_DSTATE;
extern uint16_t _TRACE_USB_OHCI_EXIT_DSTATE;
extern uint16_t _TRACE_USB_OHCI_ISO_TD_READ_FAILED_DSTATE;
extern uint16_t _TRACE_USB_OHCI_ISO_TD_HEAD_DSTATE;
extern uint16_t _TRACE_USB_OHCI_ISO_TD_HEAD_OFFSET_DSTATE;
extern uint16_t _TRACE_USB_OHCI_ISO_TD_RELATIVE_FRAME_NUMBER_NEG_DSTATE;
extern uint16_t _TRACE_USB_OHCI_ISO_TD_RELATIVE_FRAME_NUMBER_BIG_DSTATE;
extern uint16_t _TRACE_USB_OHCI_ISO_TD_BAD_DIRECTION_DSTATE;
extern uint16_t _TRACE_USB_OHCI_ISO_TD_BAD_BP_BE_DSTATE;
extern uint16_t _TRACE_USB_OHCI_ISO_TD_BAD_CC_NOT_ACCESSED_DSTATE;
extern uint16_t _TRACE_USB_OHCI_ISO_TD_BAD_CC_OVERRUN_DSTATE;
extern uint16_t _TRACE_USB_OHCI_ISO_TD_SO_DSTATE;
extern uint16_t _TRACE_USB_OHCI_ISO_TD_DATA_OVERRUN_DSTATE;
extern uint16_t _TRACE_USB_OHCI_ISO_TD_DATA_UNDERRUN_DSTATE;
extern uint16_t _TRACE_USB_OHCI_ISO_TD_NAK_DSTATE;
extern uint16_t _TRACE_USB_OHCI_ISO_TD_BAD_RESPONSE_DSTATE;
extern uint16_t _TRACE_USB_OHCI_PORT_ATTACH_DSTATE;
extern uint16_t _TRACE_USB_OHCI_PORT_DETACH_DSTATE;
extern uint16_t _TRACE_USB_OHCI_PORT_WAKEUP_DSTATE;
extern uint16_t _TRACE_USB_OHCI_PORT_SUSPEND_DSTATE;
extern uint16_t _TRACE_USB_OHCI_PORT_RESET_DSTATE;
extern uint16_t _TRACE_USB_OHCI_REMOTE_WAKEUP_DSTATE;
extern uint16_t _TRACE_USB_OHCI_RESET_DSTATE;
extern uint16_t _TRACE_USB_OHCI_START_DSTATE;
extern uint16_t _TRACE_USB_OHCI_RESUME_DSTATE;
extern uint16_t _TRACE_USB_OHCI_STOP_DSTATE;
extern uint16_t _TRACE_USB_OHCI_SET_CTL_DSTATE;
extern uint16_t _TRACE_USB_OHCI_TD_UNDERRUN_DSTATE;
extern uint16_t _TRACE_USB_OHCI_TD_DEV_ERROR_DSTATE;
extern uint16_t _TRACE_USB_OHCI_TD_NAK_DSTATE;
extern uint16_t _TRACE_USB_OHCI_TD_STALL_DSTATE;
extern uint16_t _TRACE_USB_OHCI_TD_BABBLE_DSTATE;
extern uint16_t _TRACE_USB_OHCI_TD_BAD_DEVICE_RESPONSE_DSTATE;
extern uint16_t _TRACE_USB_OHCI_TD_READ_ERROR_DSTATE;
extern uint16_t _TRACE_USB_OHCI_TD_BAD_DIRECTION_DSTATE;
extern uint16_t _TRACE_USB_OHCI_TD_SKIP_ASYNC_DSTATE;
extern uint16_t _TRACE_USB_OHCI_TD_PKT_HDR_DSTATE;
extern uint16_t _TRACE_USB_OHCI_TD_PKT_SHORT_DSTATE;
extern uint16_t _TRACE_USB_OHCI_TD_PKT_FULL_DSTATE;
extern uint16_t _TRACE_USB_OHCI_TD_TOO_MANY_PENDING_DSTATE;
extern uint16_t _TRACE_USB_OHCI_TD_PACKET_STATUS_DSTATE;
extern uint16_t _TRACE_USB_OHCI_ED_READ_ERROR_DSTATE;
extern uint16_t _TRACE_USB_OHCI_ED_PKT_DSTATE;
extern uint16_t _TRACE_USB_OHCI_ED_PKT_FLAGS_DSTATE;
extern uint16_t _TRACE_USB_OHCI_HCCA_READ_ERROR_DSTATE;
extern uint16_t _TRACE_USB_OHCI_MEM_READ_UNALIGNED_DSTATE;
extern uint16_t _TRACE_USB_OHCI_MEM_READ_BAD_OFFSET_DSTATE;
extern uint16_t _TRACE_USB_OHCI_MEM_WRITE_UNALIGNED_DSTATE;
extern uint16_t _TRACE_USB_OHCI_MEM_WRITE_BAD_OFFSET_DSTATE;
extern uint16_t _TRACE_USB_OHCI_PROCESS_LISTS_DSTATE;
extern uint16_t _TRACE_USB_OHCI_SET_FRAME_INTERVAL_DSTATE;
extern uint16_t _TRACE_USB_OHCI_HUB_POWER_UP_DSTATE;
extern uint16_t _TRACE_USB_OHCI_HUB_POWER_DOWN_DSTATE;
extern uint16_t _TRACE_USB_OHCI_INIT_TIME_DSTATE;
extern uint16_t _TRACE_USB_OHCI_DIE_DSTATE;
extern uint16_t _TRACE_USB_OHCI_ASYNC_COMPLETE_DSTATE;
extern uint16_t _TRACE_USB_EHCI_RESET_DSTATE;
extern uint16_t _TRACE_USB_EHCI_UNREALIZE_DSTATE;
extern uint16_t _TRACE_USB_EHCI_OPREG_READ_DSTATE;
extern uint16_t _TRACE_USB_EHCI_OPREG_WRITE_DSTATE;
extern uint16_t _TRACE_USB_EHCI_OPREG_CHANGE_DSTATE;
extern uint16_t _TRACE_USB_EHCI_PORTSC_READ_DSTATE;
extern uint16_t _TRACE_USB_EHCI_PORTSC_WRITE_DSTATE;
extern uint16_t _TRACE_USB_EHCI_PORTSC_CHANGE_DSTATE;
extern uint16_t _TRACE_USB_EHCI_USBSTS_DSTATE;
extern uint16_t _TRACE_USB_EHCI_STATE_DSTATE;
extern uint16_t _TRACE_USB_EHCI_QH_PTRS_DSTATE;
extern uint16_t _TRACE_USB_EHCI_QH_FIELDS_DSTATE;
extern uint16_t _TRACE_USB_EHCI_QH_BITS_DSTATE;
extern uint16_t _TRACE_USB_EHCI_QTD_PTRS_DSTATE;
extern uint16_t _TRACE_USB_EHCI_QTD_FIELDS_DSTATE;
extern uint16_t _TRACE_USB_EHCI_QTD_BITS_DSTATE;
extern uint16_t _TRACE_USB_EHCI_ITD_DSTATE;
extern uint16_t _TRACE_USB_EHCI_SITD_DSTATE;
extern uint16_t _TRACE_USB_EHCI_PORT_ATTACH_DSTATE;
extern uint16_t _TRACE_USB_EHCI_PORT_DETACH_DSTATE;
extern uint16_t _TRACE_USB_EHCI_PORT_RESET_DSTATE;
extern uint16_t _TRACE_USB_EHCI_PORT_SUSPEND_DSTATE;
extern uint16_t _TRACE_USB_EHCI_PORT_WAKEUP_DSTATE;
extern uint16_t _TRACE_USB_EHCI_PORT_RESUME_DSTATE;
extern uint16_t _TRACE_USB_EHCI_QUEUE_ACTION_DSTATE;
extern uint16_t _TRACE_USB_EHCI_PACKET_ACTION_DSTATE;
extern uint16_t _TRACE_USB_EHCI_IRQ_DSTATE;
extern uint16_t _TRACE_USB_EHCI_GUEST_BUG_DSTATE;
extern uint16_t _TRACE_USB_EHCI_DOORBELL_RING_DSTATE;
extern uint16_t _TRACE_USB_EHCI_DOORBELL_ACK_DSTATE;
extern uint16_t _TRACE_USB_EHCI_DMA_ERROR_DSTATE;
extern uint16_t _TRACE_USB_UHCI_RESET_DSTATE;
extern uint16_t _TRACE_USB_UHCI_EXIT_DSTATE;
extern uint16_t _TRACE_USB_UHCI_SCHEDULE_START_DSTATE;
extern uint16_t _TRACE_USB_UHCI_SCHEDULE_STOP_DSTATE;
extern uint16_t _TRACE_USB_UHCI_FRAME_START_DSTATE;
extern uint16_t _TRACE_USB_UHCI_FRAME_STOP_BANDWIDTH_DSTATE;
extern uint16_t _TRACE_USB_UHCI_FRAME_LOOP_STOP_IDLE_DSTATE;
extern uint16_t _TRACE_USB_UHCI_FRAME_LOOP_CONTINUE_DSTATE;
extern uint16_t _TRACE_USB_UHCI_MMIO_READW_DSTATE;
extern uint16_t _TRACE_USB_UHCI_MMIO_WRITEW_DSTATE;
extern uint16_t _TRACE_USB_UHCI_QUEUE_ADD_DSTATE;
extern uint16_t _TRACE_USB_UHCI_QUEUE_DEL_DSTATE;
extern uint16_t _TRACE_USB_UHCI_PACKET_ADD_DSTATE;
extern uint16_t _TRACE_USB_UHCI_PACKET_LINK_ASYNC_DSTATE;
extern uint16_t _TRACE_USB_UHCI_PACKET_UNLINK_ASYNC_DSTATE;
extern uint16_t _TRACE_USB_UHCI_PACKET_CANCEL_DSTATE;
extern uint16_t _TRACE_USB_UHCI_PACKET_COMPLETE_SUCCESS_DSTATE;
extern uint16_t _TRACE_USB_UHCI_PACKET_COMPLETE_SHORTXFER_DSTATE;
extern uint16_t _TRACE_USB_UHCI_PACKET_COMPLETE_STALL_DSTATE;
extern uint16_t _TRACE_USB_UHCI_PACKET_COMPLETE_BABBLE_DSTATE;
extern uint16_t _TRACE_USB_UHCI_PACKET_COMPLETE_ERROR_DSTATE;
extern uint16_t _TRACE_USB_UHCI_PACKET_DEL_DSTATE;
extern uint16_t _TRACE_USB_UHCI_QH_LOAD_DSTATE;
extern uint16_t _TRACE_USB_UHCI_TD_LOAD_DSTATE;
extern uint16_t _TRACE_USB_UHCI_TD_QUEUE_DSTATE;
extern uint16_t _TRACE_USB_UHCI_TD_NEXTQH_DSTATE;
extern uint16_t _TRACE_USB_UHCI_TD_ASYNC_DSTATE;
extern uint16_t _TRACE_USB_UHCI_TD_COMPLETE_DSTATE;
extern uint16_t _TRACE_USB_XHCI_RESET_DSTATE;
extern uint16_t _TRACE_USB_XHCI_EXIT_DSTATE;
extern uint16_t _TRACE_USB_XHCI_RUN_DSTATE;
extern uint16_t _TRACE_USB_XHCI_STOP_DSTATE;
extern uint16_t _TRACE_USB_XHCI_CAP_READ_DSTATE;
extern uint16_t _TRACE_USB_XHCI_OPER_READ_DSTATE;
extern uint16_t _TRACE_USB_XHCI_PORT_READ_DSTATE;
extern uint16_t _TRACE_USB_XHCI_RUNTIME_READ_DSTATE;
extern uint16_t _TRACE_USB_XHCI_DOORBELL_READ_DSTATE;
extern uint16_t _TRACE_USB_XHCI_OPER_WRITE_DSTATE;
extern uint16_t _TRACE_USB_XHCI_PORT_WRITE_DSTATE;
extern uint16_t _TRACE_USB_XHCI_RUNTIME_WRITE_DSTATE;
extern uint16_t _TRACE_USB_XHCI_DOORBELL_WRITE_DSTATE;
extern uint16_t _TRACE_USB_XHCI_IRQ_INTX_DSTATE;
extern uint16_t _TRACE_USB_XHCI_IRQ_MSI_DSTATE;
extern uint16_t _TRACE_USB_XHCI_IRQ_MSIX_DSTATE;
extern uint16_t _TRACE_USB_XHCI_IRQ_MSIX_USE_DSTATE;
extern uint16_t _TRACE_USB_XHCI_IRQ_MSIX_UNUSE_DSTATE;
extern uint16_t _TRACE_USB_XHCI_QUEUE_EVENT_DSTATE;
extern uint16_t _TRACE_USB_XHCI_FETCH_TRB_DSTATE;
extern uint16_t _TRACE_USB_XHCI_PORT_RESET_DSTATE;
extern uint16_t _TRACE_USB_XHCI_PORT_LINK_DSTATE;
extern uint16_t _TRACE_USB_XHCI_PORT_NOTIFY_DSTATE;
extern uint16_t _TRACE_USB_XHCI_SLOT_ENABLE_DSTATE;
extern uint16_t _TRACE_USB_XHCI_SLOT_DISABLE_DSTATE;
extern uint16_t _TRACE_USB_XHCI_SLOT_ADDRESS_DSTATE;
extern uint16_t _TRACE_USB_XHCI_SLOT_CONFIGURE_DSTATE;
extern uint16_t _TRACE_USB_XHCI_SLOT_EVALUATE_DSTATE;
extern uint16_t _TRACE_USB_XHCI_SLOT_RESET_DSTATE;
extern uint16_t _TRACE_USB_XHCI_EP_ENABLE_DSTATE;
extern uint16_t _TRACE_USB_XHCI_EP_DISABLE_DSTATE;
extern uint16_t _TRACE_USB_XHCI_EP_SET_DEQUEUE_DSTATE;
extern uint16_t _TRACE_USB_XHCI_EP_KICK_DSTATE;
extern uint16_t _TRACE_USB_XHCI_EP_STOP_DSTATE;
extern uint16_t _TRACE_USB_XHCI_EP_RESET_DSTATE;
extern uint16_t _TRACE_USB_XHCI_EP_STATE_DSTATE;
extern uint16_t _TRACE_USB_XHCI_XFER_START_DSTATE;
extern uint16_t _TRACE_USB_XHCI_XFER_ASYNC_DSTATE;
extern uint16_t _TRACE_USB_XHCI_XFER_NAK_DSTATE;
extern uint16_t _TRACE_USB_XHCI_XFER_RETRY_DSTATE;
extern uint16_t _TRACE_USB_XHCI_XFER_SUCCESS_DSTATE;
extern uint16_t _TRACE_USB_XHCI_XFER_ERROR_DSTATE;
extern uint16_t _TRACE_USB_XHCI_UNIMPLEMENTED_DSTATE;
extern uint16_t _TRACE_USB_XHCI_ENFORCED_LIMIT_DSTATE;
extern uint16_t _TRACE_USB_DWC2_UPDATE_IRQ_DSTATE;
extern uint16_t _TRACE_USB_DWC2_RAISE_GLOBAL_IRQ_DSTATE;
extern uint16_t _TRACE_USB_DWC2_LOWER_GLOBAL_IRQ_DSTATE;
extern uint16_t _TRACE_USB_DWC2_RAISE_HOST_IRQ_DSTATE;
extern uint16_t _TRACE_USB_DWC2_LOWER_HOST_IRQ_DSTATE;
extern uint16_t _TRACE_USB_DWC2_SOF_DSTATE;
extern uint16_t _TRACE_USB_DWC2_BUS_START_DSTATE;
extern uint16_t _TRACE_USB_DWC2_BUS_STOP_DSTATE;
extern uint16_t _TRACE_USB_DWC2_FIND_DEVICE_DSTATE;
extern uint16_t _TRACE_USB_DWC2_PORT_DISABLED_DSTATE;
extern uint16_t _TRACE_USB_DWC2_DEVICE_FOUND_DSTATE;
extern uint16_t _TRACE_USB_DWC2_DEVICE_NOT_FOUND_DSTATE;
extern uint16_t _TRACE_USB_DWC2_HANDLE_PACKET_DSTATE;
extern uint16_t _TRACE_USB_DWC2_MEMORY_READ_DSTATE;
extern uint16_t _TRACE_USB_DWC2_PACKET_STATUS_DSTATE;
extern uint16_t _TRACE_USB_DWC2_PACKET_ERROR_DSTATE;
extern uint16_t _TRACE_USB_DWC2_ASYNC_PACKET_DSTATE;
extern uint16_t _TRACE_USB_DWC2_MEMORY_WRITE_DSTATE;
extern uint16_t _TRACE_USB_DWC2_PACKET_DONE_DSTATE;
extern uint16_t _TRACE_USB_DWC2_PACKET_NEXT_DSTATE;
extern uint16_t _TRACE_USB_DWC2_ATTACH_DSTATE;
extern uint16_t _TRACE_USB_DWC2_ATTACH_SPEED_DSTATE;
extern uint16_t _TRACE_USB_DWC2_DETACH_DSTATE;
extern uint16_t _TRACE_USB_DWC2_CHILD_DETACH_DSTATE;
extern uint16_t _TRACE_USB_DWC2_WAKEUP_DSTATE;
extern uint16_t _TRACE_USB_DWC2_ASYNC_PACKET_COMPLETE_DSTATE;
extern uint16_t _TRACE_USB_DWC2_WORK_BH_DSTATE;
extern uint16_t _TRACE_USB_DWC2_WORK_BH_SERVICE_DSTATE;
extern uint16_t _TRACE_USB_DWC2_WORK_BH_NEXT_DSTATE;
extern uint16_t _TRACE_USB_DWC2_ENABLE_CHAN_DSTATE;
extern uint16_t _TRACE_USB_DWC2_GLBREG_READ_DSTATE;
extern uint16_t _TRACE_USB_DWC2_GLBREG_WRITE_DSTATE;
extern uint16_t _TRACE_USB_DWC2_FSZREG_READ_DSTATE;
extern uint16_t _TRACE_USB_DWC2_FSZREG_WRITE_DSTATE;
extern uint16_t _TRACE_USB_DWC2_HREG0_READ_DSTATE;
extern uint16_t _TRACE_USB_DWC2_HREG0_WRITE_DSTATE;
extern uint16_t _TRACE_USB_DWC2_HREG1_READ_DSTATE;
extern uint16_t _TRACE_USB_DWC2_HREG1_WRITE_DSTATE;
extern uint16_t _TRACE_USB_DWC2_PCGREG_READ_DSTATE;
extern uint16_t _TRACE_USB_DWC2_PCGREG_WRITE_DSTATE;
extern uint16_t _TRACE_USB_DWC2_HREG2_READ_DSTATE;
extern uint16_t _TRACE_USB_DWC2_HREG2_WRITE_DSTATE;
extern uint16_t _TRACE_USB_DWC2_HREG0_ACTION_DSTATE;
extern uint16_t _TRACE_USB_DWC2_WAKEUP_ENDPOINT_DSTATE;
extern uint16_t _TRACE_USB_DWC2_WORK_TIMER_DSTATE;
extern uint16_t _TRACE_USB_DWC2_RESET_ENTER_DSTATE;
extern uint16_t _TRACE_USB_DWC2_RESET_HOLD_DSTATE;
extern uint16_t _TRACE_USB_DWC2_RESET_EXIT_DSTATE;
extern uint16_t _TRACE_USB_DESC_DEVICE_DSTATE;
extern uint16_t _TRACE_USB_DESC_DEVICE_QUALIFIER_DSTATE;
extern uint16_t _TRACE_USB_DESC_CONFIG_DSTATE;
extern uint16_t _TRACE_USB_DESC_OTHER_SPEED_CONFIG_DSTATE;
extern uint16_t _TRACE_USB_DESC_STRING_DSTATE;
extern uint16_t _TRACE_USB_DESC_BOS_DSTATE;
extern uint16_t _TRACE_USB_DESC_MSOS_DSTATE;
extern uint16_t _TRACE_USB_SET_ADDR_DSTATE;
extern uint16_t _TRACE_USB_SET_CONFIG_DSTATE;
extern uint16_t _TRACE_USB_SET_INTERFACE_DSTATE;
extern uint16_t _TRACE_USB_CLEAR_DEVICE_FEATURE_DSTATE;
extern uint16_t _TRACE_USB_SET_DEVICE_FEATURE_DSTATE;
extern uint16_t _TRACE_USB_HUB_RESET_DSTATE;
extern uint16_t _TRACE_USB_HUB_CONTROL_DSTATE;
extern uint16_t _TRACE_USB_HUB_GET_PORT_STATUS_DSTATE;
extern uint16_t _TRACE_USB_HUB_SET_PORT_FEATURE_DSTATE;
extern uint16_t _TRACE_USB_HUB_CLEAR_PORT_FEATURE_DSTATE;
extern uint16_t _TRACE_USB_HUB_ATTACH_DSTATE;
extern uint16_t _TRACE_USB_HUB_DETACH_DSTATE;
extern uint16_t _TRACE_USB_HUB_STATUS_REPORT_DSTATE;
extern uint16_t _TRACE_USB_MSD_RESET_DSTATE;
extern uint16_t _TRACE_USB_MSD_MAXLUN_DSTATE;
extern uint16_t _TRACE_USB_MSD_SEND_STATUS_DSTATE;
extern uint16_t _TRACE_USB_MSD_DATA_IN_DSTATE;
extern uint16_t _TRACE_USB_MSD_DATA_OUT_DSTATE;
extern uint16_t _TRACE_USB_MSD_PACKET_ASYNC_DSTATE;
extern uint16_t _TRACE_USB_MSD_PACKET_COMPLETE_DSTATE;
extern uint16_t _TRACE_USB_MSD_CMD_SUBMIT_DSTATE;
extern uint16_t _TRACE_USB_MSD_CMD_COMPLETE_DSTATE;
extern uint16_t _TRACE_USB_MSD_CMD_CANCEL_DSTATE;
extern uint16_t _TRACE_USB_UAS_RESET_DSTATE;
extern uint16_t _TRACE_USB_UAS_COMMAND_DSTATE;
extern uint16_t _TRACE_USB_UAS_RESPONSE_DSTATE;
extern uint16_t _TRACE_USB_UAS_SENSE_DSTATE;
extern uint16_t _TRACE_USB_UAS_READ_READY_DSTATE;
extern uint16_t _TRACE_USB_UAS_WRITE_READY_DSTATE;
extern uint16_t _TRACE_USB_UAS_XFER_DATA_DSTATE;
extern uint16_t _TRACE_USB_UAS_SCSI_DATA_DSTATE;
extern uint16_t _TRACE_USB_UAS_SCSI_COMPLETE_DSTATE;
extern uint16_t _TRACE_USB_UAS_TMF_ABORT_TASK_DSTATE;
extern uint16_t _TRACE_USB_UAS_TMF_LOGICAL_UNIT_RESET_DSTATE;
extern uint16_t _TRACE_USB_UAS_TMF_UNSUPPORTED_DSTATE;
extern uint16_t _TRACE_USB_MTP_RESET_DSTATE;
extern uint16_t _TRACE_USB_MTP_COMMAND_DSTATE;
extern uint16_t _TRACE_USB_MTP_SUCCESS_DSTATE;
extern uint16_t _TRACE_USB_MTP_ERROR_DSTATE;
extern uint16_t _TRACE_USB_MTP_DATA_IN_DSTATE;
extern uint16_t _TRACE_USB_MTP_XFER_DSTATE;
extern uint16_t _TRACE_USB_MTP_NAK_DSTATE;
extern uint16_t _TRACE_USB_MTP_STALL_DSTATE;
extern uint16_t _TRACE_USB_MTP_OP_GET_DEVICE_INFO_DSTATE;
extern uint16_t _TRACE_USB_MTP_OP_OPEN_SESSION_DSTATE;
extern uint16_t _TRACE_USB_MTP_OP_CLOSE_SESSION_DSTATE;
extern uint16_t _TRACE_USB_MTP_OP_GET_STORAGE_IDS_DSTATE;
extern uint16_t _TRACE_USB_MTP_OP_GET_STORAGE_INFO_DSTATE;
extern uint16_t _TRACE_USB_MTP_OP_GET_NUM_OBJECTS_DSTATE;
extern uint16_t _TRACE_USB_MTP_OP_GET_OBJECT_HANDLES_DSTATE;
extern uint16_t _TRACE_USB_MTP_OP_GET_OBJECT_INFO_DSTATE;
extern uint16_t _TRACE_USB_MTP_OP_GET_OBJECT_DSTATE;
extern uint16_t _TRACE_USB_MTP_OP_GET_PARTIAL_OBJECT_DSTATE;
extern uint16_t _TRACE_USB_MTP_OP_UNKNOWN_DSTATE;
extern uint16_t _TRACE_USB_MTP_OBJECT_ALLOC_DSTATE;
extern uint16_t _TRACE_USB_MTP_OBJECT_FREE_DSTATE;
extern uint16_t _TRACE_USB_MTP_ADD_CHILD_DSTATE;
extern uint16_t _TRACE_USB_MTP_FILE_MONITOR_EVENT_DSTATE;
extern uint16_t _TRACE_USB_HOST_OPEN_STARTED_DSTATE;
extern uint16_t _TRACE_USB_HOST_OPEN_HOSTFD_DSTATE;
extern uint16_t _TRACE_USB_HOST_OPEN_SUCCESS_DSTATE;
extern uint16_t _TRACE_USB_HOST_OPEN_FAILURE_DSTATE;
extern uint16_t _TRACE_USB_HOST_CLOSE_DSTATE;
extern uint16_t _TRACE_USB_HOST_ATTACH_KERNEL_DSTATE;
extern uint16_t _TRACE_USB_HOST_DETACH_KERNEL_DSTATE;
extern uint16_t _TRACE_USB_HOST_SET_ADDRESS_DSTATE;
extern uint16_t _TRACE_USB_HOST_SET_CONFIG_DSTATE;
extern uint16_t _TRACE_USB_HOST_SET_INTERFACE_DSTATE;
extern uint16_t _TRACE_USB_HOST_CLAIM_INTERFACE_DSTATE;
extern uint16_t _TRACE_USB_HOST_RELEASE_INTERFACE_DSTATE;
extern uint16_t _TRACE_USB_HOST_REQ_CONTROL_DSTATE;
extern uint16_t _TRACE_USB_HOST_REQ_DATA_DSTATE;
extern uint16_t _TRACE_USB_HOST_REQ_COMPLETE_DSTATE;
extern uint16_t _TRACE_USB_HOST_REQ_EMULATED_DSTATE;
extern uint16_t _TRACE_USB_HOST_REQ_CANCELED_DSTATE;
extern uint16_t _TRACE_USB_HOST_ISO_START_DSTATE;
extern uint16_t _TRACE_USB_HOST_ISO_STOP_DSTATE;
extern uint16_t _TRACE_USB_HOST_ISO_OUT_OF_BUFS_DSTATE;
extern uint16_t _TRACE_USB_HOST_RESET_DSTATE;
extern uint16_t _TRACE_USB_HOST_AUTO_SCAN_ENABLED_DSTATE;
extern uint16_t _TRACE_USB_HOST_AUTO_SCAN_DISABLED_DSTATE;
extern uint16_t _TRACE_USB_HOST_PARSE_CONFIG_DSTATE;
extern uint16_t _TRACE_USB_HOST_PARSE_INTERFACE_DSTATE;
extern uint16_t _TRACE_USB_HOST_PARSE_ENDPOINT_DSTATE;
extern uint16_t _TRACE_USB_HOST_PARSE_ERROR_DSTATE;
extern uint16_t _TRACE_USB_HOST_REMOTE_WAKEUP_REMOVED_DSTATE;
extern uint16_t _TRACE_USB_SERIAL_RESET_DSTATE;
extern uint16_t _TRACE_USB_SERIAL_HANDLE_CONTROL_DSTATE;
extern uint16_t _TRACE_USB_SERIAL_UNSUPPORTED_PARITY_DSTATE;
extern uint16_t _TRACE_USB_SERIAL_UNSUPPORTED_STOPBITS_DSTATE;
extern uint16_t _TRACE_USB_SERIAL_UNSUPPORTED_CONTROL_DSTATE;
extern uint16_t _TRACE_USB_SERIAL_UNSUPPORTED_DATA_BITS_DSTATE;
extern uint16_t _TRACE_USB_SERIAL_BAD_TOKEN_DSTATE;
extern uint16_t _TRACE_USB_SERIAL_SET_BAUD_DSTATE;
extern uint16_t _TRACE_USB_SERIAL_SET_DATA_DSTATE;
extern uint16_t _TRACE_USB_SERIAL_SET_FLOW_CONTROL_DSTATE;
extern uint16_t _TRACE_USB_SERIAL_SET_XONXOFF_DSTATE;
#define TRACE_USB_PACKET_STATE_CHANGE_ENABLED 1
#define TRACE_USB_PACKET_STATE_FAULT_ENABLED 1
#define TRACE_USB_PORT_CLAIM_ENABLED 1
#define TRACE_USB_PORT_ATTACH_ENABLED 1
#define TRACE_USB_PORT_DETACH_ENABLED 1
#define TRACE_USB_PORT_RELEASE_ENABLED 1
#define TRACE_USB_OHCI_EXIT_ENABLED 1
#define TRACE_USB_OHCI_ISO_TD_READ_FAILED_ENABLED 1
#define TRACE_USB_OHCI_ISO_TD_HEAD_ENABLED 1
#define TRACE_USB_OHCI_ISO_TD_HEAD_OFFSET_ENABLED 1
#define TRACE_USB_OHCI_ISO_TD_RELATIVE_FRAME_NUMBER_NEG_ENABLED 1
#define TRACE_USB_OHCI_ISO_TD_RELATIVE_FRAME_NUMBER_BIG_ENABLED 1
#define TRACE_USB_OHCI_ISO_TD_BAD_DIRECTION_ENABLED 1
#define TRACE_USB_OHCI_ISO_TD_BAD_BP_BE_ENABLED 1
#define TRACE_USB_OHCI_ISO_TD_BAD_CC_NOT_ACCESSED_ENABLED 1
#define TRACE_USB_OHCI_ISO_TD_BAD_CC_OVERRUN_ENABLED 1
#define TRACE_USB_OHCI_ISO_TD_SO_ENABLED 1
#define TRACE_USB_OHCI_ISO_TD_DATA_OVERRUN_ENABLED 1
#define TRACE_USB_OHCI_ISO_TD_DATA_UNDERRUN_ENABLED 1
#define TRACE_USB_OHCI_ISO_TD_NAK_ENABLED 1
#define TRACE_USB_OHCI_ISO_TD_BAD_RESPONSE_ENABLED 1
#define TRACE_USB_OHCI_PORT_ATTACH_ENABLED 1
#define TRACE_USB_OHCI_PORT_DETACH_ENABLED 1
#define TRACE_USB_OHCI_PORT_WAKEUP_ENABLED 1
#define TRACE_USB_OHCI_PORT_SUSPEND_ENABLED 1
#define TRACE_USB_OHCI_PORT_RESET_ENABLED 1
#define TRACE_USB_OHCI_REMOTE_WAKEUP_ENABLED 1
#define TRACE_USB_OHCI_RESET_ENABLED 1
#define TRACE_USB_OHCI_START_ENABLED 1
#define TRACE_USB_OHCI_RESUME_ENABLED 1
#define TRACE_USB_OHCI_STOP_ENABLED 1
#define TRACE_USB_OHCI_SET_CTL_ENABLED 1
#define TRACE_USB_OHCI_TD_UNDERRUN_ENABLED 1
#define TRACE_USB_OHCI_TD_DEV_ERROR_ENABLED 1
#define TRACE_USB_OHCI_TD_NAK_ENABLED 1
#define TRACE_USB_OHCI_TD_STALL_ENABLED 1
#define TRACE_USB_OHCI_TD_BABBLE_ENABLED 1
#define TRACE_USB_OHCI_TD_BAD_DEVICE_RESPONSE_ENABLED 1
#define TRACE_USB_OHCI_TD_READ_ERROR_ENABLED 1
#define TRACE_USB_OHCI_TD_BAD_DIRECTION_ENABLED 1
#define TRACE_USB_OHCI_TD_SKIP_ASYNC_ENABLED 1
#define TRACE_USB_OHCI_TD_PKT_HDR_ENABLED 1
#define TRACE_USB_OHCI_TD_PKT_SHORT_ENABLED 1
#define TRACE_USB_OHCI_TD_PKT_FULL_ENABLED 1
#define TRACE_USB_OHCI_TD_TOO_MANY_PENDING_ENABLED 1
#define TRACE_USB_OHCI_TD_PACKET_STATUS_ENABLED 1
#define TRACE_USB_OHCI_ED_READ_ERROR_ENABLED 1
#define TRACE_USB_OHCI_ED_PKT_ENABLED 1
#define TRACE_USB_OHCI_ED_PKT_FLAGS_ENABLED 1
#define TRACE_USB_OHCI_HCCA_READ_ERROR_ENABLED 1
#define TRACE_USB_OHCI_MEM_READ_UNALIGNED_ENABLED 1
#define TRACE_USB_OHCI_MEM_READ_BAD_OFFSET_ENABLED 1
#define TRACE_USB_OHCI_MEM_WRITE_UNALIGNED_ENABLED 1
#define TRACE_USB_OHCI_MEM_WRITE_BAD_OFFSET_ENABLED 1
#define TRACE_USB_OHCI_PROCESS_LISTS_ENABLED 1
#define TRACE_USB_OHCI_SET_FRAME_INTERVAL_ENABLED 1
#define TRACE_USB_OHCI_HUB_POWER_UP_ENABLED 1
#define TRACE_USB_OHCI_HUB_POWER_DOWN_ENABLED 1
#define TRACE_USB_OHCI_INIT_TIME_ENABLED 1
#define TRACE_USB_OHCI_DIE_ENABLED 1
#define TRACE_USB_OHCI_ASYNC_COMPLETE_ENABLED 1
#define TRACE_USB_EHCI_RESET_ENABLED 1
#define TRACE_USB_EHCI_UNREALIZE_ENABLED 1
#define TRACE_USB_EHCI_OPREG_READ_ENABLED 1
#define TRACE_USB_EHCI_OPREG_WRITE_ENABLED 1
#define TRACE_USB_EHCI_OPREG_CHANGE_ENABLED 1
#define TRACE_USB_EHCI_PORTSC_READ_ENABLED 1
#define TRACE_USB_EHCI_PORTSC_WRITE_ENABLED 1
#define TRACE_USB_EHCI_PORTSC_CHANGE_ENABLED 1
#define TRACE_USB_EHCI_USBSTS_ENABLED 1
#define TRACE_USB_EHCI_STATE_ENABLED 1
#define TRACE_USB_EHCI_QH_PTRS_ENABLED 1
#define TRACE_USB_EHCI_QH_FIELDS_ENABLED 1
#define TRACE_USB_EHCI_QH_BITS_ENABLED 1
#define TRACE_USB_EHCI_QTD_PTRS_ENABLED 1
#define TRACE_USB_EHCI_QTD_FIELDS_ENABLED 1
#define TRACE_USB_EHCI_QTD_BITS_ENABLED 1
#define TRACE_USB_EHCI_ITD_ENABLED 1
#define TRACE_USB_EHCI_SITD_ENABLED 1
#define TRACE_USB_EHCI_PORT_ATTACH_ENABLED 1
#define TRACE_USB_EHCI_PORT_DETACH_ENABLED 1
#define TRACE_USB_EHCI_PORT_RESET_ENABLED 1
#define TRACE_USB_EHCI_PORT_SUSPEND_ENABLED 1
#define TRACE_USB_EHCI_PORT_WAKEUP_ENABLED 1
#define TRACE_USB_EHCI_PORT_RESUME_ENABLED 1
#define TRACE_USB_EHCI_QUEUE_ACTION_ENABLED 1
#define TRACE_USB_EHCI_PACKET_ACTION_ENABLED 1
#define TRACE_USB_EHCI_IRQ_ENABLED 1
#define TRACE_USB_EHCI_GUEST_BUG_ENABLED 1
#define TRACE_USB_EHCI_DOORBELL_RING_ENABLED 1
#define TRACE_USB_EHCI_DOORBELL_ACK_ENABLED 1
#define TRACE_USB_EHCI_DMA_ERROR_ENABLED 1
#define TRACE_USB_UHCI_RESET_ENABLED 1
#define TRACE_USB_UHCI_EXIT_ENABLED 1
#define TRACE_USB_UHCI_SCHEDULE_START_ENABLED 1
#define TRACE_USB_UHCI_SCHEDULE_STOP_ENABLED 1
#define TRACE_USB_UHCI_FRAME_START_ENABLED 1
#define TRACE_USB_UHCI_FRAME_STOP_BANDWIDTH_ENABLED 1
#define TRACE_USB_UHCI_FRAME_LOOP_STOP_IDLE_ENABLED 1
#define TRACE_USB_UHCI_FRAME_LOOP_CONTINUE_ENABLED 1
#define TRACE_USB_UHCI_MMIO_READW_ENABLED 1
#define TRACE_USB_UHCI_MMIO_WRITEW_ENABLED 1
#define TRACE_USB_UHCI_QUEUE_ADD_ENABLED 1
#define TRACE_USB_UHCI_QUEUE_DEL_ENABLED 1
#define TRACE_USB_UHCI_PACKET_ADD_ENABLED 1
#define TRACE_USB_UHCI_PACKET_LINK_ASYNC_ENABLED 1
#define TRACE_USB_UHCI_PACKET_UNLINK_ASYNC_ENABLED 1
#define TRACE_USB_UHCI_PACKET_CANCEL_ENABLED 1
#define TRACE_USB_UHCI_PACKET_COMPLETE_SUCCESS_ENABLED 1
#define TRACE_USB_UHCI_PACKET_COMPLETE_SHORTXFER_ENABLED 1
#define TRACE_USB_UHCI_PACKET_COMPLETE_STALL_ENABLED 1
#define TRACE_USB_UHCI_PACKET_COMPLETE_BABBLE_ENABLED 1
#define TRACE_USB_UHCI_PACKET_COMPLETE_ERROR_ENABLED 1
#define TRACE_USB_UHCI_PACKET_DEL_ENABLED 1
#define TRACE_USB_UHCI_QH_LOAD_ENABLED 1
#define TRACE_USB_UHCI_TD_LOAD_ENABLED 1
#define TRACE_USB_UHCI_TD_QUEUE_ENABLED 1
#define TRACE_USB_UHCI_TD_NEXTQH_ENABLED 1
#define TRACE_USB_UHCI_TD_ASYNC_ENABLED 1
#define TRACE_USB_UHCI_TD_COMPLETE_ENABLED 1
#define TRACE_USB_XHCI_RESET_ENABLED 1
#define TRACE_USB_XHCI_EXIT_ENABLED 1
#define TRACE_USB_XHCI_RUN_ENABLED 1
#define TRACE_USB_XHCI_STOP_ENABLED 1
#define TRACE_USB_XHCI_CAP_READ_ENABLED 1
#define TRACE_USB_XHCI_OPER_READ_ENABLED 1
#define TRACE_USB_XHCI_PORT_READ_ENABLED 1
#define TRACE_USB_XHCI_RUNTIME_READ_ENABLED 1
#define TRACE_USB_XHCI_DOORBELL_READ_ENABLED 1
#define TRACE_USB_XHCI_OPER_WRITE_ENABLED 1
#define TRACE_USB_XHCI_PORT_WRITE_ENABLED 1
#define TRACE_USB_XHCI_RUNTIME_WRITE_ENABLED 1
#define TRACE_USB_XHCI_DOORBELL_WRITE_ENABLED 1
#define TRACE_USB_XHCI_IRQ_INTX_ENABLED 1
#define TRACE_USB_XHCI_IRQ_MSI_ENABLED 1
#define TRACE_USB_XHCI_IRQ_MSIX_ENABLED 1
#define TRACE_USB_XHCI_IRQ_MSIX_USE_ENABLED 1
#define TRACE_USB_XHCI_IRQ_MSIX_UNUSE_ENABLED 1
#define TRACE_USB_XHCI_QUEUE_EVENT_ENABLED 1
#define TRACE_USB_XHCI_FETCH_TRB_ENABLED 1
#define TRACE_USB_XHCI_PORT_RESET_ENABLED 1
#define TRACE_USB_XHCI_PORT_LINK_ENABLED 1
#define TRACE_USB_XHCI_PORT_NOTIFY_ENABLED 1
#define TRACE_USB_XHCI_SLOT_ENABLE_ENABLED 1
#define TRACE_USB_XHCI_SLOT_DISABLE_ENABLED 1
#define TRACE_USB_XHCI_SLOT_ADDRESS_ENABLED 1
#define TRACE_USB_XHCI_SLOT_CONFIGURE_ENABLED 1
#define TRACE_USB_XHCI_SLOT_EVALUATE_ENABLED 1
#define TRACE_USB_XHCI_SLOT_RESET_ENABLED 1
#define TRACE_USB_XHCI_EP_ENABLE_ENABLED 1
#define TRACE_USB_XHCI_EP_DISABLE_ENABLED 1
#define TRACE_USB_XHCI_EP_SET_DEQUEUE_ENABLED 1
#define TRACE_USB_XHCI_EP_KICK_ENABLED 1
#define TRACE_USB_XHCI_EP_STOP_ENABLED 1
#define TRACE_USB_XHCI_EP_RESET_ENABLED 1
#define TRACE_USB_XHCI_EP_STATE_ENABLED 1
#define TRACE_USB_XHCI_XFER_START_ENABLED 1
#define TRACE_USB_XHCI_XFER_ASYNC_ENABLED 1
#define TRACE_USB_XHCI_XFER_NAK_ENABLED 1
#define TRACE_USB_XHCI_XFER_RETRY_ENABLED 1
#define TRACE_USB_XHCI_XFER_SUCCESS_ENABLED 1
#define TRACE_USB_XHCI_XFER_ERROR_ENABLED 1
#define TRACE_USB_XHCI_UNIMPLEMENTED_ENABLED 1
#define TRACE_USB_XHCI_ENFORCED_LIMIT_ENABLED 1
#define TRACE_USB_DWC2_UPDATE_IRQ_ENABLED 1
#define TRACE_USB_DWC2_RAISE_GLOBAL_IRQ_ENABLED 1
#define TRACE_USB_DWC2_LOWER_GLOBAL_IRQ_ENABLED 1
#define TRACE_USB_DWC2_RAISE_HOST_IRQ_ENABLED 1
#define TRACE_USB_DWC2_LOWER_HOST_IRQ_ENABLED 1
#define TRACE_USB_DWC2_SOF_ENABLED 1
#define TRACE_USB_DWC2_BUS_START_ENABLED 1
#define TRACE_USB_DWC2_BUS_STOP_ENABLED 1
#define TRACE_USB_DWC2_FIND_DEVICE_ENABLED 1
#define TRACE_USB_DWC2_PORT_DISABLED_ENABLED 1
#define TRACE_USB_DWC2_DEVICE_FOUND_ENABLED 1
#define TRACE_USB_DWC2_DEVICE_NOT_FOUND_ENABLED 1
#define TRACE_USB_DWC2_HANDLE_PACKET_ENABLED 1
#define TRACE_USB_DWC2_MEMORY_READ_ENABLED 1
#define TRACE_USB_DWC2_PACKET_STATUS_ENABLED 1
#define TRACE_USB_DWC2_PACKET_ERROR_ENABLED 1
#define TRACE_USB_DWC2_ASYNC_PACKET_ENABLED 1
#define TRACE_USB_DWC2_MEMORY_WRITE_ENABLED 1
#define TRACE_USB_DWC2_PACKET_DONE_ENABLED 1
#define TRACE_USB_DWC2_PACKET_NEXT_ENABLED 1
#define TRACE_USB_DWC2_ATTACH_ENABLED 1
#define TRACE_USB_DWC2_ATTACH_SPEED_ENABLED 1
#define TRACE_USB_DWC2_DETACH_ENABLED 1
#define TRACE_USB_DWC2_CHILD_DETACH_ENABLED 1
#define TRACE_USB_DWC2_WAKEUP_ENABLED 1
#define TRACE_USB_DWC2_ASYNC_PACKET_COMPLETE_ENABLED 1
#define TRACE_USB_DWC2_WORK_BH_ENABLED 1
#define TRACE_USB_DWC2_WORK_BH_SERVICE_ENABLED 1
#define TRACE_USB_DWC2_WORK_BH_NEXT_ENABLED 1
#define TRACE_USB_DWC2_ENABLE_CHAN_ENABLED 1
#define TRACE_USB_DWC2_GLBREG_READ_ENABLED 1
#define TRACE_USB_DWC2_GLBREG_WRITE_ENABLED 1
#define TRACE_USB_DWC2_FSZREG_READ_ENABLED 1
#define TRACE_USB_DWC2_FSZREG_WRITE_ENABLED 1
#define TRACE_USB_DWC2_HREG0_READ_ENABLED 1
#define TRACE_USB_DWC2_HREG0_WRITE_ENABLED 1
#define TRACE_USB_DWC2_HREG1_READ_ENABLED 1
#define TRACE_USB_DWC2_HREG1_WRITE_ENABLED 1
#define TRACE_USB_DWC2_PCGREG_READ_ENABLED 1
#define TRACE_USB_DWC2_PCGREG_WRITE_ENABLED 1
#define TRACE_USB_DWC2_HREG2_READ_ENABLED 1
#define TRACE_USB_DWC2_HREG2_WRITE_ENABLED 1
#define TRACE_USB_DWC2_HREG0_ACTION_ENABLED 1
#define TRACE_USB_DWC2_WAKEUP_ENDPOINT_ENABLED 1
#define TRACE_USB_DWC2_WORK_TIMER_ENABLED 1
#define TRACE_USB_DWC2_RESET_ENTER_ENABLED 1
#define TRACE_USB_DWC2_RESET_HOLD_ENABLED 1
#define TRACE_USB_DWC2_RESET_EXIT_ENABLED 1
#define TRACE_USB_DESC_DEVICE_ENABLED 1
#define TRACE_USB_DESC_DEVICE_QUALIFIER_ENABLED 1
#define TRACE_USB_DESC_CONFIG_ENABLED 1
#define TRACE_USB_DESC_OTHER_SPEED_CONFIG_ENABLED 1
#define TRACE_USB_DESC_STRING_ENABLED 1
#define TRACE_USB_DESC_BOS_ENABLED 1
#define TRACE_USB_DESC_MSOS_ENABLED 1
#define TRACE_USB_SET_ADDR_ENABLED 1
#define TRACE_USB_SET_CONFIG_ENABLED 1
#define TRACE_USB_SET_INTERFACE_ENABLED 1
#define TRACE_USB_CLEAR_DEVICE_FEATURE_ENABLED 1
#define TRACE_USB_SET_DEVICE_FEATURE_ENABLED 1
#define TRACE_USB_HUB_RESET_ENABLED 1
#define TRACE_USB_HUB_CONTROL_ENABLED 1
#define TRACE_USB_HUB_GET_PORT_STATUS_ENABLED 1
#define TRACE_USB_HUB_SET_PORT_FEATURE_ENABLED 1
#define TRACE_USB_HUB_CLEAR_PORT_FEATURE_ENABLED 1
#define TRACE_USB_HUB_ATTACH_ENABLED 1
#define TRACE_USB_HUB_DETACH_ENABLED 1
#define TRACE_USB_HUB_STATUS_REPORT_ENABLED 1
#define TRACE_USB_MSD_RESET_ENABLED 1
#define TRACE_USB_MSD_MAXLUN_ENABLED 1
#define TRACE_USB_MSD_SEND_STATUS_ENABLED 1
#define TRACE_USB_MSD_DATA_IN_ENABLED 1
#define TRACE_USB_MSD_DATA_OUT_ENABLED 1
#define TRACE_USB_MSD_PACKET_ASYNC_ENABLED 1
#define TRACE_USB_MSD_PACKET_COMPLETE_ENABLED 1
#define TRACE_USB_MSD_CMD_SUBMIT_ENABLED 1
#define TRACE_USB_MSD_CMD_COMPLETE_ENABLED 1
#define TRACE_USB_MSD_CMD_CANCEL_ENABLED 1
#define TRACE_USB_UAS_RESET_ENABLED 1
#define TRACE_USB_UAS_COMMAND_ENABLED 1
#define TRACE_USB_UAS_RESPONSE_ENABLED 1
#define TRACE_USB_UAS_SENSE_ENABLED 1
#define TRACE_USB_UAS_READ_READY_ENABLED 1
#define TRACE_USB_UAS_WRITE_READY_ENABLED 1
#define TRACE_USB_UAS_XFER_DATA_ENABLED 1
#define TRACE_USB_UAS_SCSI_DATA_ENABLED 1
#define TRACE_USB_UAS_SCSI_COMPLETE_ENABLED 1
#define TRACE_USB_UAS_TMF_ABORT_TASK_ENABLED 1
#define TRACE_USB_UAS_TMF_LOGICAL_UNIT_RESET_ENABLED 1
#define TRACE_USB_UAS_TMF_UNSUPPORTED_ENABLED 1
#define TRACE_USB_MTP_RESET_ENABLED 1
#define TRACE_USB_MTP_COMMAND_ENABLED 1
#define TRACE_USB_MTP_SUCCESS_ENABLED 1
#define TRACE_USB_MTP_ERROR_ENABLED 1
#define TRACE_USB_MTP_DATA_IN_ENABLED 1
#define TRACE_USB_MTP_XFER_ENABLED 1
#define TRACE_USB_MTP_NAK_ENABLED 1
#define TRACE_USB_MTP_STALL_ENABLED 1
#define TRACE_USB_MTP_OP_GET_DEVICE_INFO_ENABLED 1
#define TRACE_USB_MTP_OP_OPEN_SESSION_ENABLED 1
#define TRACE_USB_MTP_OP_CLOSE_SESSION_ENABLED 1
#define TRACE_USB_MTP_OP_GET_STORAGE_IDS_ENABLED 1
#define TRACE_USB_MTP_OP_GET_STORAGE_INFO_ENABLED 1
#define TRACE_USB_MTP_OP_GET_NUM_OBJECTS_ENABLED 1
#define TRACE_USB_MTP_OP_GET_OBJECT_HANDLES_ENABLED 1
#define TRACE_USB_MTP_OP_GET_OBJECT_INFO_ENABLED 1
#define TRACE_USB_MTP_OP_GET_OBJECT_ENABLED 1
#define TRACE_USB_MTP_OP_GET_PARTIAL_OBJECT_ENABLED 1
#define TRACE_USB_MTP_OP_UNKNOWN_ENABLED 1
#define TRACE_USB_MTP_OBJECT_ALLOC_ENABLED 1
#define TRACE_USB_MTP_OBJECT_FREE_ENABLED 1
#define TRACE_USB_MTP_ADD_CHILD_ENABLED 1
#define TRACE_USB_MTP_FILE_MONITOR_EVENT_ENABLED 1
#define TRACE_USB_HOST_OPEN_STARTED_ENABLED 1
#define TRACE_USB_HOST_OPEN_HOSTFD_ENABLED 1
#define TRACE_USB_HOST_OPEN_SUCCESS_ENABLED 1
#define TRACE_USB_HOST_OPEN_FAILURE_ENABLED 1
#define TRACE_USB_HOST_CLOSE_ENABLED 1
#define TRACE_USB_HOST_ATTACH_KERNEL_ENABLED 1
#define TRACE_USB_HOST_DETACH_KERNEL_ENABLED 1
#define TRACE_USB_HOST_SET_ADDRESS_ENABLED 1
#define TRACE_USB_HOST_SET_CONFIG_ENABLED 1
#define TRACE_USB_HOST_SET_INTERFACE_ENABLED 1
#define TRACE_USB_HOST_CLAIM_INTERFACE_ENABLED 1
#define TRACE_USB_HOST_RELEASE_INTERFACE_ENABLED 1
#define TRACE_USB_HOST_REQ_CONTROL_ENABLED 1
#define TRACE_USB_HOST_REQ_DATA_ENABLED 1
#define TRACE_USB_HOST_REQ_COMPLETE_ENABLED 1
#define TRACE_USB_HOST_REQ_EMULATED_ENABLED 1
#define TRACE_USB_HOST_REQ_CANCELED_ENABLED 1
#define TRACE_USB_HOST_ISO_START_ENABLED 1
#define TRACE_USB_HOST_ISO_STOP_ENABLED 1
#define TRACE_USB_HOST_ISO_OUT_OF_BUFS_ENABLED 1
#define TRACE_USB_HOST_RESET_ENABLED 1
#define TRACE_USB_HOST_AUTO_SCAN_ENABLED_ENABLED 1
#define TRACE_USB_HOST_AUTO_SCAN_DISABLED_ENABLED 1
#define TRACE_USB_HOST_PARSE_CONFIG_ENABLED 1
#define TRACE_USB_HOST_PARSE_INTERFACE_ENABLED 1
#define TRACE_USB_HOST_PARSE_ENDPOINT_ENABLED 1
#define TRACE_USB_HOST_PARSE_ERROR_ENABLED 1
#define TRACE_USB_HOST_REMOTE_WAKEUP_REMOVED_ENABLED 1
#define TRACE_USB_SERIAL_RESET_ENABLED 1
#define TRACE_USB_SERIAL_HANDLE_CONTROL_ENABLED 1
#define TRACE_USB_SERIAL_UNSUPPORTED_PARITY_ENABLED 1
#define TRACE_USB_SERIAL_UNSUPPORTED_STOPBITS_ENABLED 1
#define TRACE_USB_SERIAL_UNSUPPORTED_CONTROL_ENABLED 1
#define TRACE_USB_SERIAL_UNSUPPORTED_DATA_BITS_ENABLED 1
#define TRACE_USB_SERIAL_BAD_TOKEN_ENABLED 1
#define TRACE_USB_SERIAL_SET_BAUD_ENABLED 1
#define TRACE_USB_SERIAL_SET_DATA_ENABLED 1
#define TRACE_USB_SERIAL_SET_FLOW_CONTROL_ENABLED 1
#define TRACE_USB_SERIAL_SET_XONXOFF_ENABLED 1
#include "qemu/log-for-trace.h"


#define TRACE_USB_PACKET_STATE_CHANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_PACKET_STATE_CHANGE) || \
    false)

static inline void _nocheck__trace_usb_packet_state_change(int bus, const char * port, int ep, void * p, const char * o, const char * n)
{
    if (trace_event_get_state(TRACE_USB_PACKET_STATE_CHANGE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_packet_state_change " "bus %d, port %s, ep %d, packet %p, state %s -> %s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, port, ep, p, o, n);
    }
}

static inline void trace_usb_packet_state_change(int bus, const char * port, int ep, void * p, const char * o, const char * n)
{
    if (true) {
        _nocheck__trace_usb_packet_state_change(bus, port, ep, p, o, n);
    }
}

#define TRACE_USB_PACKET_STATE_FAULT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_PACKET_STATE_FAULT) || \
    false)

static inline void _nocheck__trace_usb_packet_state_fault(int bus, const char * port, int ep, void * p, const char * o, const char * n)
{
    if (trace_event_get_state(TRACE_USB_PACKET_STATE_FAULT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_packet_state_fault " "bus %d, port %s, ep %d, packet %p, state %s, expected %s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, port, ep, p, o, n);
    }
}

static inline void trace_usb_packet_state_fault(int bus, const char * port, int ep, void * p, const char * o, const char * n)
{
    if (true) {
        _nocheck__trace_usb_packet_state_fault(bus, port, ep, p, o, n);
    }
}

#define TRACE_USB_PORT_CLAIM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_PORT_CLAIM) || \
    false)

static inline void _nocheck__trace_usb_port_claim(int bus, const char * port)
{
    if (trace_event_get_state(TRACE_USB_PORT_CLAIM) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_port_claim " "bus %d, port %s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, port);
    }
}

static inline void trace_usb_port_claim(int bus, const char * port)
{
    if (true) {
        _nocheck__trace_usb_port_claim(bus, port);
    }
}

#define TRACE_USB_PORT_ATTACH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_PORT_ATTACH) || \
    false)

static inline void _nocheck__trace_usb_port_attach(int bus, const char * port, const char * devspeed, const char * portspeed)
{
    if (trace_event_get_state(TRACE_USB_PORT_ATTACH) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_port_attach " "bus %d, port %s, devspeed %s, portspeed %s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, port, devspeed, portspeed);
    }
}

static inline void trace_usb_port_attach(int bus, const char * port, const char * devspeed, const char * portspeed)
{
    if (true) {
        _nocheck__trace_usb_port_attach(bus, port, devspeed, portspeed);
    }
}

#define TRACE_USB_PORT_DETACH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_PORT_DETACH) || \
    false)

static inline void _nocheck__trace_usb_port_detach(int bus, const char * port)
{
    if (trace_event_get_state(TRACE_USB_PORT_DETACH) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_port_detach " "bus %d, port %s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, port);
    }
}

static inline void trace_usb_port_detach(int bus, const char * port)
{
    if (true) {
        _nocheck__trace_usb_port_detach(bus, port);
    }
}

#define TRACE_USB_PORT_RELEASE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_PORT_RELEASE) || \
    false)

static inline void _nocheck__trace_usb_port_release(int bus, const char * port)
{
    if (trace_event_get_state(TRACE_USB_PORT_RELEASE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_port_release " "bus %d, port %s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, port);
    }
}

static inline void trace_usb_port_release(int bus, const char * port)
{
    if (true) {
        _nocheck__trace_usb_port_release(bus, port);
    }
}

#define TRACE_USB_OHCI_EXIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_EXIT) || \
    false)

static inline void _nocheck__trace_usb_ohci_exit(const char * s)
{
    if (trace_event_get_state(TRACE_USB_OHCI_EXIT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_exit " "%s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s);
    }
}

static inline void trace_usb_ohci_exit(const char * s)
{
    if (true) {
        _nocheck__trace_usb_ohci_exit(s);
    }
}

#define TRACE_USB_OHCI_ISO_TD_READ_FAILED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_ISO_TD_READ_FAILED) || \
    false)

static inline void _nocheck__trace_usb_ohci_iso_td_read_failed(uint32_t addr)
{
    if (trace_event_get_state(TRACE_USB_OHCI_ISO_TD_READ_FAILED) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_iso_td_read_failed " "ISO_TD read error at 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr);
    }
}

static inline void trace_usb_ohci_iso_td_read_failed(uint32_t addr)
{
    if (true) {
        _nocheck__trace_usb_ohci_iso_td_read_failed(addr);
    }
}

#define TRACE_USB_OHCI_ISO_TD_HEAD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_ISO_TD_HEAD) || \
    false)

static inline void _nocheck__trace_usb_ohci_iso_td_head(uint32_t head, uint32_t tail, uint32_t flags, uint32_t bp, uint32_t next, uint32_t be, uint32_t framenum, uint32_t startframe, uint32_t framecount, int rel_frame_num)
{
    if (trace_event_get_state(TRACE_USB_OHCI_ISO_TD_HEAD) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_iso_td_head " "ISO_TD ED head 0x%.8x tailp 0x%.8x\n0x%.8x 0x%.8x 0x%.8x 0x%.8x\nframe_number 0x%.8x starting_frame 0x%.8x\nframe_count  0x%.8x relative %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , head, tail, flags, bp, next, be, framenum, startframe, framecount, rel_frame_num);
    }
}

static inline void trace_usb_ohci_iso_td_head(uint32_t head, uint32_t tail, uint32_t flags, uint32_t bp, uint32_t next, uint32_t be, uint32_t framenum, uint32_t startframe, uint32_t framecount, int rel_frame_num)
{
    if (true) {
        _nocheck__trace_usb_ohci_iso_td_head(head, tail, flags, bp, next, be, framenum, startframe, framecount, rel_frame_num);
    }
}

#define TRACE_USB_OHCI_ISO_TD_HEAD_OFFSET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_ISO_TD_HEAD_OFFSET) || \
    false)

static inline void _nocheck__trace_usb_ohci_iso_td_head_offset(uint32_t o0, uint32_t o1, uint32_t o2, uint32_t o3, uint32_t o4, uint32_t o5, uint32_t o6, uint32_t o7)
{
    if (trace_event_get_state(TRACE_USB_OHCI_ISO_TD_HEAD_OFFSET) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_iso_td_head_offset " "0x%.8x 0x%.8x 0x%.8x 0x%.8x 0x%.8x 0x%.8x 0x%.8x 0x%.8x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , o0, o1, o2, o3, o4, o5, o6, o7);
    }
}

static inline void trace_usb_ohci_iso_td_head_offset(uint32_t o0, uint32_t o1, uint32_t o2, uint32_t o3, uint32_t o4, uint32_t o5, uint32_t o6, uint32_t o7)
{
    if (true) {
        _nocheck__trace_usb_ohci_iso_td_head_offset(o0, o1, o2, o3, o4, o5, o6, o7);
    }
}

#define TRACE_USB_OHCI_ISO_TD_RELATIVE_FRAME_NUMBER_NEG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_ISO_TD_RELATIVE_FRAME_NUMBER_NEG) || \
    false)

static inline void _nocheck__trace_usb_ohci_iso_td_relative_frame_number_neg(int rel)
{
    if (trace_event_get_state(TRACE_USB_OHCI_ISO_TD_RELATIVE_FRAME_NUMBER_NEG) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_iso_td_relative_frame_number_neg " "ISO_TD R=%d < 0" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , rel);
    }
}

static inline void trace_usb_ohci_iso_td_relative_frame_number_neg(int rel)
{
    if (true) {
        _nocheck__trace_usb_ohci_iso_td_relative_frame_number_neg(rel);
    }
}

#define TRACE_USB_OHCI_ISO_TD_RELATIVE_FRAME_NUMBER_BIG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_ISO_TD_RELATIVE_FRAME_NUMBER_BIG) || \
    false)

static inline void _nocheck__trace_usb_ohci_iso_td_relative_frame_number_big(int rel, int count)
{
    if (trace_event_get_state(TRACE_USB_OHCI_ISO_TD_RELATIVE_FRAME_NUMBER_BIG) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_iso_td_relative_frame_number_big " "ISO_TD R=%d > FC=%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , rel, count);
    }
}

static inline void trace_usb_ohci_iso_td_relative_frame_number_big(int rel, int count)
{
    if (true) {
        _nocheck__trace_usb_ohci_iso_td_relative_frame_number_big(rel, count);
    }
}

#define TRACE_USB_OHCI_ISO_TD_BAD_DIRECTION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_ISO_TD_BAD_DIRECTION) || \
    false)

static inline void _nocheck__trace_usb_ohci_iso_td_bad_direction(int dir)
{
    if (trace_event_get_state(TRACE_USB_OHCI_ISO_TD_BAD_DIRECTION) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_iso_td_bad_direction " "Bad direction %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , dir);
    }
}

static inline void trace_usb_ohci_iso_td_bad_direction(int dir)
{
    if (true) {
        _nocheck__trace_usb_ohci_iso_td_bad_direction(dir);
    }
}

#define TRACE_USB_OHCI_ISO_TD_BAD_BP_BE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_ISO_TD_BAD_BP_BE) || \
    false)

static inline void _nocheck__trace_usb_ohci_iso_td_bad_bp_be(uint32_t bp, uint32_t be)
{
    if (trace_event_get_state(TRACE_USB_OHCI_ISO_TD_BAD_BP_BE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_iso_td_bad_bp_be " "ISO_TD bp 0x%.8x be 0x%.8x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bp, be);
    }
}

static inline void trace_usb_ohci_iso_td_bad_bp_be(uint32_t bp, uint32_t be)
{
    if (true) {
        _nocheck__trace_usb_ohci_iso_td_bad_bp_be(bp, be);
    }
}

#define TRACE_USB_OHCI_ISO_TD_BAD_CC_NOT_ACCESSED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_ISO_TD_BAD_CC_NOT_ACCESSED) || \
    false)

static inline void _nocheck__trace_usb_ohci_iso_td_bad_cc_not_accessed(uint32_t start, uint32_t next)
{
    if (trace_event_get_state(TRACE_USB_OHCI_ISO_TD_BAD_CC_NOT_ACCESSED) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_iso_td_bad_cc_not_accessed " "ISO_TD cc != not accessed 0x%.8x 0x%.8x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , start, next);
    }
}

static inline void trace_usb_ohci_iso_td_bad_cc_not_accessed(uint32_t start, uint32_t next)
{
    if (true) {
        _nocheck__trace_usb_ohci_iso_td_bad_cc_not_accessed(start, next);
    }
}

#define TRACE_USB_OHCI_ISO_TD_BAD_CC_OVERRUN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_ISO_TD_BAD_CC_OVERRUN) || \
    false)

static inline void _nocheck__trace_usb_ohci_iso_td_bad_cc_overrun(uint32_t start, uint32_t next)
{
    if (trace_event_get_state(TRACE_USB_OHCI_ISO_TD_BAD_CC_OVERRUN) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_iso_td_bad_cc_overrun " "ISO_TD start_offset=0x%.8x > next_offset=0x%.8x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , start, next);
    }
}

static inline void trace_usb_ohci_iso_td_bad_cc_overrun(uint32_t start, uint32_t next)
{
    if (true) {
        _nocheck__trace_usb_ohci_iso_td_bad_cc_overrun(start, next);
    }
}

#define TRACE_USB_OHCI_ISO_TD_SO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_ISO_TD_SO) || \
    false)

static inline void _nocheck__trace_usb_ohci_iso_td_so(uint32_t so, uint32_t eo, uint32_t s, uint32_t e, const char * str, ssize_t len, int ret)
{
    if (trace_event_get_state(TRACE_USB_OHCI_ISO_TD_SO) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_iso_td_so " "0x%.8x eo 0x%.8x\nsa 0x%.8x ea 0x%.8x\ndir %s len %zu ret %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , so, eo, s, e, str, len, ret);
    }
}

static inline void trace_usb_ohci_iso_td_so(uint32_t so, uint32_t eo, uint32_t s, uint32_t e, const char * str, ssize_t len, int ret)
{
    if (true) {
        _nocheck__trace_usb_ohci_iso_td_so(so, eo, s, e, str, len, ret);
    }
}

#define TRACE_USB_OHCI_ISO_TD_DATA_OVERRUN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_ISO_TD_DATA_OVERRUN) || \
    false)

static inline void _nocheck__trace_usb_ohci_iso_td_data_overrun(int ret, ssize_t len)
{
    if (trace_event_get_state(TRACE_USB_OHCI_ISO_TD_DATA_OVERRUN) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_iso_td_data_overrun " "DataOverrun %d > %zu" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , ret, len);
    }
}

static inline void trace_usb_ohci_iso_td_data_overrun(int ret, ssize_t len)
{
    if (true) {
        _nocheck__trace_usb_ohci_iso_td_data_overrun(ret, len);
    }
}

#define TRACE_USB_OHCI_ISO_TD_DATA_UNDERRUN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_ISO_TD_DATA_UNDERRUN) || \
    false)

static inline void _nocheck__trace_usb_ohci_iso_td_data_underrun(int ret)
{
    if (trace_event_get_state(TRACE_USB_OHCI_ISO_TD_DATA_UNDERRUN) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_iso_td_data_underrun " "DataUnderrun %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , ret);
    }
}

static inline void trace_usb_ohci_iso_td_data_underrun(int ret)
{
    if (true) {
        _nocheck__trace_usb_ohci_iso_td_data_underrun(ret);
    }
}

#define TRACE_USB_OHCI_ISO_TD_NAK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_ISO_TD_NAK) || \
    false)

static inline void _nocheck__trace_usb_ohci_iso_td_nak(int ret)
{
    if (trace_event_get_state(TRACE_USB_OHCI_ISO_TD_NAK) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_iso_td_nak " "got NAK/STALL %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , ret);
    }
}

static inline void trace_usb_ohci_iso_td_nak(int ret)
{
    if (true) {
        _nocheck__trace_usb_ohci_iso_td_nak(ret);
    }
}

#define TRACE_USB_OHCI_ISO_TD_BAD_RESPONSE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_ISO_TD_BAD_RESPONSE) || \
    false)

static inline void _nocheck__trace_usb_ohci_iso_td_bad_response(int ret)
{
    if (trace_event_get_state(TRACE_USB_OHCI_ISO_TD_BAD_RESPONSE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_iso_td_bad_response " "Bad device response %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , ret);
    }
}

static inline void trace_usb_ohci_iso_td_bad_response(int ret)
{
    if (true) {
        _nocheck__trace_usb_ohci_iso_td_bad_response(ret);
    }
}

#define TRACE_USB_OHCI_PORT_ATTACH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_PORT_ATTACH) || \
    false)

static inline void _nocheck__trace_usb_ohci_port_attach(int index)
{
    if (trace_event_get_state(TRACE_USB_OHCI_PORT_ATTACH) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_port_attach " "port #%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , index);
    }
}

static inline void trace_usb_ohci_port_attach(int index)
{
    if (true) {
        _nocheck__trace_usb_ohci_port_attach(index);
    }
}

#define TRACE_USB_OHCI_PORT_DETACH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_PORT_DETACH) || \
    false)

static inline void _nocheck__trace_usb_ohci_port_detach(int index)
{
    if (trace_event_get_state(TRACE_USB_OHCI_PORT_DETACH) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_port_detach " "port #%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , index);
    }
}

static inline void trace_usb_ohci_port_detach(int index)
{
    if (true) {
        _nocheck__trace_usb_ohci_port_detach(index);
    }
}

#define TRACE_USB_OHCI_PORT_WAKEUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_PORT_WAKEUP) || \
    false)

static inline void _nocheck__trace_usb_ohci_port_wakeup(int index)
{
    if (trace_event_get_state(TRACE_USB_OHCI_PORT_WAKEUP) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_port_wakeup " "port #%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , index);
    }
}

static inline void trace_usb_ohci_port_wakeup(int index)
{
    if (true) {
        _nocheck__trace_usb_ohci_port_wakeup(index);
    }
}

#define TRACE_USB_OHCI_PORT_SUSPEND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_PORT_SUSPEND) || \
    false)

static inline void _nocheck__trace_usb_ohci_port_suspend(int index)
{
    if (trace_event_get_state(TRACE_USB_OHCI_PORT_SUSPEND) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_port_suspend " "port #%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , index);
    }
}

static inline void trace_usb_ohci_port_suspend(int index)
{
    if (true) {
        _nocheck__trace_usb_ohci_port_suspend(index);
    }
}

#define TRACE_USB_OHCI_PORT_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_PORT_RESET) || \
    false)

static inline void _nocheck__trace_usb_ohci_port_reset(int index)
{
    if (trace_event_get_state(TRACE_USB_OHCI_PORT_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_port_reset " "port #%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , index);
    }
}

static inline void trace_usb_ohci_port_reset(int index)
{
    if (true) {
        _nocheck__trace_usb_ohci_port_reset(index);
    }
}

#define TRACE_USB_OHCI_REMOTE_WAKEUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_REMOTE_WAKEUP) || \
    false)

static inline void _nocheck__trace_usb_ohci_remote_wakeup(const char * s)
{
    if (trace_event_get_state(TRACE_USB_OHCI_REMOTE_WAKEUP) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_remote_wakeup " "%s: SUSPEND->RESUME" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s);
    }
}

static inline void trace_usb_ohci_remote_wakeup(const char * s)
{
    if (true) {
        _nocheck__trace_usb_ohci_remote_wakeup(s);
    }
}

#define TRACE_USB_OHCI_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_RESET) || \
    false)

static inline void _nocheck__trace_usb_ohci_reset(const char * s)
{
    if (trace_event_get_state(TRACE_USB_OHCI_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_reset " "%s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s);
    }
}

static inline void trace_usb_ohci_reset(const char * s)
{
    if (true) {
        _nocheck__trace_usb_ohci_reset(s);
    }
}

#define TRACE_USB_OHCI_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_START) || \
    false)

static inline void _nocheck__trace_usb_ohci_start(const char * s)
{
    if (trace_event_get_state(TRACE_USB_OHCI_START) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_start " "%s: USB Operational" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s);
    }
}

static inline void trace_usb_ohci_start(const char * s)
{
    if (true) {
        _nocheck__trace_usb_ohci_start(s);
    }
}

#define TRACE_USB_OHCI_RESUME_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_RESUME) || \
    false)

static inline void _nocheck__trace_usb_ohci_resume(const char * s)
{
    if (trace_event_get_state(TRACE_USB_OHCI_RESUME) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_resume " "%s: USB Resume" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s);
    }
}

static inline void trace_usb_ohci_resume(const char * s)
{
    if (true) {
        _nocheck__trace_usb_ohci_resume(s);
    }
}

#define TRACE_USB_OHCI_STOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_STOP) || \
    false)

static inline void _nocheck__trace_usb_ohci_stop(const char * s)
{
    if (trace_event_get_state(TRACE_USB_OHCI_STOP) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_stop " "%s: USB Suspended" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s);
    }
}

static inline void trace_usb_ohci_stop(const char * s)
{
    if (true) {
        _nocheck__trace_usb_ohci_stop(s);
    }
}

#define TRACE_USB_OHCI_SET_CTL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_SET_CTL) || \
    false)

static inline void _nocheck__trace_usb_ohci_set_ctl(const char * s, uint32_t new_state)
{
    if (trace_event_get_state(TRACE_USB_OHCI_SET_CTL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_set_ctl " "%s: new state 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, new_state);
    }
}

static inline void trace_usb_ohci_set_ctl(const char * s, uint32_t new_state)
{
    if (true) {
        _nocheck__trace_usb_ohci_set_ctl(s, new_state);
    }
}

#define TRACE_USB_OHCI_TD_UNDERRUN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_TD_UNDERRUN) || \
    false)

static inline void _nocheck__trace_usb_ohci_td_underrun(void)
{
    if (trace_event_get_state(TRACE_USB_OHCI_TD_UNDERRUN) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_td_underrun " "" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_ohci_td_underrun(void)
{
    if (true) {
        _nocheck__trace_usb_ohci_td_underrun();
    }
}

#define TRACE_USB_OHCI_TD_DEV_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_TD_DEV_ERROR) || \
    false)

static inline void _nocheck__trace_usb_ohci_td_dev_error(void)
{
    if (trace_event_get_state(TRACE_USB_OHCI_TD_DEV_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_td_dev_error " "" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_ohci_td_dev_error(void)
{
    if (true) {
        _nocheck__trace_usb_ohci_td_dev_error();
    }
}

#define TRACE_USB_OHCI_TD_NAK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_TD_NAK) || \
    false)

static inline void _nocheck__trace_usb_ohci_td_nak(void)
{
    if (trace_event_get_state(TRACE_USB_OHCI_TD_NAK) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_td_nak " "" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_ohci_td_nak(void)
{
    if (true) {
        _nocheck__trace_usb_ohci_td_nak();
    }
}

#define TRACE_USB_OHCI_TD_STALL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_TD_STALL) || \
    false)

static inline void _nocheck__trace_usb_ohci_td_stall(void)
{
    if (trace_event_get_state(TRACE_USB_OHCI_TD_STALL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_td_stall " "" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_ohci_td_stall(void)
{
    if (true) {
        _nocheck__trace_usb_ohci_td_stall();
    }
}

#define TRACE_USB_OHCI_TD_BABBLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_TD_BABBLE) || \
    false)

static inline void _nocheck__trace_usb_ohci_td_babble(void)
{
    if (trace_event_get_state(TRACE_USB_OHCI_TD_BABBLE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_td_babble " "" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_ohci_td_babble(void)
{
    if (true) {
        _nocheck__trace_usb_ohci_td_babble();
    }
}

#define TRACE_USB_OHCI_TD_BAD_DEVICE_RESPONSE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_TD_BAD_DEVICE_RESPONSE) || \
    false)

static inline void _nocheck__trace_usb_ohci_td_bad_device_response(int rc)
{
    if (trace_event_get_state(TRACE_USB_OHCI_TD_BAD_DEVICE_RESPONSE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_td_bad_device_response " "%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , rc);
    }
}

static inline void trace_usb_ohci_td_bad_device_response(int rc)
{
    if (true) {
        _nocheck__trace_usb_ohci_td_bad_device_response(rc);
    }
}

#define TRACE_USB_OHCI_TD_READ_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_TD_READ_ERROR) || \
    false)

static inline void _nocheck__trace_usb_ohci_td_read_error(uint32_t addr)
{
    if (trace_event_get_state(TRACE_USB_OHCI_TD_READ_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_td_read_error " "TD read error at 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr);
    }
}

static inline void trace_usb_ohci_td_read_error(uint32_t addr)
{
    if (true) {
        _nocheck__trace_usb_ohci_td_read_error(addr);
    }
}

#define TRACE_USB_OHCI_TD_BAD_DIRECTION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_TD_BAD_DIRECTION) || \
    false)

static inline void _nocheck__trace_usb_ohci_td_bad_direction(int dir)
{
    if (trace_event_get_state(TRACE_USB_OHCI_TD_BAD_DIRECTION) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_td_bad_direction " "Bad direction %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , dir);
    }
}

static inline void trace_usb_ohci_td_bad_direction(int dir)
{
    if (true) {
        _nocheck__trace_usb_ohci_td_bad_direction(dir);
    }
}

#define TRACE_USB_OHCI_TD_SKIP_ASYNC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_TD_SKIP_ASYNC) || \
    false)

static inline void _nocheck__trace_usb_ohci_td_skip_async(void)
{
    if (trace_event_get_state(TRACE_USB_OHCI_TD_SKIP_ASYNC) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_td_skip_async " "" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_ohci_td_skip_async(void)
{
    if (true) {
        _nocheck__trace_usb_ohci_td_skip_async();
    }
}

#define TRACE_USB_OHCI_TD_PKT_HDR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_TD_PKT_HDR) || \
    false)

static inline void _nocheck__trace_usb_ohci_td_pkt_hdr(uint32_t addr, int64_t pktlen, int64_t len, const char * s, int flag_r, uint32_t cbp, uint32_t be)
{
    if (trace_event_get_state(TRACE_USB_OHCI_TD_PKT_HDR) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_td_pkt_hdr " " TD @ 0x%.8x %" PRId64 " of %" PRId64 " bytes %s r=%d cbp=0x%.8x be=0x%.8x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, pktlen, len, s, flag_r, cbp, be);
    }
}

static inline void trace_usb_ohci_td_pkt_hdr(uint32_t addr, int64_t pktlen, int64_t len, const char * s, int flag_r, uint32_t cbp, uint32_t be)
{
    if (true) {
        _nocheck__trace_usb_ohci_td_pkt_hdr(addr, pktlen, len, s, flag_r, cbp, be);
    }
}

#define TRACE_USB_OHCI_TD_PKT_SHORT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_TD_PKT_SHORT) || \
    false)

static inline void _nocheck__trace_usb_ohci_td_pkt_short(const char * dir, const char * buf)
{
    if (trace_event_get_state(TRACE_USB_OHCI_TD_PKT_SHORT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_td_pkt_short " "%s data: %s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , dir, buf);
    }
}

static inline void trace_usb_ohci_td_pkt_short(const char * dir, const char * buf)
{
    if (true) {
        _nocheck__trace_usb_ohci_td_pkt_short(dir, buf);
    }
}

#define TRACE_USB_OHCI_TD_PKT_FULL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_TD_PKT_FULL) || \
    false)

static inline void _nocheck__trace_usb_ohci_td_pkt_full(const char * dir, const char * buf)
{
    if (trace_event_get_state(TRACE_USB_OHCI_TD_PKT_FULL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_td_pkt_full " "%s data: %s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , dir, buf);
    }
}

static inline void trace_usb_ohci_td_pkt_full(const char * dir, const char * buf)
{
    if (true) {
        _nocheck__trace_usb_ohci_td_pkt_full(dir, buf);
    }
}

#define TRACE_USB_OHCI_TD_TOO_MANY_PENDING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_TD_TOO_MANY_PENDING) || \
    false)

static inline void _nocheck__trace_usb_ohci_td_too_many_pending(void)
{
    if (trace_event_get_state(TRACE_USB_OHCI_TD_TOO_MANY_PENDING) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_td_too_many_pending " "" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_ohci_td_too_many_pending(void)
{
    if (true) {
        _nocheck__trace_usb_ohci_td_too_many_pending();
    }
}

#define TRACE_USB_OHCI_TD_PACKET_STATUS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_TD_PACKET_STATUS) || \
    false)

static inline void _nocheck__trace_usb_ohci_td_packet_status(int status)
{
    if (trace_event_get_state(TRACE_USB_OHCI_TD_PACKET_STATUS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_td_packet_status " "status=%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , status);
    }
}

static inline void trace_usb_ohci_td_packet_status(int status)
{
    if (true) {
        _nocheck__trace_usb_ohci_td_packet_status(status);
    }
}

#define TRACE_USB_OHCI_ED_READ_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_ED_READ_ERROR) || \
    false)

static inline void _nocheck__trace_usb_ohci_ed_read_error(uint32_t addr)
{
    if (trace_event_get_state(TRACE_USB_OHCI_ED_READ_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_ed_read_error " "ED read error at 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr);
    }
}

static inline void trace_usb_ohci_ed_read_error(uint32_t addr)
{
    if (true) {
        _nocheck__trace_usb_ohci_ed_read_error(addr);
    }
}

#define TRACE_USB_OHCI_ED_PKT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_ED_PKT) || \
    false)

static inline void _nocheck__trace_usb_ohci_ed_pkt(uint32_t cur, int h, int c, uint32_t head, uint32_t tail, uint32_t next)
{
    if (trace_event_get_state(TRACE_USB_OHCI_ED_PKT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_ed_pkt " "ED @ 0x%.8x h=%u c=%u\n  head=0x%.8x tailp=0x%.8x next=0x%.8x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , cur, h, c, head, tail, next);
    }
}

static inline void trace_usb_ohci_ed_pkt(uint32_t cur, int h, int c, uint32_t head, uint32_t tail, uint32_t next)
{
    if (true) {
        _nocheck__trace_usb_ohci_ed_pkt(cur, h, c, head, tail, next);
    }
}

#define TRACE_USB_OHCI_ED_PKT_FLAGS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_ED_PKT_FLAGS) || \
    false)

static inline void _nocheck__trace_usb_ohci_ed_pkt_flags(uint32_t fa, uint32_t en, uint32_t d, int s, int k, int f, uint32_t mps)
{
    if (trace_event_get_state(TRACE_USB_OHCI_ED_PKT_FLAGS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_ed_pkt_flags " "fa=%u en=%u d=%u s=%u k=%u f=%u mps=%u" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , fa, en, d, s, k, f, mps);
    }
}

static inline void trace_usb_ohci_ed_pkt_flags(uint32_t fa, uint32_t en, uint32_t d, int s, int k, int f, uint32_t mps)
{
    if (true) {
        _nocheck__trace_usb_ohci_ed_pkt_flags(fa, en, d, s, k, f, mps);
    }
}

#define TRACE_USB_OHCI_HCCA_READ_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_HCCA_READ_ERROR) || \
    false)

static inline void _nocheck__trace_usb_ohci_hcca_read_error(uint32_t addr)
{
    if (trace_event_get_state(TRACE_USB_OHCI_HCCA_READ_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_hcca_read_error " "HCCA read error at 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr);
    }
}

static inline void trace_usb_ohci_hcca_read_error(uint32_t addr)
{
    if (true) {
        _nocheck__trace_usb_ohci_hcca_read_error(addr);
    }
}

#define TRACE_USB_OHCI_MEM_READ_UNALIGNED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_MEM_READ_UNALIGNED) || \
    false)

static inline void _nocheck__trace_usb_ohci_mem_read_unaligned(uint32_t addr)
{
    if (trace_event_get_state(TRACE_USB_OHCI_MEM_READ_UNALIGNED) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_mem_read_unaligned " "at 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr);
    }
}

static inline void trace_usb_ohci_mem_read_unaligned(uint32_t addr)
{
    if (true) {
        _nocheck__trace_usb_ohci_mem_read_unaligned(addr);
    }
}

#define TRACE_USB_OHCI_MEM_READ_BAD_OFFSET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_MEM_READ_BAD_OFFSET) || \
    false)

static inline void _nocheck__trace_usb_ohci_mem_read_bad_offset(uint32_t addr)
{
    if (trace_event_get_state(TRACE_USB_OHCI_MEM_READ_BAD_OFFSET) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_mem_read_bad_offset " "0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr);
    }
}

static inline void trace_usb_ohci_mem_read_bad_offset(uint32_t addr)
{
    if (true) {
        _nocheck__trace_usb_ohci_mem_read_bad_offset(addr);
    }
}

#define TRACE_USB_OHCI_MEM_WRITE_UNALIGNED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_MEM_WRITE_UNALIGNED) || \
    false)

static inline void _nocheck__trace_usb_ohci_mem_write_unaligned(uint32_t addr)
{
    if (trace_event_get_state(TRACE_USB_OHCI_MEM_WRITE_UNALIGNED) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_mem_write_unaligned " "at 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr);
    }
}

static inline void trace_usb_ohci_mem_write_unaligned(uint32_t addr)
{
    if (true) {
        _nocheck__trace_usb_ohci_mem_write_unaligned(addr);
    }
}

#define TRACE_USB_OHCI_MEM_WRITE_BAD_OFFSET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_MEM_WRITE_BAD_OFFSET) || \
    false)

static inline void _nocheck__trace_usb_ohci_mem_write_bad_offset(uint32_t addr)
{
    if (trace_event_get_state(TRACE_USB_OHCI_MEM_WRITE_BAD_OFFSET) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_mem_write_bad_offset " "0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr);
    }
}

static inline void trace_usb_ohci_mem_write_bad_offset(uint32_t addr)
{
    if (true) {
        _nocheck__trace_usb_ohci_mem_write_bad_offset(addr);
    }
}

#define TRACE_USB_OHCI_PROCESS_LISTS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_PROCESS_LISTS) || \
    false)

static inline void _nocheck__trace_usb_ohci_process_lists(uint32_t head, uint32_t cur)
{
    if (trace_event_get_state(TRACE_USB_OHCI_PROCESS_LISTS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_process_lists " "head 0x%x, cur 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , head, cur);
    }
}

static inline void trace_usb_ohci_process_lists(uint32_t head, uint32_t cur)
{
    if (true) {
        _nocheck__trace_usb_ohci_process_lists(head, cur);
    }
}

#define TRACE_USB_OHCI_SET_FRAME_INTERVAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_SET_FRAME_INTERVAL) || \
    false)

static inline void _nocheck__trace_usb_ohci_set_frame_interval(const char * name, uint16_t fi_x, uint16_t fi_u)
{
    if (trace_event_get_state(TRACE_USB_OHCI_SET_FRAME_INTERVAL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_set_frame_interval " "%s: FrameInterval = 0x%x (%u)" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , name, fi_x, fi_u);
    }
}

static inline void trace_usb_ohci_set_frame_interval(const char * name, uint16_t fi_x, uint16_t fi_u)
{
    if (true) {
        _nocheck__trace_usb_ohci_set_frame_interval(name, fi_x, fi_u);
    }
}

#define TRACE_USB_OHCI_HUB_POWER_UP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_HUB_POWER_UP) || \
    false)

static inline void _nocheck__trace_usb_ohci_hub_power_up(void)
{
    if (trace_event_get_state(TRACE_USB_OHCI_HUB_POWER_UP) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_hub_power_up " "powered up all ports" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_ohci_hub_power_up(void)
{
    if (true) {
        _nocheck__trace_usb_ohci_hub_power_up();
    }
}

#define TRACE_USB_OHCI_HUB_POWER_DOWN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_HUB_POWER_DOWN) || \
    false)

static inline void _nocheck__trace_usb_ohci_hub_power_down(void)
{
    if (trace_event_get_state(TRACE_USB_OHCI_HUB_POWER_DOWN) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_hub_power_down " "powered down all ports" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_ohci_hub_power_down(void)
{
    if (true) {
        _nocheck__trace_usb_ohci_hub_power_down();
    }
}

#define TRACE_USB_OHCI_INIT_TIME_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_INIT_TIME) || \
    false)

static inline void _nocheck__trace_usb_ohci_init_time(int64_t frametime, int64_t bittime)
{
    if (trace_event_get_state(TRACE_USB_OHCI_INIT_TIME) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_init_time " "usb_bit_time=%" PRId64 " usb_frame_time=%" PRId64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , frametime, bittime);
    }
}

static inline void trace_usb_ohci_init_time(int64_t frametime, int64_t bittime)
{
    if (true) {
        _nocheck__trace_usb_ohci_init_time(frametime, bittime);
    }
}

#define TRACE_USB_OHCI_DIE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_DIE) || \
    false)

static inline void _nocheck__trace_usb_ohci_die(void)
{
    if (trace_event_get_state(TRACE_USB_OHCI_DIE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_die " "" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_ohci_die(void)
{
    if (true) {
        _nocheck__trace_usb_ohci_die();
    }
}

#define TRACE_USB_OHCI_ASYNC_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_OHCI_ASYNC_COMPLETE) || \
    false)

static inline void _nocheck__trace_usb_ohci_async_complete(void)
{
    if (trace_event_get_state(TRACE_USB_OHCI_ASYNC_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ohci_async_complete " "" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_ohci_async_complete(void)
{
    if (true) {
        _nocheck__trace_usb_ohci_async_complete();
    }
}

#define TRACE_USB_EHCI_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_EHCI_RESET) || \
    false)

static inline void _nocheck__trace_usb_ehci_reset(void)
{
    if (trace_event_get_state(TRACE_USB_EHCI_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ehci_reset " "=== RESET ===" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_ehci_reset(void)
{
    if (true) {
        _nocheck__trace_usb_ehci_reset();
    }
}

#define TRACE_USB_EHCI_UNREALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_EHCI_UNREALIZE) || \
    false)

static inline void _nocheck__trace_usb_ehci_unrealize(void)
{
    if (trace_event_get_state(TRACE_USB_EHCI_UNREALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ehci_unrealize " "=== UNREALIZE ===" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_ehci_unrealize(void)
{
    if (true) {
        _nocheck__trace_usb_ehci_unrealize();
    }
}

#define TRACE_USB_EHCI_OPREG_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_EHCI_OPREG_READ) || \
    false)

static inline void _nocheck__trace_usb_ehci_opreg_read(uint32_t addr, const char * str, uint32_t val)
{
    if (trace_event_get_state(TRACE_USB_EHCI_OPREG_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ehci_opreg_read " "rd mmio 0x%04x [%s] = 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, str, val);
    }
}

static inline void trace_usb_ehci_opreg_read(uint32_t addr, const char * str, uint32_t val)
{
    if (true) {
        _nocheck__trace_usb_ehci_opreg_read(addr, str, val);
    }
}

#define TRACE_USB_EHCI_OPREG_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_EHCI_OPREG_WRITE) || \
    false)

static inline void _nocheck__trace_usb_ehci_opreg_write(uint32_t addr, const char * str, uint32_t val)
{
    if (trace_event_get_state(TRACE_USB_EHCI_OPREG_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ehci_opreg_write " "wr mmio 0x%04x [%s] = 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, str, val);
    }
}

static inline void trace_usb_ehci_opreg_write(uint32_t addr, const char * str, uint32_t val)
{
    if (true) {
        _nocheck__trace_usb_ehci_opreg_write(addr, str, val);
    }
}

#define TRACE_USB_EHCI_OPREG_CHANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_EHCI_OPREG_CHANGE) || \
    false)

static inline void _nocheck__trace_usb_ehci_opreg_change(uint32_t addr, const char * str, uint32_t new, uint32_t old)
{
    if (trace_event_get_state(TRACE_USB_EHCI_OPREG_CHANGE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ehci_opreg_change " "ch mmio 0x%04x [%s] = 0x%x (old: 0x%x)" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, str, new, old);
    }
}

static inline void trace_usb_ehci_opreg_change(uint32_t addr, const char * str, uint32_t new, uint32_t old)
{
    if (true) {
        _nocheck__trace_usb_ehci_opreg_change(addr, str, new, old);
    }
}

#define TRACE_USB_EHCI_PORTSC_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_EHCI_PORTSC_READ) || \
    false)

static inline void _nocheck__trace_usb_ehci_portsc_read(uint32_t addr, uint32_t port, uint32_t val)
{
    if (trace_event_get_state(TRACE_USB_EHCI_PORTSC_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ehci_portsc_read " "rd mmio 0x%04x [port %d] = 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, port, val);
    }
}

static inline void trace_usb_ehci_portsc_read(uint32_t addr, uint32_t port, uint32_t val)
{
    if (true) {
        _nocheck__trace_usb_ehci_portsc_read(addr, port, val);
    }
}

#define TRACE_USB_EHCI_PORTSC_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_EHCI_PORTSC_WRITE) || \
    false)

static inline void _nocheck__trace_usb_ehci_portsc_write(uint32_t addr, uint32_t port, uint32_t val)
{
    if (trace_event_get_state(TRACE_USB_EHCI_PORTSC_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ehci_portsc_write " "wr mmio 0x%04x [port %d] = 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, port, val);
    }
}

static inline void trace_usb_ehci_portsc_write(uint32_t addr, uint32_t port, uint32_t val)
{
    if (true) {
        _nocheck__trace_usb_ehci_portsc_write(addr, port, val);
    }
}

#define TRACE_USB_EHCI_PORTSC_CHANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_EHCI_PORTSC_CHANGE) || \
    false)

static inline void _nocheck__trace_usb_ehci_portsc_change(uint32_t addr, uint32_t port, uint32_t new, uint32_t old)
{
    if (trace_event_get_state(TRACE_USB_EHCI_PORTSC_CHANGE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ehci_portsc_change " "ch mmio 0x%04x [port %d] = 0x%x (old: 0x%x)" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, port, new, old);
    }
}

static inline void trace_usb_ehci_portsc_change(uint32_t addr, uint32_t port, uint32_t new, uint32_t old)
{
    if (true) {
        _nocheck__trace_usb_ehci_portsc_change(addr, port, new, old);
    }
}

#define TRACE_USB_EHCI_USBSTS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_EHCI_USBSTS) || \
    false)

static inline void _nocheck__trace_usb_ehci_usbsts(const char * sts, int state)
{
    if (trace_event_get_state(TRACE_USB_EHCI_USBSTS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ehci_usbsts " "usbsts %s %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , sts, state);
    }
}

static inline void trace_usb_ehci_usbsts(const char * sts, int state)
{
    if (true) {
        _nocheck__trace_usb_ehci_usbsts(sts, state);
    }
}

#define TRACE_USB_EHCI_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_EHCI_STATE) || \
    false)

static inline void _nocheck__trace_usb_ehci_state(const char * schedule, const char * state)
{
    if (trace_event_get_state(TRACE_USB_EHCI_STATE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ehci_state " "%s schedule %s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , schedule, state);
    }
}

static inline void trace_usb_ehci_state(const char * schedule, const char * state)
{
    if (true) {
        _nocheck__trace_usb_ehci_state(schedule, state);
    }
}

#define TRACE_USB_EHCI_QH_PTRS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_EHCI_QH_PTRS) || \
    false)

static inline void _nocheck__trace_usb_ehci_qh_ptrs(void * q, uint32_t addr, uint32_t nxt, uint32_t c_qtd, uint32_t n_qtd, uint32_t a_qtd)
{
    if (trace_event_get_state(TRACE_USB_EHCI_QH_PTRS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ehci_qh_ptrs " "q %p - QH @ 0x%08x: next 0x%08x qtds 0x%08x,0x%08x,0x%08x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , q, addr, nxt, c_qtd, n_qtd, a_qtd);
    }
}

static inline void trace_usb_ehci_qh_ptrs(void * q, uint32_t addr, uint32_t nxt, uint32_t c_qtd, uint32_t n_qtd, uint32_t a_qtd)
{
    if (true) {
        _nocheck__trace_usb_ehci_qh_ptrs(q, addr, nxt, c_qtd, n_qtd, a_qtd);
    }
}

#define TRACE_USB_EHCI_QH_FIELDS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_EHCI_QH_FIELDS) || \
    false)

static inline void _nocheck__trace_usb_ehci_qh_fields(uint32_t addr, int rl, int mplen, int eps, int ep, int devaddr)
{
    if (trace_event_get_state(TRACE_USB_EHCI_QH_FIELDS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ehci_qh_fields " "QH @ 0x%08x - rl %d, mplen %d, eps %d, ep %d, dev %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, rl, mplen, eps, ep, devaddr);
    }
}

static inline void trace_usb_ehci_qh_fields(uint32_t addr, int rl, int mplen, int eps, int ep, int devaddr)
{
    if (true) {
        _nocheck__trace_usb_ehci_qh_fields(addr, rl, mplen, eps, ep, devaddr);
    }
}

#define TRACE_USB_EHCI_QH_BITS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_EHCI_QH_BITS) || \
    false)

static inline void _nocheck__trace_usb_ehci_qh_bits(uint32_t addr, int c, int h, int dtc, int i)
{
    if (trace_event_get_state(TRACE_USB_EHCI_QH_BITS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ehci_qh_bits " "QH @ 0x%08x - c %d, h %d, dtc %d, i %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, c, h, dtc, i);
    }
}

static inline void trace_usb_ehci_qh_bits(uint32_t addr, int c, int h, int dtc, int i)
{
    if (true) {
        _nocheck__trace_usb_ehci_qh_bits(addr, c, h, dtc, i);
    }
}

#define TRACE_USB_EHCI_QTD_PTRS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_EHCI_QTD_PTRS) || \
    false)

static inline void _nocheck__trace_usb_ehci_qtd_ptrs(void * q, uint32_t addr, uint32_t nxt, uint32_t altnext)
{
    if (trace_event_get_state(TRACE_USB_EHCI_QTD_PTRS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ehci_qtd_ptrs " "q %p - QTD @ 0x%08x: next 0x%08x altnext 0x%08x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , q, addr, nxt, altnext);
    }
}

static inline void trace_usb_ehci_qtd_ptrs(void * q, uint32_t addr, uint32_t nxt, uint32_t altnext)
{
    if (true) {
        _nocheck__trace_usb_ehci_qtd_ptrs(q, addr, nxt, altnext);
    }
}

#define TRACE_USB_EHCI_QTD_FIELDS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_EHCI_QTD_FIELDS) || \
    false)

static inline void _nocheck__trace_usb_ehci_qtd_fields(uint32_t addr, int tbytes, int cpage, int cerr, int pid)
{
    if (trace_event_get_state(TRACE_USB_EHCI_QTD_FIELDS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ehci_qtd_fields " "QTD @ 0x%08x - tbytes %d, cpage %d, cerr %d, pid %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, tbytes, cpage, cerr, pid);
    }
}

static inline void trace_usb_ehci_qtd_fields(uint32_t addr, int tbytes, int cpage, int cerr, int pid)
{
    if (true) {
        _nocheck__trace_usb_ehci_qtd_fields(addr, tbytes, cpage, cerr, pid);
    }
}

#define TRACE_USB_EHCI_QTD_BITS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_EHCI_QTD_BITS) || \
    false)

static inline void _nocheck__trace_usb_ehci_qtd_bits(uint32_t addr, int ioc, int active, int halt, int babble, int xacterr)
{
    if (trace_event_get_state(TRACE_USB_EHCI_QTD_BITS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ehci_qtd_bits " "QTD @ 0x%08x - ioc %d, active %d, halt %d, babble %d, xacterr %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, ioc, active, halt, babble, xacterr);
    }
}

static inline void trace_usb_ehci_qtd_bits(uint32_t addr, int ioc, int active, int halt, int babble, int xacterr)
{
    if (true) {
        _nocheck__trace_usb_ehci_qtd_bits(addr, ioc, active, halt, babble, xacterr);
    }
}

#define TRACE_USB_EHCI_ITD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_EHCI_ITD) || \
    false)

static inline void _nocheck__trace_usb_ehci_itd(uint32_t addr, uint32_t nxt, uint32_t mplen, uint32_t mult, uint32_t ep, uint32_t devaddr)
{
    if (trace_event_get_state(TRACE_USB_EHCI_ITD) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ehci_itd " "ITD @ 0x%08x: next 0x%08x - mplen %d, mult %d, ep %d, dev %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, nxt, mplen, mult, ep, devaddr);
    }
}

static inline void trace_usb_ehci_itd(uint32_t addr, uint32_t nxt, uint32_t mplen, uint32_t mult, uint32_t ep, uint32_t devaddr)
{
    if (true) {
        _nocheck__trace_usb_ehci_itd(addr, nxt, mplen, mult, ep, devaddr);
    }
}

#define TRACE_USB_EHCI_SITD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_EHCI_SITD) || \
    false)

static inline void _nocheck__trace_usb_ehci_sitd(uint32_t addr, uint32_t nxt, uint32_t active)
{
    if (trace_event_get_state(TRACE_USB_EHCI_SITD) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ehci_sitd " "ITD @ 0x%08x: next 0x%08x - active %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, nxt, active);
    }
}

static inline void trace_usb_ehci_sitd(uint32_t addr, uint32_t nxt, uint32_t active)
{
    if (true) {
        _nocheck__trace_usb_ehci_sitd(addr, nxt, active);
    }
}

#define TRACE_USB_EHCI_PORT_ATTACH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_EHCI_PORT_ATTACH) || \
    false)

static inline void _nocheck__trace_usb_ehci_port_attach(uint32_t port, const char * owner, const char * device)
{
    if (trace_event_get_state(TRACE_USB_EHCI_PORT_ATTACH) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ehci_port_attach " "attach port #%d, owner %s, device %s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , port, owner, device);
    }
}

static inline void trace_usb_ehci_port_attach(uint32_t port, const char * owner, const char * device)
{
    if (true) {
        _nocheck__trace_usb_ehci_port_attach(port, owner, device);
    }
}

#define TRACE_USB_EHCI_PORT_DETACH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_EHCI_PORT_DETACH) || \
    false)

static inline void _nocheck__trace_usb_ehci_port_detach(uint32_t port, const char * owner)
{
    if (trace_event_get_state(TRACE_USB_EHCI_PORT_DETACH) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ehci_port_detach " "detach port #%d, owner %s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , port, owner);
    }
}

static inline void trace_usb_ehci_port_detach(uint32_t port, const char * owner)
{
    if (true) {
        _nocheck__trace_usb_ehci_port_detach(port, owner);
    }
}

#define TRACE_USB_EHCI_PORT_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_EHCI_PORT_RESET) || \
    false)

static inline void _nocheck__trace_usb_ehci_port_reset(uint32_t port, int enable)
{
    if (trace_event_get_state(TRACE_USB_EHCI_PORT_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ehci_port_reset " "reset port #%d - %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , port, enable);
    }
}

static inline void trace_usb_ehci_port_reset(uint32_t port, int enable)
{
    if (true) {
        _nocheck__trace_usb_ehci_port_reset(port, enable);
    }
}

#define TRACE_USB_EHCI_PORT_SUSPEND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_EHCI_PORT_SUSPEND) || \
    false)

static inline void _nocheck__trace_usb_ehci_port_suspend(uint32_t port)
{
    if (trace_event_get_state(TRACE_USB_EHCI_PORT_SUSPEND) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ehci_port_suspend " "port #%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , port);
    }
}

static inline void trace_usb_ehci_port_suspend(uint32_t port)
{
    if (true) {
        _nocheck__trace_usb_ehci_port_suspend(port);
    }
}

#define TRACE_USB_EHCI_PORT_WAKEUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_EHCI_PORT_WAKEUP) || \
    false)

static inline void _nocheck__trace_usb_ehci_port_wakeup(uint32_t port)
{
    if (trace_event_get_state(TRACE_USB_EHCI_PORT_WAKEUP) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ehci_port_wakeup " "port #%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , port);
    }
}

static inline void trace_usb_ehci_port_wakeup(uint32_t port)
{
    if (true) {
        _nocheck__trace_usb_ehci_port_wakeup(port);
    }
}

#define TRACE_USB_EHCI_PORT_RESUME_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_EHCI_PORT_RESUME) || \
    false)

static inline void _nocheck__trace_usb_ehci_port_resume(uint32_t port)
{
    if (trace_event_get_state(TRACE_USB_EHCI_PORT_RESUME) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ehci_port_resume " "port #%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , port);
    }
}

static inline void trace_usb_ehci_port_resume(uint32_t port)
{
    if (true) {
        _nocheck__trace_usb_ehci_port_resume(port);
    }
}

#define TRACE_USB_EHCI_QUEUE_ACTION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_EHCI_QUEUE_ACTION) || \
    false)

static inline void _nocheck__trace_usb_ehci_queue_action(void * q, const char * action)
{
    if (trace_event_get_state(TRACE_USB_EHCI_QUEUE_ACTION) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ehci_queue_action " "q %p: %s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , q, action);
    }
}

static inline void trace_usb_ehci_queue_action(void * q, const char * action)
{
    if (true) {
        _nocheck__trace_usb_ehci_queue_action(q, action);
    }
}

#define TRACE_USB_EHCI_PACKET_ACTION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_EHCI_PACKET_ACTION) || \
    false)

static inline void _nocheck__trace_usb_ehci_packet_action(void * q, void * p, const char * action)
{
    if (trace_event_get_state(TRACE_USB_EHCI_PACKET_ACTION) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ehci_packet_action " "q %p p %p: %s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , q, p, action);
    }
}

static inline void trace_usb_ehci_packet_action(void * q, void * p, const char * action)
{
    if (true) {
        _nocheck__trace_usb_ehci_packet_action(q, p, action);
    }
}

#define TRACE_USB_EHCI_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_EHCI_IRQ) || \
    false)

static inline void _nocheck__trace_usb_ehci_irq(uint32_t level, uint32_t frindex, uint32_t sts, uint32_t mask)
{
    if (trace_event_get_state(TRACE_USB_EHCI_IRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ehci_irq " "level %d, frindex 0x%04x, sts 0x%x, mask 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , level, frindex, sts, mask);
    }
}

static inline void trace_usb_ehci_irq(uint32_t level, uint32_t frindex, uint32_t sts, uint32_t mask)
{
    if (true) {
        _nocheck__trace_usb_ehci_irq(level, frindex, sts, mask);
    }
}

#define TRACE_USB_EHCI_GUEST_BUG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_EHCI_GUEST_BUG) || \
    false)

static inline void _nocheck__trace_usb_ehci_guest_bug(const char * reason)
{
    if (trace_event_get_state(TRACE_USB_EHCI_GUEST_BUG) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ehci_guest_bug " "%s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , reason);
    }
}

static inline void trace_usb_ehci_guest_bug(const char * reason)
{
    if (true) {
        _nocheck__trace_usb_ehci_guest_bug(reason);
    }
}

#define TRACE_USB_EHCI_DOORBELL_RING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_EHCI_DOORBELL_RING) || \
    false)

static inline void _nocheck__trace_usb_ehci_doorbell_ring(void)
{
    if (trace_event_get_state(TRACE_USB_EHCI_DOORBELL_RING) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ehci_doorbell_ring " "" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_ehci_doorbell_ring(void)
{
    if (true) {
        _nocheck__trace_usb_ehci_doorbell_ring();
    }
}

#define TRACE_USB_EHCI_DOORBELL_ACK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_EHCI_DOORBELL_ACK) || \
    false)

static inline void _nocheck__trace_usb_ehci_doorbell_ack(void)
{
    if (trace_event_get_state(TRACE_USB_EHCI_DOORBELL_ACK) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ehci_doorbell_ack " "" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_ehci_doorbell_ack(void)
{
    if (true) {
        _nocheck__trace_usb_ehci_doorbell_ack();
    }
}

#define TRACE_USB_EHCI_DMA_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_EHCI_DMA_ERROR) || \
    false)

static inline void _nocheck__trace_usb_ehci_dma_error(void)
{
    if (trace_event_get_state(TRACE_USB_EHCI_DMA_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_ehci_dma_error " "" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_ehci_dma_error(void)
{
    if (true) {
        _nocheck__trace_usb_ehci_dma_error();
    }
}

#define TRACE_USB_UHCI_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UHCI_RESET) || \
    false)

static inline void _nocheck__trace_usb_uhci_reset(void)
{
    if (trace_event_get_state(TRACE_USB_UHCI_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uhci_reset " "=== RESET ===" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_uhci_reset(void)
{
    if (true) {
        _nocheck__trace_usb_uhci_reset();
    }
}

#define TRACE_USB_UHCI_EXIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UHCI_EXIT) || \
    false)

static inline void _nocheck__trace_usb_uhci_exit(void)
{
    if (trace_event_get_state(TRACE_USB_UHCI_EXIT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uhci_exit " "=== EXIT ===" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_uhci_exit(void)
{
    if (true) {
        _nocheck__trace_usb_uhci_exit();
    }
}

#define TRACE_USB_UHCI_SCHEDULE_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UHCI_SCHEDULE_START) || \
    false)

static inline void _nocheck__trace_usb_uhci_schedule_start(void)
{
    if (trace_event_get_state(TRACE_USB_UHCI_SCHEDULE_START) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uhci_schedule_start " "" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_uhci_schedule_start(void)
{
    if (true) {
        _nocheck__trace_usb_uhci_schedule_start();
    }
}

#define TRACE_USB_UHCI_SCHEDULE_STOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UHCI_SCHEDULE_STOP) || \
    false)

static inline void _nocheck__trace_usb_uhci_schedule_stop(void)
{
    if (trace_event_get_state(TRACE_USB_UHCI_SCHEDULE_STOP) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uhci_schedule_stop " "" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_uhci_schedule_stop(void)
{
    if (true) {
        _nocheck__trace_usb_uhci_schedule_stop();
    }
}

#define TRACE_USB_UHCI_FRAME_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UHCI_FRAME_START) || \
    false)

static inline void _nocheck__trace_usb_uhci_frame_start(uint32_t num)
{
    if (trace_event_get_state(TRACE_USB_UHCI_FRAME_START) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uhci_frame_start " "nr %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , num);
    }
}

static inline void trace_usb_uhci_frame_start(uint32_t num)
{
    if (true) {
        _nocheck__trace_usb_uhci_frame_start(num);
    }
}

#define TRACE_USB_UHCI_FRAME_STOP_BANDWIDTH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UHCI_FRAME_STOP_BANDWIDTH) || \
    false)

static inline void _nocheck__trace_usb_uhci_frame_stop_bandwidth(void)
{
    if (trace_event_get_state(TRACE_USB_UHCI_FRAME_STOP_BANDWIDTH) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uhci_frame_stop_bandwidth " "" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_uhci_frame_stop_bandwidth(void)
{
    if (true) {
        _nocheck__trace_usb_uhci_frame_stop_bandwidth();
    }
}

#define TRACE_USB_UHCI_FRAME_LOOP_STOP_IDLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UHCI_FRAME_LOOP_STOP_IDLE) || \
    false)

static inline void _nocheck__trace_usb_uhci_frame_loop_stop_idle(void)
{
    if (trace_event_get_state(TRACE_USB_UHCI_FRAME_LOOP_STOP_IDLE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uhci_frame_loop_stop_idle " "" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_uhci_frame_loop_stop_idle(void)
{
    if (true) {
        _nocheck__trace_usb_uhci_frame_loop_stop_idle();
    }
}

#define TRACE_USB_UHCI_FRAME_LOOP_CONTINUE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UHCI_FRAME_LOOP_CONTINUE) || \
    false)

static inline void _nocheck__trace_usb_uhci_frame_loop_continue(void)
{
    if (trace_event_get_state(TRACE_USB_UHCI_FRAME_LOOP_CONTINUE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uhci_frame_loop_continue " "" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_uhci_frame_loop_continue(void)
{
    if (true) {
        _nocheck__trace_usb_uhci_frame_loop_continue();
    }
}

#define TRACE_USB_UHCI_MMIO_READW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UHCI_MMIO_READW) || \
    false)

static inline void _nocheck__trace_usb_uhci_mmio_readw(uint32_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_USB_UHCI_MMIO_READW) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uhci_mmio_readw " "addr 0x%04x, ret 0x%04x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, val);
    }
}

static inline void trace_usb_uhci_mmio_readw(uint32_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_usb_uhci_mmio_readw(addr, val);
    }
}

#define TRACE_USB_UHCI_MMIO_WRITEW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UHCI_MMIO_WRITEW) || \
    false)

static inline void _nocheck__trace_usb_uhci_mmio_writew(uint32_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_USB_UHCI_MMIO_WRITEW) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uhci_mmio_writew " "addr 0x%04x, val 0x%04x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, val);
    }
}

static inline void trace_usb_uhci_mmio_writew(uint32_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_usb_uhci_mmio_writew(addr, val);
    }
}

#define TRACE_USB_UHCI_QUEUE_ADD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UHCI_QUEUE_ADD) || \
    false)

static inline void _nocheck__trace_usb_uhci_queue_add(uint32_t token)
{
    if (trace_event_get_state(TRACE_USB_UHCI_QUEUE_ADD) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uhci_queue_add " "token 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , token);
    }
}

static inline void trace_usb_uhci_queue_add(uint32_t token)
{
    if (true) {
        _nocheck__trace_usb_uhci_queue_add(token);
    }
}

#define TRACE_USB_UHCI_QUEUE_DEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UHCI_QUEUE_DEL) || \
    false)

static inline void _nocheck__trace_usb_uhci_queue_del(uint32_t token, const char * reason)
{
    if (trace_event_get_state(TRACE_USB_UHCI_QUEUE_DEL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uhci_queue_del " "token 0x%x: %s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , token, reason);
    }
}

static inline void trace_usb_uhci_queue_del(uint32_t token, const char * reason)
{
    if (true) {
        _nocheck__trace_usb_uhci_queue_del(token, reason);
    }
}

#define TRACE_USB_UHCI_PACKET_ADD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UHCI_PACKET_ADD) || \
    false)

static inline void _nocheck__trace_usb_uhci_packet_add(uint32_t token, uint32_t addr)
{
    if (trace_event_get_state(TRACE_USB_UHCI_PACKET_ADD) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uhci_packet_add " "token 0x%x, td 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , token, addr);
    }
}

static inline void trace_usb_uhci_packet_add(uint32_t token, uint32_t addr)
{
    if (true) {
        _nocheck__trace_usb_uhci_packet_add(token, addr);
    }
}

#define TRACE_USB_UHCI_PACKET_LINK_ASYNC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UHCI_PACKET_LINK_ASYNC) || \
    false)

static inline void _nocheck__trace_usb_uhci_packet_link_async(uint32_t token, uint32_t addr)
{
    if (trace_event_get_state(TRACE_USB_UHCI_PACKET_LINK_ASYNC) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uhci_packet_link_async " "token 0x%x, td 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , token, addr);
    }
}

static inline void trace_usb_uhci_packet_link_async(uint32_t token, uint32_t addr)
{
    if (true) {
        _nocheck__trace_usb_uhci_packet_link_async(token, addr);
    }
}

#define TRACE_USB_UHCI_PACKET_UNLINK_ASYNC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UHCI_PACKET_UNLINK_ASYNC) || \
    false)

static inline void _nocheck__trace_usb_uhci_packet_unlink_async(uint32_t token, uint32_t addr)
{
    if (trace_event_get_state(TRACE_USB_UHCI_PACKET_UNLINK_ASYNC) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uhci_packet_unlink_async " "token 0x%x, td 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , token, addr);
    }
}

static inline void trace_usb_uhci_packet_unlink_async(uint32_t token, uint32_t addr)
{
    if (true) {
        _nocheck__trace_usb_uhci_packet_unlink_async(token, addr);
    }
}

#define TRACE_USB_UHCI_PACKET_CANCEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UHCI_PACKET_CANCEL) || \
    false)

static inline void _nocheck__trace_usb_uhci_packet_cancel(uint32_t token, uint32_t addr, int done)
{
    if (trace_event_get_state(TRACE_USB_UHCI_PACKET_CANCEL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uhci_packet_cancel " "token 0x%x, td 0x%x, done %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , token, addr, done);
    }
}

static inline void trace_usb_uhci_packet_cancel(uint32_t token, uint32_t addr, int done)
{
    if (true) {
        _nocheck__trace_usb_uhci_packet_cancel(token, addr, done);
    }
}

#define TRACE_USB_UHCI_PACKET_COMPLETE_SUCCESS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UHCI_PACKET_COMPLETE_SUCCESS) || \
    false)

static inline void _nocheck__trace_usb_uhci_packet_complete_success(uint32_t token, uint32_t addr)
{
    if (trace_event_get_state(TRACE_USB_UHCI_PACKET_COMPLETE_SUCCESS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uhci_packet_complete_success " "token 0x%x, td 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , token, addr);
    }
}

static inline void trace_usb_uhci_packet_complete_success(uint32_t token, uint32_t addr)
{
    if (true) {
        _nocheck__trace_usb_uhci_packet_complete_success(token, addr);
    }
}

#define TRACE_USB_UHCI_PACKET_COMPLETE_SHORTXFER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UHCI_PACKET_COMPLETE_SHORTXFER) || \
    false)

static inline void _nocheck__trace_usb_uhci_packet_complete_shortxfer(uint32_t token, uint32_t addr)
{
    if (trace_event_get_state(TRACE_USB_UHCI_PACKET_COMPLETE_SHORTXFER) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uhci_packet_complete_shortxfer " "token 0x%x, td 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , token, addr);
    }
}

static inline void trace_usb_uhci_packet_complete_shortxfer(uint32_t token, uint32_t addr)
{
    if (true) {
        _nocheck__trace_usb_uhci_packet_complete_shortxfer(token, addr);
    }
}

#define TRACE_USB_UHCI_PACKET_COMPLETE_STALL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UHCI_PACKET_COMPLETE_STALL) || \
    false)

static inline void _nocheck__trace_usb_uhci_packet_complete_stall(uint32_t token, uint32_t addr)
{
    if (trace_event_get_state(TRACE_USB_UHCI_PACKET_COMPLETE_STALL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uhci_packet_complete_stall " "token 0x%x, td 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , token, addr);
    }
}

static inline void trace_usb_uhci_packet_complete_stall(uint32_t token, uint32_t addr)
{
    if (true) {
        _nocheck__trace_usb_uhci_packet_complete_stall(token, addr);
    }
}

#define TRACE_USB_UHCI_PACKET_COMPLETE_BABBLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UHCI_PACKET_COMPLETE_BABBLE) || \
    false)

static inline void _nocheck__trace_usb_uhci_packet_complete_babble(uint32_t token, uint32_t addr)
{
    if (trace_event_get_state(TRACE_USB_UHCI_PACKET_COMPLETE_BABBLE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uhci_packet_complete_babble " "token 0x%x, td 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , token, addr);
    }
}

static inline void trace_usb_uhci_packet_complete_babble(uint32_t token, uint32_t addr)
{
    if (true) {
        _nocheck__trace_usb_uhci_packet_complete_babble(token, addr);
    }
}

#define TRACE_USB_UHCI_PACKET_COMPLETE_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UHCI_PACKET_COMPLETE_ERROR) || \
    false)

static inline void _nocheck__trace_usb_uhci_packet_complete_error(uint32_t token, uint32_t addr)
{
    if (trace_event_get_state(TRACE_USB_UHCI_PACKET_COMPLETE_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uhci_packet_complete_error " "token 0x%x, td 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , token, addr);
    }
}

static inline void trace_usb_uhci_packet_complete_error(uint32_t token, uint32_t addr)
{
    if (true) {
        _nocheck__trace_usb_uhci_packet_complete_error(token, addr);
    }
}

#define TRACE_USB_UHCI_PACKET_DEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UHCI_PACKET_DEL) || \
    false)

static inline void _nocheck__trace_usb_uhci_packet_del(uint32_t token, uint32_t addr)
{
    if (trace_event_get_state(TRACE_USB_UHCI_PACKET_DEL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uhci_packet_del " "token 0x%x, td 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , token, addr);
    }
}

static inline void trace_usb_uhci_packet_del(uint32_t token, uint32_t addr)
{
    if (true) {
        _nocheck__trace_usb_uhci_packet_del(token, addr);
    }
}

#define TRACE_USB_UHCI_QH_LOAD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UHCI_QH_LOAD) || \
    false)

static inline void _nocheck__trace_usb_uhci_qh_load(uint32_t qh)
{
    if (trace_event_get_state(TRACE_USB_UHCI_QH_LOAD) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uhci_qh_load " "qh 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , qh);
    }
}

static inline void trace_usb_uhci_qh_load(uint32_t qh)
{
    if (true) {
        _nocheck__trace_usb_uhci_qh_load(qh);
    }
}

#define TRACE_USB_UHCI_TD_LOAD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UHCI_TD_LOAD) || \
    false)

static inline void _nocheck__trace_usb_uhci_td_load(uint32_t qh, uint32_t td, uint32_t ctrl, uint32_t token)
{
    if (trace_event_get_state(TRACE_USB_UHCI_TD_LOAD) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uhci_td_load " "qh 0x%x, td 0x%x, ctrl 0x%x, token 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , qh, td, ctrl, token);
    }
}

static inline void trace_usb_uhci_td_load(uint32_t qh, uint32_t td, uint32_t ctrl, uint32_t token)
{
    if (true) {
        _nocheck__trace_usb_uhci_td_load(qh, td, ctrl, token);
    }
}

#define TRACE_USB_UHCI_TD_QUEUE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UHCI_TD_QUEUE) || \
    false)

static inline void _nocheck__trace_usb_uhci_td_queue(uint32_t td, uint32_t ctrl, uint32_t token)
{
    if (trace_event_get_state(TRACE_USB_UHCI_TD_QUEUE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uhci_td_queue " "td 0x%x, ctrl 0x%x, token 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , td, ctrl, token);
    }
}

static inline void trace_usb_uhci_td_queue(uint32_t td, uint32_t ctrl, uint32_t token)
{
    if (true) {
        _nocheck__trace_usb_uhci_td_queue(td, ctrl, token);
    }
}

#define TRACE_USB_UHCI_TD_NEXTQH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UHCI_TD_NEXTQH) || \
    false)

static inline void _nocheck__trace_usb_uhci_td_nextqh(uint32_t qh, uint32_t td)
{
    if (trace_event_get_state(TRACE_USB_UHCI_TD_NEXTQH) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uhci_td_nextqh " "qh 0x%x, td 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , qh, td);
    }
}

static inline void trace_usb_uhci_td_nextqh(uint32_t qh, uint32_t td)
{
    if (true) {
        _nocheck__trace_usb_uhci_td_nextqh(qh, td);
    }
}

#define TRACE_USB_UHCI_TD_ASYNC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UHCI_TD_ASYNC) || \
    false)

static inline void _nocheck__trace_usb_uhci_td_async(uint32_t qh, uint32_t td)
{
    if (trace_event_get_state(TRACE_USB_UHCI_TD_ASYNC) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uhci_td_async " "qh 0x%x, td 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , qh, td);
    }
}

static inline void trace_usb_uhci_td_async(uint32_t qh, uint32_t td)
{
    if (true) {
        _nocheck__trace_usb_uhci_td_async(qh, td);
    }
}

#define TRACE_USB_UHCI_TD_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UHCI_TD_COMPLETE) || \
    false)

static inline void _nocheck__trace_usb_uhci_td_complete(uint32_t qh, uint32_t td)
{
    if (trace_event_get_state(TRACE_USB_UHCI_TD_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uhci_td_complete " "qh 0x%x, td 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , qh, td);
    }
}

static inline void trace_usb_uhci_td_complete(uint32_t qh, uint32_t td)
{
    if (true) {
        _nocheck__trace_usb_uhci_td_complete(qh, td);
    }
}

#define TRACE_USB_XHCI_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_RESET) || \
    false)

static inline void _nocheck__trace_usb_xhci_reset(void)
{
    if (trace_event_get_state(TRACE_USB_XHCI_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_reset " "=== RESET ===" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_xhci_reset(void)
{
    if (true) {
        _nocheck__trace_usb_xhci_reset();
    }
}

#define TRACE_USB_XHCI_EXIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_EXIT) || \
    false)

static inline void _nocheck__trace_usb_xhci_exit(void)
{
    if (trace_event_get_state(TRACE_USB_XHCI_EXIT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_exit " "=== EXIT ===" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_xhci_exit(void)
{
    if (true) {
        _nocheck__trace_usb_xhci_exit();
    }
}

#define TRACE_USB_XHCI_RUN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_RUN) || \
    false)

static inline void _nocheck__trace_usb_xhci_run(void)
{
    if (trace_event_get_state(TRACE_USB_XHCI_RUN) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_run " "" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_xhci_run(void)
{
    if (true) {
        _nocheck__trace_usb_xhci_run();
    }
}

#define TRACE_USB_XHCI_STOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_STOP) || \
    false)

static inline void _nocheck__trace_usb_xhci_stop(void)
{
    if (trace_event_get_state(TRACE_USB_XHCI_STOP) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_stop " "" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_xhci_stop(void)
{
    if (true) {
        _nocheck__trace_usb_xhci_stop();
    }
}

#define TRACE_USB_XHCI_CAP_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_CAP_READ) || \
    false)

static inline void _nocheck__trace_usb_xhci_cap_read(uint32_t off, uint32_t val)
{
    if (trace_event_get_state(TRACE_USB_XHCI_CAP_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_cap_read " "off 0x%04x, ret 0x%08x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , off, val);
    }
}

static inline void trace_usb_xhci_cap_read(uint32_t off, uint32_t val)
{
    if (true) {
        _nocheck__trace_usb_xhci_cap_read(off, val);
    }
}

#define TRACE_USB_XHCI_OPER_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_OPER_READ) || \
    false)

static inline void _nocheck__trace_usb_xhci_oper_read(uint32_t off, uint32_t val)
{
    if (trace_event_get_state(TRACE_USB_XHCI_OPER_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_oper_read " "off 0x%04x, ret 0x%08x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , off, val);
    }
}

static inline void trace_usb_xhci_oper_read(uint32_t off, uint32_t val)
{
    if (true) {
        _nocheck__trace_usb_xhci_oper_read(off, val);
    }
}

#define TRACE_USB_XHCI_PORT_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_PORT_READ) || \
    false)

static inline void _nocheck__trace_usb_xhci_port_read(uint32_t port, uint32_t off, uint32_t val)
{
    if (trace_event_get_state(TRACE_USB_XHCI_PORT_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_port_read " "port %d, off 0x%04x, ret 0x%08x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , port, off, val);
    }
}

static inline void trace_usb_xhci_port_read(uint32_t port, uint32_t off, uint32_t val)
{
    if (true) {
        _nocheck__trace_usb_xhci_port_read(port, off, val);
    }
}

#define TRACE_USB_XHCI_RUNTIME_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_RUNTIME_READ) || \
    false)

static inline void _nocheck__trace_usb_xhci_runtime_read(uint32_t off, uint32_t val)
{
    if (trace_event_get_state(TRACE_USB_XHCI_RUNTIME_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_runtime_read " "off 0x%04x, ret 0x%08x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , off, val);
    }
}

static inline void trace_usb_xhci_runtime_read(uint32_t off, uint32_t val)
{
    if (true) {
        _nocheck__trace_usb_xhci_runtime_read(off, val);
    }
}

#define TRACE_USB_XHCI_DOORBELL_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_DOORBELL_READ) || \
    false)

static inline void _nocheck__trace_usb_xhci_doorbell_read(uint32_t off, uint32_t val)
{
    if (trace_event_get_state(TRACE_USB_XHCI_DOORBELL_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_doorbell_read " "off 0x%04x, ret 0x%08x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , off, val);
    }
}

static inline void trace_usb_xhci_doorbell_read(uint32_t off, uint32_t val)
{
    if (true) {
        _nocheck__trace_usb_xhci_doorbell_read(off, val);
    }
}

#define TRACE_USB_XHCI_OPER_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_OPER_WRITE) || \
    false)

static inline void _nocheck__trace_usb_xhci_oper_write(uint32_t off, uint32_t val)
{
    if (trace_event_get_state(TRACE_USB_XHCI_OPER_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_oper_write " "off 0x%04x, val 0x%08x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , off, val);
    }
}

static inline void trace_usb_xhci_oper_write(uint32_t off, uint32_t val)
{
    if (true) {
        _nocheck__trace_usb_xhci_oper_write(off, val);
    }
}

#define TRACE_USB_XHCI_PORT_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_PORT_WRITE) || \
    false)

static inline void _nocheck__trace_usb_xhci_port_write(uint32_t port, uint32_t off, uint32_t val)
{
    if (trace_event_get_state(TRACE_USB_XHCI_PORT_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_port_write " "port %d, off 0x%04x, val 0x%08x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , port, off, val);
    }
}

static inline void trace_usb_xhci_port_write(uint32_t port, uint32_t off, uint32_t val)
{
    if (true) {
        _nocheck__trace_usb_xhci_port_write(port, off, val);
    }
}

#define TRACE_USB_XHCI_RUNTIME_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_RUNTIME_WRITE) || \
    false)

static inline void _nocheck__trace_usb_xhci_runtime_write(uint32_t off, uint32_t val)
{
    if (trace_event_get_state(TRACE_USB_XHCI_RUNTIME_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_runtime_write " "off 0x%04x, val 0x%08x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , off, val);
    }
}

static inline void trace_usb_xhci_runtime_write(uint32_t off, uint32_t val)
{
    if (true) {
        _nocheck__trace_usb_xhci_runtime_write(off, val);
    }
}

#define TRACE_USB_XHCI_DOORBELL_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_DOORBELL_WRITE) || \
    false)

static inline void _nocheck__trace_usb_xhci_doorbell_write(uint32_t off, uint32_t val)
{
    if (trace_event_get_state(TRACE_USB_XHCI_DOORBELL_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_doorbell_write " "off 0x%04x, val 0x%08x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , off, val);
    }
}

static inline void trace_usb_xhci_doorbell_write(uint32_t off, uint32_t val)
{
    if (true) {
        _nocheck__trace_usb_xhci_doorbell_write(off, val);
    }
}

#define TRACE_USB_XHCI_IRQ_INTX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_IRQ_INTX) || \
    false)

static inline void _nocheck__trace_usb_xhci_irq_intx(uint32_t level)
{
    if (trace_event_get_state(TRACE_USB_XHCI_IRQ_INTX) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_irq_intx " "level %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , level);
    }
}

static inline void trace_usb_xhci_irq_intx(uint32_t level)
{
    if (true) {
        _nocheck__trace_usb_xhci_irq_intx(level);
    }
}

#define TRACE_USB_XHCI_IRQ_MSI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_IRQ_MSI) || \
    false)

static inline void _nocheck__trace_usb_xhci_irq_msi(uint32_t nr)
{
    if (trace_event_get_state(TRACE_USB_XHCI_IRQ_MSI) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_irq_msi " "nr %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , nr);
    }
}

static inline void trace_usb_xhci_irq_msi(uint32_t nr)
{
    if (true) {
        _nocheck__trace_usb_xhci_irq_msi(nr);
    }
}

#define TRACE_USB_XHCI_IRQ_MSIX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_IRQ_MSIX) || \
    false)

static inline void _nocheck__trace_usb_xhci_irq_msix(uint32_t nr)
{
    if (trace_event_get_state(TRACE_USB_XHCI_IRQ_MSIX) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_irq_msix " "nr %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , nr);
    }
}

static inline void trace_usb_xhci_irq_msix(uint32_t nr)
{
    if (true) {
        _nocheck__trace_usb_xhci_irq_msix(nr);
    }
}

#define TRACE_USB_XHCI_IRQ_MSIX_USE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_IRQ_MSIX_USE) || \
    false)

static inline void _nocheck__trace_usb_xhci_irq_msix_use(uint32_t nr)
{
    if (trace_event_get_state(TRACE_USB_XHCI_IRQ_MSIX_USE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_irq_msix_use " "nr %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , nr);
    }
}

static inline void trace_usb_xhci_irq_msix_use(uint32_t nr)
{
    if (true) {
        _nocheck__trace_usb_xhci_irq_msix_use(nr);
    }
}

#define TRACE_USB_XHCI_IRQ_MSIX_UNUSE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_IRQ_MSIX_UNUSE) || \
    false)

static inline void _nocheck__trace_usb_xhci_irq_msix_unuse(uint32_t nr)
{
    if (trace_event_get_state(TRACE_USB_XHCI_IRQ_MSIX_UNUSE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_irq_msix_unuse " "nr %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , nr);
    }
}

static inline void trace_usb_xhci_irq_msix_unuse(uint32_t nr)
{
    if (true) {
        _nocheck__trace_usb_xhci_irq_msix_unuse(nr);
    }
}

#define TRACE_USB_XHCI_QUEUE_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_QUEUE_EVENT) || \
    false)

static inline void _nocheck__trace_usb_xhci_queue_event(uint32_t vector, uint32_t idx, const char * trb, const char * evt, uint64_t param, uint32_t status, uint32_t control)
{
    if (trace_event_get_state(TRACE_USB_XHCI_QUEUE_EVENT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_queue_event " "v %d, idx %d, %s, %s, p 0x%016" PRIx64 ", s 0x%08x, c 0x%08x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , vector, idx, trb, evt, param, status, control);
    }
}

static inline void trace_usb_xhci_queue_event(uint32_t vector, uint32_t idx, const char * trb, const char * evt, uint64_t param, uint32_t status, uint32_t control)
{
    if (true) {
        _nocheck__trace_usb_xhci_queue_event(vector, idx, trb, evt, param, status, control);
    }
}

#define TRACE_USB_XHCI_FETCH_TRB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_FETCH_TRB) || \
    false)

static inline void _nocheck__trace_usb_xhci_fetch_trb(uint64_t addr, const char * name, uint64_t param, uint32_t status, uint32_t control)
{
    if (trace_event_get_state(TRACE_USB_XHCI_FETCH_TRB) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_fetch_trb " "addr 0x%016" PRIx64 ", %s, p 0x%016" PRIx64 ", s 0x%08x, c 0x%08x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, name, param, status, control);
    }
}

static inline void trace_usb_xhci_fetch_trb(uint64_t addr, const char * name, uint64_t param, uint32_t status, uint32_t control)
{
    if (true) {
        _nocheck__trace_usb_xhci_fetch_trb(addr, name, param, status, control);
    }
}

#define TRACE_USB_XHCI_PORT_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_PORT_RESET) || \
    false)

static inline void _nocheck__trace_usb_xhci_port_reset(uint32_t port, bool warm)
{
    if (trace_event_get_state(TRACE_USB_XHCI_PORT_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_port_reset " "port %d, warm %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , port, warm);
    }
}

static inline void trace_usb_xhci_port_reset(uint32_t port, bool warm)
{
    if (true) {
        _nocheck__trace_usb_xhci_port_reset(port, warm);
    }
}

#define TRACE_USB_XHCI_PORT_LINK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_PORT_LINK) || \
    false)

static inline void _nocheck__trace_usb_xhci_port_link(uint32_t port, uint32_t pls)
{
    if (trace_event_get_state(TRACE_USB_XHCI_PORT_LINK) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_port_link " "port %d, pls %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , port, pls);
    }
}

static inline void trace_usb_xhci_port_link(uint32_t port, uint32_t pls)
{
    if (true) {
        _nocheck__trace_usb_xhci_port_link(port, pls);
    }
}

#define TRACE_USB_XHCI_PORT_NOTIFY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_PORT_NOTIFY) || \
    false)

static inline void _nocheck__trace_usb_xhci_port_notify(uint32_t port, uint32_t pls)
{
    if (trace_event_get_state(TRACE_USB_XHCI_PORT_NOTIFY) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_port_notify " "port %d, bits 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , port, pls);
    }
}

static inline void trace_usb_xhci_port_notify(uint32_t port, uint32_t pls)
{
    if (true) {
        _nocheck__trace_usb_xhci_port_notify(port, pls);
    }
}

#define TRACE_USB_XHCI_SLOT_ENABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_SLOT_ENABLE) || \
    false)

static inline void _nocheck__trace_usb_xhci_slot_enable(uint32_t slotid)
{
    if (trace_event_get_state(TRACE_USB_XHCI_SLOT_ENABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_slot_enable " "slotid %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , slotid);
    }
}

static inline void trace_usb_xhci_slot_enable(uint32_t slotid)
{
    if (true) {
        _nocheck__trace_usb_xhci_slot_enable(slotid);
    }
}

#define TRACE_USB_XHCI_SLOT_DISABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_SLOT_DISABLE) || \
    false)

static inline void _nocheck__trace_usb_xhci_slot_disable(uint32_t slotid)
{
    if (trace_event_get_state(TRACE_USB_XHCI_SLOT_DISABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_slot_disable " "slotid %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , slotid);
    }
}

static inline void trace_usb_xhci_slot_disable(uint32_t slotid)
{
    if (true) {
        _nocheck__trace_usb_xhci_slot_disable(slotid);
    }
}

#define TRACE_USB_XHCI_SLOT_ADDRESS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_SLOT_ADDRESS) || \
    false)

static inline void _nocheck__trace_usb_xhci_slot_address(uint32_t slotid, const char * port)
{
    if (trace_event_get_state(TRACE_USB_XHCI_SLOT_ADDRESS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_slot_address " "slotid %d, port %s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , slotid, port);
    }
}

static inline void trace_usb_xhci_slot_address(uint32_t slotid, const char * port)
{
    if (true) {
        _nocheck__trace_usb_xhci_slot_address(slotid, port);
    }
}

#define TRACE_USB_XHCI_SLOT_CONFIGURE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_SLOT_CONFIGURE) || \
    false)

static inline void _nocheck__trace_usb_xhci_slot_configure(uint32_t slotid)
{
    if (trace_event_get_state(TRACE_USB_XHCI_SLOT_CONFIGURE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_slot_configure " "slotid %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , slotid);
    }
}

static inline void trace_usb_xhci_slot_configure(uint32_t slotid)
{
    if (true) {
        _nocheck__trace_usb_xhci_slot_configure(slotid);
    }
}

#define TRACE_USB_XHCI_SLOT_EVALUATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_SLOT_EVALUATE) || \
    false)

static inline void _nocheck__trace_usb_xhci_slot_evaluate(uint32_t slotid)
{
    if (trace_event_get_state(TRACE_USB_XHCI_SLOT_EVALUATE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_slot_evaluate " "slotid %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , slotid);
    }
}

static inline void trace_usb_xhci_slot_evaluate(uint32_t slotid)
{
    if (true) {
        _nocheck__trace_usb_xhci_slot_evaluate(slotid);
    }
}

#define TRACE_USB_XHCI_SLOT_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_SLOT_RESET) || \
    false)

static inline void _nocheck__trace_usb_xhci_slot_reset(uint32_t slotid)
{
    if (trace_event_get_state(TRACE_USB_XHCI_SLOT_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_slot_reset " "slotid %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , slotid);
    }
}

static inline void trace_usb_xhci_slot_reset(uint32_t slotid)
{
    if (true) {
        _nocheck__trace_usb_xhci_slot_reset(slotid);
    }
}

#define TRACE_USB_XHCI_EP_ENABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_EP_ENABLE) || \
    false)

static inline void _nocheck__trace_usb_xhci_ep_enable(uint32_t slotid, uint32_t epid)
{
    if (trace_event_get_state(TRACE_USB_XHCI_EP_ENABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_ep_enable " "slotid %d, epid %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , slotid, epid);
    }
}

static inline void trace_usb_xhci_ep_enable(uint32_t slotid, uint32_t epid)
{
    if (true) {
        _nocheck__trace_usb_xhci_ep_enable(slotid, epid);
    }
}

#define TRACE_USB_XHCI_EP_DISABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_EP_DISABLE) || \
    false)

static inline void _nocheck__trace_usb_xhci_ep_disable(uint32_t slotid, uint32_t epid)
{
    if (trace_event_get_state(TRACE_USB_XHCI_EP_DISABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_ep_disable " "slotid %d, epid %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , slotid, epid);
    }
}

static inline void trace_usb_xhci_ep_disable(uint32_t slotid, uint32_t epid)
{
    if (true) {
        _nocheck__trace_usb_xhci_ep_disable(slotid, epid);
    }
}

#define TRACE_USB_XHCI_EP_SET_DEQUEUE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_EP_SET_DEQUEUE) || \
    false)

static inline void _nocheck__trace_usb_xhci_ep_set_dequeue(uint32_t slotid, uint32_t epid, uint32_t streamid, uint64_t param)
{
    if (trace_event_get_state(TRACE_USB_XHCI_EP_SET_DEQUEUE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_ep_set_dequeue " "slotid %d, epid %d, streamid %d, ptr 0x%016" PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , slotid, epid, streamid, param);
    }
}

static inline void trace_usb_xhci_ep_set_dequeue(uint32_t slotid, uint32_t epid, uint32_t streamid, uint64_t param)
{
    if (true) {
        _nocheck__trace_usb_xhci_ep_set_dequeue(slotid, epid, streamid, param);
    }
}

#define TRACE_USB_XHCI_EP_KICK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_EP_KICK) || \
    false)

static inline void _nocheck__trace_usb_xhci_ep_kick(uint32_t slotid, uint32_t epid, uint32_t streamid)
{
    if (trace_event_get_state(TRACE_USB_XHCI_EP_KICK) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_ep_kick " "slotid %d, epid %d, streamid %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , slotid, epid, streamid);
    }
}

static inline void trace_usb_xhci_ep_kick(uint32_t slotid, uint32_t epid, uint32_t streamid)
{
    if (true) {
        _nocheck__trace_usb_xhci_ep_kick(slotid, epid, streamid);
    }
}

#define TRACE_USB_XHCI_EP_STOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_EP_STOP) || \
    false)

static inline void _nocheck__trace_usb_xhci_ep_stop(uint32_t slotid, uint32_t epid)
{
    if (trace_event_get_state(TRACE_USB_XHCI_EP_STOP) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_ep_stop " "slotid %d, epid %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , slotid, epid);
    }
}

static inline void trace_usb_xhci_ep_stop(uint32_t slotid, uint32_t epid)
{
    if (true) {
        _nocheck__trace_usb_xhci_ep_stop(slotid, epid);
    }
}

#define TRACE_USB_XHCI_EP_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_EP_RESET) || \
    false)

static inline void _nocheck__trace_usb_xhci_ep_reset(uint32_t slotid, uint32_t epid)
{
    if (trace_event_get_state(TRACE_USB_XHCI_EP_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_ep_reset " "slotid %d, epid %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , slotid, epid);
    }
}

static inline void trace_usb_xhci_ep_reset(uint32_t slotid, uint32_t epid)
{
    if (true) {
        _nocheck__trace_usb_xhci_ep_reset(slotid, epid);
    }
}

#define TRACE_USB_XHCI_EP_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_EP_STATE) || \
    false)

static inline void _nocheck__trace_usb_xhci_ep_state(uint32_t slotid, uint32_t epid, const char * os, const char * ns)
{
    if (trace_event_get_state(TRACE_USB_XHCI_EP_STATE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_ep_state " "slotid %d, epid %d, %s -> %s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , slotid, epid, os, ns);
    }
}

static inline void trace_usb_xhci_ep_state(uint32_t slotid, uint32_t epid, const char * os, const char * ns)
{
    if (true) {
        _nocheck__trace_usb_xhci_ep_state(slotid, epid, os, ns);
    }
}

#define TRACE_USB_XHCI_XFER_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_XFER_START) || \
    false)

static inline void _nocheck__trace_usb_xhci_xfer_start(void * xfer, uint32_t slotid, uint32_t epid, uint32_t streamid)
{
    if (trace_event_get_state(TRACE_USB_XHCI_XFER_START) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_xfer_start " "%p: slotid %d, epid %d, streamid %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , xfer, slotid, epid, streamid);
    }
}

static inline void trace_usb_xhci_xfer_start(void * xfer, uint32_t slotid, uint32_t epid, uint32_t streamid)
{
    if (true) {
        _nocheck__trace_usb_xhci_xfer_start(xfer, slotid, epid, streamid);
    }
}

#define TRACE_USB_XHCI_XFER_ASYNC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_XFER_ASYNC) || \
    false)

static inline void _nocheck__trace_usb_xhci_xfer_async(void * xfer)
{
    if (trace_event_get_state(TRACE_USB_XHCI_XFER_ASYNC) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_xfer_async " "%p" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , xfer);
    }
}

static inline void trace_usb_xhci_xfer_async(void * xfer)
{
    if (true) {
        _nocheck__trace_usb_xhci_xfer_async(xfer);
    }
}

#define TRACE_USB_XHCI_XFER_NAK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_XFER_NAK) || \
    false)

static inline void _nocheck__trace_usb_xhci_xfer_nak(void * xfer)
{
    if (trace_event_get_state(TRACE_USB_XHCI_XFER_NAK) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_xfer_nak " "%p" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , xfer);
    }
}

static inline void trace_usb_xhci_xfer_nak(void * xfer)
{
    if (true) {
        _nocheck__trace_usb_xhci_xfer_nak(xfer);
    }
}

#define TRACE_USB_XHCI_XFER_RETRY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_XFER_RETRY) || \
    false)

static inline void _nocheck__trace_usb_xhci_xfer_retry(void * xfer)
{
    if (trace_event_get_state(TRACE_USB_XHCI_XFER_RETRY) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_xfer_retry " "%p" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , xfer);
    }
}

static inline void trace_usb_xhci_xfer_retry(void * xfer)
{
    if (true) {
        _nocheck__trace_usb_xhci_xfer_retry(xfer);
    }
}

#define TRACE_USB_XHCI_XFER_SUCCESS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_XFER_SUCCESS) || \
    false)

static inline void _nocheck__trace_usb_xhci_xfer_success(void * xfer, uint32_t bytes)
{
    if (trace_event_get_state(TRACE_USB_XHCI_XFER_SUCCESS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_xfer_success " "%p: len %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , xfer, bytes);
    }
}

static inline void trace_usb_xhci_xfer_success(void * xfer, uint32_t bytes)
{
    if (true) {
        _nocheck__trace_usb_xhci_xfer_success(xfer, bytes);
    }
}

#define TRACE_USB_XHCI_XFER_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_XFER_ERROR) || \
    false)

static inline void _nocheck__trace_usb_xhci_xfer_error(void * xfer, uint32_t ret)
{
    if (trace_event_get_state(TRACE_USB_XHCI_XFER_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_xfer_error " "%p: ret %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , xfer, ret);
    }
}

static inline void trace_usb_xhci_xfer_error(void * xfer, uint32_t ret)
{
    if (true) {
        _nocheck__trace_usb_xhci_xfer_error(xfer, ret);
    }
}

#define TRACE_USB_XHCI_UNIMPLEMENTED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_UNIMPLEMENTED) || \
    false)

static inline void _nocheck__trace_usb_xhci_unimplemented(const char * item, int nr)
{
    if (trace_event_get_state(TRACE_USB_XHCI_UNIMPLEMENTED) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_unimplemented " "%s (0x%x)" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , item, nr);
    }
}

static inline void trace_usb_xhci_unimplemented(const char * item, int nr)
{
    if (true) {
        _nocheck__trace_usb_xhci_unimplemented(item, nr);
    }
}

#define TRACE_USB_XHCI_ENFORCED_LIMIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_XHCI_ENFORCED_LIMIT) || \
    false)

static inline void _nocheck__trace_usb_xhci_enforced_limit(const char * item)
{
    if (trace_event_get_state(TRACE_USB_XHCI_ENFORCED_LIMIT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_xhci_enforced_limit " "%s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , item);
    }
}

static inline void trace_usb_xhci_enforced_limit(const char * item)
{
    if (true) {
        _nocheck__trace_usb_xhci_enforced_limit(item);
    }
}

#define TRACE_USB_DWC2_UPDATE_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_UPDATE_IRQ) || \
    false)

static inline void _nocheck__trace_usb_dwc2_update_irq(uint32_t level)
{
    if (trace_event_get_state(TRACE_USB_DWC2_UPDATE_IRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_update_irq " "level=%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , level);
    }
}

static inline void trace_usb_dwc2_update_irq(uint32_t level)
{
    if (true) {
        _nocheck__trace_usb_dwc2_update_irq(level);
    }
}

#define TRACE_USB_DWC2_RAISE_GLOBAL_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_RAISE_GLOBAL_IRQ) || \
    false)

static inline void _nocheck__trace_usb_dwc2_raise_global_irq(uint32_t intr)
{
    if (trace_event_get_state(TRACE_USB_DWC2_RAISE_GLOBAL_IRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_raise_global_irq " "0x%08x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , intr);
    }
}

static inline void trace_usb_dwc2_raise_global_irq(uint32_t intr)
{
    if (true) {
        _nocheck__trace_usb_dwc2_raise_global_irq(intr);
    }
}

#define TRACE_USB_DWC2_LOWER_GLOBAL_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_LOWER_GLOBAL_IRQ) || \
    false)

static inline void _nocheck__trace_usb_dwc2_lower_global_irq(uint32_t intr)
{
    if (trace_event_get_state(TRACE_USB_DWC2_LOWER_GLOBAL_IRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_lower_global_irq " "0x%08x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , intr);
    }
}

static inline void trace_usb_dwc2_lower_global_irq(uint32_t intr)
{
    if (true) {
        _nocheck__trace_usb_dwc2_lower_global_irq(intr);
    }
}

#define TRACE_USB_DWC2_RAISE_HOST_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_RAISE_HOST_IRQ) || \
    false)

static inline void _nocheck__trace_usb_dwc2_raise_host_irq(uint32_t intr)
{
    if (trace_event_get_state(TRACE_USB_DWC2_RAISE_HOST_IRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_raise_host_irq " "0x%04x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , intr);
    }
}

static inline void trace_usb_dwc2_raise_host_irq(uint32_t intr)
{
    if (true) {
        _nocheck__trace_usb_dwc2_raise_host_irq(intr);
    }
}

#define TRACE_USB_DWC2_LOWER_HOST_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_LOWER_HOST_IRQ) || \
    false)

static inline void _nocheck__trace_usb_dwc2_lower_host_irq(uint32_t intr)
{
    if (trace_event_get_state(TRACE_USB_DWC2_LOWER_HOST_IRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_lower_host_irq " "0x%04x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , intr);
    }
}

static inline void trace_usb_dwc2_lower_host_irq(uint32_t intr)
{
    if (true) {
        _nocheck__trace_usb_dwc2_lower_host_irq(intr);
    }
}

#define TRACE_USB_DWC2_SOF_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_SOF) || \
    false)

static inline void _nocheck__trace_usb_dwc2_sof(int64_t next)
{
    if (trace_event_get_state(TRACE_USB_DWC2_SOF) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_sof " "next SOF %" PRId64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , next);
    }
}

static inline void trace_usb_dwc2_sof(int64_t next)
{
    if (true) {
        _nocheck__trace_usb_dwc2_sof(next);
    }
}

#define TRACE_USB_DWC2_BUS_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_BUS_START) || \
    false)

static inline void _nocheck__trace_usb_dwc2_bus_start(void)
{
    if (trace_event_get_state(TRACE_USB_DWC2_BUS_START) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_bus_start " "start SOFs" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_dwc2_bus_start(void)
{
    if (true) {
        _nocheck__trace_usb_dwc2_bus_start();
    }
}

#define TRACE_USB_DWC2_BUS_STOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_BUS_STOP) || \
    false)

static inline void _nocheck__trace_usb_dwc2_bus_stop(void)
{
    if (trace_event_get_state(TRACE_USB_DWC2_BUS_STOP) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_bus_stop " "stop SOFs" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_dwc2_bus_stop(void)
{
    if (true) {
        _nocheck__trace_usb_dwc2_bus_stop();
    }
}

#define TRACE_USB_DWC2_FIND_DEVICE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_FIND_DEVICE) || \
    false)

static inline void _nocheck__trace_usb_dwc2_find_device(uint8_t addr)
{
    if (trace_event_get_state(TRACE_USB_DWC2_FIND_DEVICE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_find_device " "%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr);
    }
}

static inline void trace_usb_dwc2_find_device(uint8_t addr)
{
    if (true) {
        _nocheck__trace_usb_dwc2_find_device(addr);
    }
}

#define TRACE_USB_DWC2_PORT_DISABLED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_PORT_DISABLED) || \
    false)

static inline void _nocheck__trace_usb_dwc2_port_disabled(uint32_t pnum)
{
    if (trace_event_get_state(TRACE_USB_DWC2_PORT_DISABLED) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_port_disabled " "port %d disabled" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , pnum);
    }
}

static inline void trace_usb_dwc2_port_disabled(uint32_t pnum)
{
    if (true) {
        _nocheck__trace_usb_dwc2_port_disabled(pnum);
    }
}

#define TRACE_USB_DWC2_DEVICE_FOUND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_DEVICE_FOUND) || \
    false)

static inline void _nocheck__trace_usb_dwc2_device_found(uint32_t pnum)
{
    if (trace_event_get_state(TRACE_USB_DWC2_DEVICE_FOUND) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_device_found " "device found on port %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , pnum);
    }
}

static inline void trace_usb_dwc2_device_found(uint32_t pnum)
{
    if (true) {
        _nocheck__trace_usb_dwc2_device_found(pnum);
    }
}

#define TRACE_USB_DWC2_DEVICE_NOT_FOUND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_DEVICE_NOT_FOUND) || \
    false)

static inline void _nocheck__trace_usb_dwc2_device_not_found(void)
{
    if (trace_event_get_state(TRACE_USB_DWC2_DEVICE_NOT_FOUND) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_device_not_found " "device not found" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_dwc2_device_not_found(void)
{
    if (true) {
        _nocheck__trace_usb_dwc2_device_not_found();
    }
}

#define TRACE_USB_DWC2_HANDLE_PACKET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_HANDLE_PACKET) || \
    false)

static inline void _nocheck__trace_usb_dwc2_handle_packet(uint32_t chan, void * dev, void * pkt, uint32_t ep, const char * type, const char * dir, uint32_t mps, uint32_t len, uint32_t pcnt)
{
    if (trace_event_get_state(TRACE_USB_DWC2_HANDLE_PACKET) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_handle_packet " "ch %d dev %p pkt %p ep %d type %s dir %s mps %d len %d pcnt %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , chan, dev, pkt, ep, type, dir, mps, len, pcnt);
    }
}

static inline void trace_usb_dwc2_handle_packet(uint32_t chan, void * dev, void * pkt, uint32_t ep, const char * type, const char * dir, uint32_t mps, uint32_t len, uint32_t pcnt)
{
    if (true) {
        _nocheck__trace_usb_dwc2_handle_packet(chan, dev, pkt, ep, type, dir, mps, len, pcnt);
    }
}

#define TRACE_USB_DWC2_MEMORY_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_MEMORY_READ) || \
    false)

static inline void _nocheck__trace_usb_dwc2_memory_read(uint32_t addr, uint32_t len)
{
    if (trace_event_get_state(TRACE_USB_DWC2_MEMORY_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_memory_read " "addr %d len %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, len);
    }
}

static inline void trace_usb_dwc2_memory_read(uint32_t addr, uint32_t len)
{
    if (true) {
        _nocheck__trace_usb_dwc2_memory_read(addr, len);
    }
}

#define TRACE_USB_DWC2_PACKET_STATUS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_PACKET_STATUS) || \
    false)

static inline void _nocheck__trace_usb_dwc2_packet_status(const char * status, uint32_t len)
{
    if (trace_event_get_state(TRACE_USB_DWC2_PACKET_STATUS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_packet_status " "status %s len %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , status, len);
    }
}

static inline void trace_usb_dwc2_packet_status(const char * status, uint32_t len)
{
    if (true) {
        _nocheck__trace_usb_dwc2_packet_status(status, len);
    }
}

#define TRACE_USB_DWC2_PACKET_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_PACKET_ERROR) || \
    false)

static inline void _nocheck__trace_usb_dwc2_packet_error(const char * status)
{
    if (trace_event_get_state(TRACE_USB_DWC2_PACKET_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_packet_error " "ERROR %s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , status);
    }
}

static inline void trace_usb_dwc2_packet_error(const char * status)
{
    if (true) {
        _nocheck__trace_usb_dwc2_packet_error(status);
    }
}

#define TRACE_USB_DWC2_ASYNC_PACKET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_ASYNC_PACKET) || \
    false)

static inline void _nocheck__trace_usb_dwc2_async_packet(void * pkt, uint32_t chan, void * dev, uint32_t ep, const char * dir, uint32_t len)
{
    if (trace_event_get_state(TRACE_USB_DWC2_ASYNC_PACKET) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_async_packet " "pkt %p ch %d dev %p ep %d %s len %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , pkt, chan, dev, ep, dir, len);
    }
}

static inline void trace_usb_dwc2_async_packet(void * pkt, uint32_t chan, void * dev, uint32_t ep, const char * dir, uint32_t len)
{
    if (true) {
        _nocheck__trace_usb_dwc2_async_packet(pkt, chan, dev, ep, dir, len);
    }
}

#define TRACE_USB_DWC2_MEMORY_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_MEMORY_WRITE) || \
    false)

static inline void _nocheck__trace_usb_dwc2_memory_write(uint32_t addr, uint32_t len)
{
    if (trace_event_get_state(TRACE_USB_DWC2_MEMORY_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_memory_write " "addr %d len %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, len);
    }
}

static inline void trace_usb_dwc2_memory_write(uint32_t addr, uint32_t len)
{
    if (true) {
        _nocheck__trace_usb_dwc2_memory_write(addr, len);
    }
}

#define TRACE_USB_DWC2_PACKET_DONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_PACKET_DONE) || \
    false)

static inline void _nocheck__trace_usb_dwc2_packet_done(const char * status, uint32_t actual, uint32_t len, uint32_t pcnt)
{
    if (trace_event_get_state(TRACE_USB_DWC2_PACKET_DONE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_packet_done " "status %s actual %d len %d pcnt %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , status, actual, len, pcnt);
    }
}

static inline void trace_usb_dwc2_packet_done(const char * status, uint32_t actual, uint32_t len, uint32_t pcnt)
{
    if (true) {
        _nocheck__trace_usb_dwc2_packet_done(status, actual, len, pcnt);
    }
}

#define TRACE_USB_DWC2_PACKET_NEXT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_PACKET_NEXT) || \
    false)

static inline void _nocheck__trace_usb_dwc2_packet_next(const char * status, uint32_t len, uint32_t pcnt)
{
    if (trace_event_get_state(TRACE_USB_DWC2_PACKET_NEXT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_packet_next " "status %s len %d pcnt %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , status, len, pcnt);
    }
}

static inline void trace_usb_dwc2_packet_next(const char * status, uint32_t len, uint32_t pcnt)
{
    if (true) {
        _nocheck__trace_usb_dwc2_packet_next(status, len, pcnt);
    }
}

#define TRACE_USB_DWC2_ATTACH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_ATTACH) || \
    false)

static inline void _nocheck__trace_usb_dwc2_attach(void * port)
{
    if (trace_event_get_state(TRACE_USB_DWC2_ATTACH) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_attach " "port %p" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , port);
    }
}

static inline void trace_usb_dwc2_attach(void * port)
{
    if (true) {
        _nocheck__trace_usb_dwc2_attach(port);
    }
}

#define TRACE_USB_DWC2_ATTACH_SPEED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_ATTACH_SPEED) || \
    false)

static inline void _nocheck__trace_usb_dwc2_attach_speed(const char * speed)
{
    if (trace_event_get_state(TRACE_USB_DWC2_ATTACH_SPEED) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_attach_speed " "%s-speed device attached" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , speed);
    }
}

static inline void trace_usb_dwc2_attach_speed(const char * speed)
{
    if (true) {
        _nocheck__trace_usb_dwc2_attach_speed(speed);
    }
}

#define TRACE_USB_DWC2_DETACH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_DETACH) || \
    false)

static inline void _nocheck__trace_usb_dwc2_detach(void * port)
{
    if (trace_event_get_state(TRACE_USB_DWC2_DETACH) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_detach " "port %p" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , port);
    }
}

static inline void trace_usb_dwc2_detach(void * port)
{
    if (true) {
        _nocheck__trace_usb_dwc2_detach(port);
    }
}

#define TRACE_USB_DWC2_CHILD_DETACH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_CHILD_DETACH) || \
    false)

static inline void _nocheck__trace_usb_dwc2_child_detach(void * port, void * child)
{
    if (trace_event_get_state(TRACE_USB_DWC2_CHILD_DETACH) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_child_detach " "port %p child %p" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , port, child);
    }
}

static inline void trace_usb_dwc2_child_detach(void * port, void * child)
{
    if (true) {
        _nocheck__trace_usb_dwc2_child_detach(port, child);
    }
}

#define TRACE_USB_DWC2_WAKEUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_WAKEUP) || \
    false)

static inline void _nocheck__trace_usb_dwc2_wakeup(void * port)
{
    if (trace_event_get_state(TRACE_USB_DWC2_WAKEUP) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_wakeup " "port %p" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , port);
    }
}

static inline void trace_usb_dwc2_wakeup(void * port)
{
    if (true) {
        _nocheck__trace_usb_dwc2_wakeup(port);
    }
}

#define TRACE_USB_DWC2_ASYNC_PACKET_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_ASYNC_PACKET_COMPLETE) || \
    false)

static inline void _nocheck__trace_usb_dwc2_async_packet_complete(void * port, void * pkt, uint32_t chan, void * dev, uint32_t ep, const char * dir, uint32_t len)
{
    if (trace_event_get_state(TRACE_USB_DWC2_ASYNC_PACKET_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_async_packet_complete " "port %p packet %p ch %d dev %p ep %d %s len %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , port, pkt, chan, dev, ep, dir, len);
    }
}

static inline void trace_usb_dwc2_async_packet_complete(void * port, void * pkt, uint32_t chan, void * dev, uint32_t ep, const char * dir, uint32_t len)
{
    if (true) {
        _nocheck__trace_usb_dwc2_async_packet_complete(port, pkt, chan, dev, ep, dir, len);
    }
}

#define TRACE_USB_DWC2_WORK_BH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_WORK_BH) || \
    false)

static inline void _nocheck__trace_usb_dwc2_work_bh(void)
{
    if (trace_event_get_state(TRACE_USB_DWC2_WORK_BH) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_work_bh " "" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_dwc2_work_bh(void)
{
    if (true) {
        _nocheck__trace_usb_dwc2_work_bh();
    }
}

#define TRACE_USB_DWC2_WORK_BH_SERVICE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_WORK_BH_SERVICE) || \
    false)

static inline void _nocheck__trace_usb_dwc2_work_bh_service(uint32_t first, uint32_t current, void * dev, uint32_t ep)
{
    if (trace_event_get_state(TRACE_USB_DWC2_WORK_BH_SERVICE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_work_bh_service " "first %d servicing %d dev %p ep %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , first, current, dev, ep);
    }
}

static inline void trace_usb_dwc2_work_bh_service(uint32_t first, uint32_t current, void * dev, uint32_t ep)
{
    if (true) {
        _nocheck__trace_usb_dwc2_work_bh_service(first, current, dev, ep);
    }
}

#define TRACE_USB_DWC2_WORK_BH_NEXT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_WORK_BH_NEXT) || \
    false)

static inline void _nocheck__trace_usb_dwc2_work_bh_next(uint32_t chan)
{
    if (trace_event_get_state(TRACE_USB_DWC2_WORK_BH_NEXT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_work_bh_next " "next %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , chan);
    }
}

static inline void trace_usb_dwc2_work_bh_next(uint32_t chan)
{
    if (true) {
        _nocheck__trace_usb_dwc2_work_bh_next(chan);
    }
}

#define TRACE_USB_DWC2_ENABLE_CHAN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_ENABLE_CHAN) || \
    false)

static inline void _nocheck__trace_usb_dwc2_enable_chan(uint32_t chan, void * dev, void * pkt, uint32_t ep)
{
    if (trace_event_get_state(TRACE_USB_DWC2_ENABLE_CHAN) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_enable_chan " "ch %d dev %p pkt %p ep %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , chan, dev, pkt, ep);
    }
}

static inline void trace_usb_dwc2_enable_chan(uint32_t chan, void * dev, void * pkt, uint32_t ep)
{
    if (true) {
        _nocheck__trace_usb_dwc2_enable_chan(chan, dev, pkt, ep);
    }
}

#define TRACE_USB_DWC2_GLBREG_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_GLBREG_READ) || \
    false)

static inline void _nocheck__trace_usb_dwc2_glbreg_read(uint64_t addr, const char * reg, uint32_t val)
{
    if (trace_event_get_state(TRACE_USB_DWC2_GLBREG_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_glbreg_read " " 0x%04" PRIx64 " %s val 0x%08x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, reg, val);
    }
}

static inline void trace_usb_dwc2_glbreg_read(uint64_t addr, const char * reg, uint32_t val)
{
    if (true) {
        _nocheck__trace_usb_dwc2_glbreg_read(addr, reg, val);
    }
}

#define TRACE_USB_DWC2_GLBREG_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_GLBREG_WRITE) || \
    false)

static inline void _nocheck__trace_usb_dwc2_glbreg_write(uint64_t addr, const char * reg, uint64_t val, uint32_t old, uint64_t result)
{
    if (trace_event_get_state(TRACE_USB_DWC2_GLBREG_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_glbreg_write " "0x%04" PRIx64 " %s val 0x%08" PRIx64 " old 0x%08x result 0x%08" PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, reg, val, old, result);
    }
}

static inline void trace_usb_dwc2_glbreg_write(uint64_t addr, const char * reg, uint64_t val, uint32_t old, uint64_t result)
{
    if (true) {
        _nocheck__trace_usb_dwc2_glbreg_write(addr, reg, val, old, result);
    }
}

#define TRACE_USB_DWC2_FSZREG_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_FSZREG_READ) || \
    false)

static inline void _nocheck__trace_usb_dwc2_fszreg_read(uint64_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_USB_DWC2_FSZREG_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_fszreg_read " " 0x%04" PRIx64 " HPTXFSIZ  val 0x%08x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, val);
    }
}

static inline void trace_usb_dwc2_fszreg_read(uint64_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_usb_dwc2_fszreg_read(addr, val);
    }
}

#define TRACE_USB_DWC2_FSZREG_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_FSZREG_WRITE) || \
    false)

static inline void _nocheck__trace_usb_dwc2_fszreg_write(uint64_t addr, uint64_t val, uint32_t old, uint64_t result)
{
    if (trace_event_get_state(TRACE_USB_DWC2_FSZREG_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_fszreg_write " "0x%04" PRIx64 " HPTXFSIZ  val 0x%08" PRIx64 " old 0x%08x result 0x%08" PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, val, old, result);
    }
}

static inline void trace_usb_dwc2_fszreg_write(uint64_t addr, uint64_t val, uint32_t old, uint64_t result)
{
    if (true) {
        _nocheck__trace_usb_dwc2_fszreg_write(addr, val, old, result);
    }
}

#define TRACE_USB_DWC2_HREG0_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_HREG0_READ) || \
    false)

static inline void _nocheck__trace_usb_dwc2_hreg0_read(uint64_t addr, const char * reg, uint32_t val)
{
    if (trace_event_get_state(TRACE_USB_DWC2_HREG0_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_hreg0_read " "  0x%04" PRIx64 " %s val 0x%08x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, reg, val);
    }
}

static inline void trace_usb_dwc2_hreg0_read(uint64_t addr, const char * reg, uint32_t val)
{
    if (true) {
        _nocheck__trace_usb_dwc2_hreg0_read(addr, reg, val);
    }
}

#define TRACE_USB_DWC2_HREG0_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_HREG0_WRITE) || \
    false)

static inline void _nocheck__trace_usb_dwc2_hreg0_write(uint64_t addr, const char * reg, uint64_t val, uint32_t old, uint64_t result)
{
    if (trace_event_get_state(TRACE_USB_DWC2_HREG0_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_hreg0_write " " 0x%04" PRIx64 " %s val 0x%08" PRIx64 " old 0x%08x result 0x%08" PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, reg, val, old, result);
    }
}

static inline void trace_usb_dwc2_hreg0_write(uint64_t addr, const char * reg, uint64_t val, uint32_t old, uint64_t result)
{
    if (true) {
        _nocheck__trace_usb_dwc2_hreg0_write(addr, reg, val, old, result);
    }
}

#define TRACE_USB_DWC2_HREG1_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_HREG1_READ) || \
    false)

static inline void _nocheck__trace_usb_dwc2_hreg1_read(uint64_t addr, const char * reg, uint64_t chan, uint32_t val)
{
    if (trace_event_get_state(TRACE_USB_DWC2_HREG1_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_hreg1_read " "  0x%04" PRIx64 " %s%" PRId64 " val 0x%08x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, reg, chan, val);
    }
}

static inline void trace_usb_dwc2_hreg1_read(uint64_t addr, const char * reg, uint64_t chan, uint32_t val)
{
    if (true) {
        _nocheck__trace_usb_dwc2_hreg1_read(addr, reg, chan, val);
    }
}

#define TRACE_USB_DWC2_HREG1_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_HREG1_WRITE) || \
    false)

static inline void _nocheck__trace_usb_dwc2_hreg1_write(uint64_t addr, const char * reg, uint64_t chan, uint64_t val, uint32_t old, uint64_t result)
{
    if (trace_event_get_state(TRACE_USB_DWC2_HREG1_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_hreg1_write " " 0x%04" PRIx64 " %s%" PRId64 " val 0x%08" PRIx64 " old 0x%08x result 0x%08" PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, reg, chan, val, old, result);
    }
}

static inline void trace_usb_dwc2_hreg1_write(uint64_t addr, const char * reg, uint64_t chan, uint64_t val, uint32_t old, uint64_t result)
{
    if (true) {
        _nocheck__trace_usb_dwc2_hreg1_write(addr, reg, chan, val, old, result);
    }
}

#define TRACE_USB_DWC2_PCGREG_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_PCGREG_READ) || \
    false)

static inline void _nocheck__trace_usb_dwc2_pcgreg_read(uint64_t addr, const char * reg, uint32_t val)
{
    if (trace_event_get_state(TRACE_USB_DWC2_PCGREG_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_pcgreg_read " " 0x%04" PRIx64 " %s val 0x%08x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, reg, val);
    }
}

static inline void trace_usb_dwc2_pcgreg_read(uint64_t addr, const char * reg, uint32_t val)
{
    if (true) {
        _nocheck__trace_usb_dwc2_pcgreg_read(addr, reg, val);
    }
}

#define TRACE_USB_DWC2_PCGREG_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_PCGREG_WRITE) || \
    false)

static inline void _nocheck__trace_usb_dwc2_pcgreg_write(uint64_t addr, const char * reg, uint64_t val, uint32_t old, uint64_t result)
{
    if (trace_event_get_state(TRACE_USB_DWC2_PCGREG_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_pcgreg_write " "0x%04" PRIx64 " %s val 0x%08" PRIx64 " old 0x%08x result 0x%08" PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, reg, val, old, result);
    }
}

static inline void trace_usb_dwc2_pcgreg_write(uint64_t addr, const char * reg, uint64_t val, uint32_t old, uint64_t result)
{
    if (true) {
        _nocheck__trace_usb_dwc2_pcgreg_write(addr, reg, val, old, result);
    }
}

#define TRACE_USB_DWC2_HREG2_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_HREG2_READ) || \
    false)

static inline void _nocheck__trace_usb_dwc2_hreg2_read(uint64_t addr, uint64_t fifo, uint32_t val)
{
    if (trace_event_get_state(TRACE_USB_DWC2_HREG2_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_hreg2_read " "  0x%04" PRIx64 " FIFO%" PRId64 "     val 0x%08x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, fifo, val);
    }
}

static inline void trace_usb_dwc2_hreg2_read(uint64_t addr, uint64_t fifo, uint32_t val)
{
    if (true) {
        _nocheck__trace_usb_dwc2_hreg2_read(addr, fifo, val);
    }
}

#define TRACE_USB_DWC2_HREG2_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_HREG2_WRITE) || \
    false)

static inline void _nocheck__trace_usb_dwc2_hreg2_write(uint64_t addr, uint64_t fifo, uint64_t val, uint32_t old, uint64_t result)
{
    if (trace_event_get_state(TRACE_USB_DWC2_HREG2_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_hreg2_write " " 0x%04" PRIx64 " FIFO%" PRId64 "     val 0x%08" PRIx64 " old 0x%08x result 0x%08" PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, fifo, val, old, result);
    }
}

static inline void trace_usb_dwc2_hreg2_write(uint64_t addr, uint64_t fifo, uint64_t val, uint32_t old, uint64_t result)
{
    if (true) {
        _nocheck__trace_usb_dwc2_hreg2_write(addr, fifo, val, old, result);
    }
}

#define TRACE_USB_DWC2_HREG0_ACTION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_HREG0_ACTION) || \
    false)

static inline void _nocheck__trace_usb_dwc2_hreg0_action(const char * s)
{
    if (trace_event_get_state(TRACE_USB_DWC2_HREG0_ACTION) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_hreg0_action " "%s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s);
    }
}

static inline void trace_usb_dwc2_hreg0_action(const char * s)
{
    if (true) {
        _nocheck__trace_usb_dwc2_hreg0_action(s);
    }
}

#define TRACE_USB_DWC2_WAKEUP_ENDPOINT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_WAKEUP_ENDPOINT) || \
    false)

static inline void _nocheck__trace_usb_dwc2_wakeup_endpoint(void * ep, uint32_t stream)
{
    if (trace_event_get_state(TRACE_USB_DWC2_WAKEUP_ENDPOINT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_wakeup_endpoint " "endp %p stream %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , ep, stream);
    }
}

static inline void trace_usb_dwc2_wakeup_endpoint(void * ep, uint32_t stream)
{
    if (true) {
        _nocheck__trace_usb_dwc2_wakeup_endpoint(ep, stream);
    }
}

#define TRACE_USB_DWC2_WORK_TIMER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_WORK_TIMER) || \
    false)

static inline void _nocheck__trace_usb_dwc2_work_timer(void)
{
    if (trace_event_get_state(TRACE_USB_DWC2_WORK_TIMER) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_work_timer " "" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_dwc2_work_timer(void)
{
    if (true) {
        _nocheck__trace_usb_dwc2_work_timer();
    }
}

#define TRACE_USB_DWC2_RESET_ENTER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_RESET_ENTER) || \
    false)

static inline void _nocheck__trace_usb_dwc2_reset_enter(void)
{
    if (trace_event_get_state(TRACE_USB_DWC2_RESET_ENTER) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_reset_enter " "=== RESET enter ===" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_dwc2_reset_enter(void)
{
    if (true) {
        _nocheck__trace_usb_dwc2_reset_enter();
    }
}

#define TRACE_USB_DWC2_RESET_HOLD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_RESET_HOLD) || \
    false)

static inline void _nocheck__trace_usb_dwc2_reset_hold(void)
{
    if (trace_event_get_state(TRACE_USB_DWC2_RESET_HOLD) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_reset_hold " "=== RESET hold ===" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_dwc2_reset_hold(void)
{
    if (true) {
        _nocheck__trace_usb_dwc2_reset_hold();
    }
}

#define TRACE_USB_DWC2_RESET_EXIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DWC2_RESET_EXIT) || \
    false)

static inline void _nocheck__trace_usb_dwc2_reset_exit(void)
{
    if (trace_event_get_state(TRACE_USB_DWC2_RESET_EXIT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_dwc2_reset_exit " "=== RESET exit ===" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_dwc2_reset_exit(void)
{
    if (true) {
        _nocheck__trace_usb_dwc2_reset_exit();
    }
}

#define TRACE_USB_DESC_DEVICE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DESC_DEVICE) || \
    false)

static inline void _nocheck__trace_usb_desc_device(int addr, int len, int ret)
{
    if (trace_event_get_state(TRACE_USB_DESC_DEVICE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_desc_device " "dev %d query device, len %d, ret %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, len, ret);
    }
}

static inline void trace_usb_desc_device(int addr, int len, int ret)
{
    if (true) {
        _nocheck__trace_usb_desc_device(addr, len, ret);
    }
}

#define TRACE_USB_DESC_DEVICE_QUALIFIER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DESC_DEVICE_QUALIFIER) || \
    false)

static inline void _nocheck__trace_usb_desc_device_qualifier(int addr, int len, int ret)
{
    if (trace_event_get_state(TRACE_USB_DESC_DEVICE_QUALIFIER) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_desc_device_qualifier " "dev %d query device qualifier, len %d, ret %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, len, ret);
    }
}

static inline void trace_usb_desc_device_qualifier(int addr, int len, int ret)
{
    if (true) {
        _nocheck__trace_usb_desc_device_qualifier(addr, len, ret);
    }
}

#define TRACE_USB_DESC_CONFIG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DESC_CONFIG) || \
    false)

static inline void _nocheck__trace_usb_desc_config(int addr, int index, int len, int ret)
{
    if (trace_event_get_state(TRACE_USB_DESC_CONFIG) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_desc_config " "dev %d query config %d, len %d, ret %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, index, len, ret);
    }
}

static inline void trace_usb_desc_config(int addr, int index, int len, int ret)
{
    if (true) {
        _nocheck__trace_usb_desc_config(addr, index, len, ret);
    }
}

#define TRACE_USB_DESC_OTHER_SPEED_CONFIG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DESC_OTHER_SPEED_CONFIG) || \
    false)

static inline void _nocheck__trace_usb_desc_other_speed_config(int addr, int index, int len, int ret)
{
    if (trace_event_get_state(TRACE_USB_DESC_OTHER_SPEED_CONFIG) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_desc_other_speed_config " "dev %d query config %d, len %d, ret %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, index, len, ret);
    }
}

static inline void trace_usb_desc_other_speed_config(int addr, int index, int len, int ret)
{
    if (true) {
        _nocheck__trace_usb_desc_other_speed_config(addr, index, len, ret);
    }
}

#define TRACE_USB_DESC_STRING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DESC_STRING) || \
    false)

static inline void _nocheck__trace_usb_desc_string(int addr, int index, int len, int ret)
{
    if (trace_event_get_state(TRACE_USB_DESC_STRING) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_desc_string " "dev %d query string %d, len %d, ret %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, index, len, ret);
    }
}

static inline void trace_usb_desc_string(int addr, int index, int len, int ret)
{
    if (true) {
        _nocheck__trace_usb_desc_string(addr, index, len, ret);
    }
}

#define TRACE_USB_DESC_BOS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DESC_BOS) || \
    false)

static inline void _nocheck__trace_usb_desc_bos(int addr, int len, int ret)
{
    if (trace_event_get_state(TRACE_USB_DESC_BOS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_desc_bos " "dev %d bos, len %d, ret %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, len, ret);
    }
}

static inline void trace_usb_desc_bos(int addr, int len, int ret)
{
    if (true) {
        _nocheck__trace_usb_desc_bos(addr, len, ret);
    }
}

#define TRACE_USB_DESC_MSOS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_DESC_MSOS) || \
    false)

static inline void _nocheck__trace_usb_desc_msos(int addr, int index, int len, int ret)
{
    if (trace_event_get_state(TRACE_USB_DESC_MSOS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_desc_msos " "dev %d msos, index 0x%x, len %d, ret %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, index, len, ret);
    }
}

static inline void trace_usb_desc_msos(int addr, int index, int len, int ret)
{
    if (true) {
        _nocheck__trace_usb_desc_msos(addr, index, len, ret);
    }
}

#define TRACE_USB_SET_ADDR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_SET_ADDR) || \
    false)

static inline void _nocheck__trace_usb_set_addr(int addr)
{
    if (trace_event_get_state(TRACE_USB_SET_ADDR) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_set_addr " "dev %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr);
    }
}

static inline void trace_usb_set_addr(int addr)
{
    if (true) {
        _nocheck__trace_usb_set_addr(addr);
    }
}

#define TRACE_USB_SET_CONFIG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_SET_CONFIG) || \
    false)

static inline void _nocheck__trace_usb_set_config(int addr, int config, int ret)
{
    if (trace_event_get_state(TRACE_USB_SET_CONFIG) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_set_config " "dev %d, config %d, ret %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, config, ret);
    }
}

static inline void trace_usb_set_config(int addr, int config, int ret)
{
    if (true) {
        _nocheck__trace_usb_set_config(addr, config, ret);
    }
}

#define TRACE_USB_SET_INTERFACE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_SET_INTERFACE) || \
    false)

static inline void _nocheck__trace_usb_set_interface(int addr, int iface, int alt, int ret)
{
    if (trace_event_get_state(TRACE_USB_SET_INTERFACE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_set_interface " "dev %d, interface %d, altsetting %d, ret %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, iface, alt, ret);
    }
}

static inline void trace_usb_set_interface(int addr, int iface, int alt, int ret)
{
    if (true) {
        _nocheck__trace_usb_set_interface(addr, iface, alt, ret);
    }
}

#define TRACE_USB_CLEAR_DEVICE_FEATURE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_CLEAR_DEVICE_FEATURE) || \
    false)

static inline void _nocheck__trace_usb_clear_device_feature(int addr, int feature, int ret)
{
    if (trace_event_get_state(TRACE_USB_CLEAR_DEVICE_FEATURE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_clear_device_feature " "dev %d, feature %d, ret %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, feature, ret);
    }
}

static inline void trace_usb_clear_device_feature(int addr, int feature, int ret)
{
    if (true) {
        _nocheck__trace_usb_clear_device_feature(addr, feature, ret);
    }
}

#define TRACE_USB_SET_DEVICE_FEATURE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_SET_DEVICE_FEATURE) || \
    false)

static inline void _nocheck__trace_usb_set_device_feature(int addr, int feature, int ret)
{
    if (trace_event_get_state(TRACE_USB_SET_DEVICE_FEATURE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_set_device_feature " "dev %d, feature %d, ret %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, feature, ret);
    }
}

static inline void trace_usb_set_device_feature(int addr, int feature, int ret)
{
    if (true) {
        _nocheck__trace_usb_set_device_feature(addr, feature, ret);
    }
}

#define TRACE_USB_HUB_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_HUB_RESET) || \
    false)

static inline void _nocheck__trace_usb_hub_reset(int addr)
{
    if (trace_event_get_state(TRACE_USB_HUB_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_hub_reset " "dev %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr);
    }
}

static inline void trace_usb_hub_reset(int addr)
{
    if (true) {
        _nocheck__trace_usb_hub_reset(addr);
    }
}

#define TRACE_USB_HUB_CONTROL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_HUB_CONTROL) || \
    false)

static inline void _nocheck__trace_usb_hub_control(int addr, int request, int value, int index, int length)
{
    if (trace_event_get_state(TRACE_USB_HUB_CONTROL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_hub_control " "dev %d, req 0x%x, value %d, index %d, langth %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, request, value, index, length);
    }
}

static inline void trace_usb_hub_control(int addr, int request, int value, int index, int length)
{
    if (true) {
        _nocheck__trace_usb_hub_control(addr, request, value, index, length);
    }
}

#define TRACE_USB_HUB_GET_PORT_STATUS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_HUB_GET_PORT_STATUS) || \
    false)

static inline void _nocheck__trace_usb_hub_get_port_status(int addr, int nr, int status, int changed)
{
    if (trace_event_get_state(TRACE_USB_HUB_GET_PORT_STATUS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_hub_get_port_status " "dev %d, port %d, status 0x%x, changed 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, nr, status, changed);
    }
}

static inline void trace_usb_hub_get_port_status(int addr, int nr, int status, int changed)
{
    if (true) {
        _nocheck__trace_usb_hub_get_port_status(addr, nr, status, changed);
    }
}

#define TRACE_USB_HUB_SET_PORT_FEATURE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_HUB_SET_PORT_FEATURE) || \
    false)

static inline void _nocheck__trace_usb_hub_set_port_feature(int addr, int nr, const char * f)
{
    if (trace_event_get_state(TRACE_USB_HUB_SET_PORT_FEATURE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_hub_set_port_feature " "dev %d, port %d, feature %s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, nr, f);
    }
}

static inline void trace_usb_hub_set_port_feature(int addr, int nr, const char * f)
{
    if (true) {
        _nocheck__trace_usb_hub_set_port_feature(addr, nr, f);
    }
}

#define TRACE_USB_HUB_CLEAR_PORT_FEATURE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_HUB_CLEAR_PORT_FEATURE) || \
    false)

static inline void _nocheck__trace_usb_hub_clear_port_feature(int addr, int nr, const char * f)
{
    if (trace_event_get_state(TRACE_USB_HUB_CLEAR_PORT_FEATURE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_hub_clear_port_feature " "dev %d, port %d, feature %s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, nr, f);
    }
}

static inline void trace_usb_hub_clear_port_feature(int addr, int nr, const char * f)
{
    if (true) {
        _nocheck__trace_usb_hub_clear_port_feature(addr, nr, f);
    }
}

#define TRACE_USB_HUB_ATTACH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_HUB_ATTACH) || \
    false)

static inline void _nocheck__trace_usb_hub_attach(int addr, int nr)
{
    if (trace_event_get_state(TRACE_USB_HUB_ATTACH) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_hub_attach " "dev %d, port %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, nr);
    }
}

static inline void trace_usb_hub_attach(int addr, int nr)
{
    if (true) {
        _nocheck__trace_usb_hub_attach(addr, nr);
    }
}

#define TRACE_USB_HUB_DETACH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_HUB_DETACH) || \
    false)

static inline void _nocheck__trace_usb_hub_detach(int addr, int nr)
{
    if (trace_event_get_state(TRACE_USB_HUB_DETACH) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_hub_detach " "dev %d, port %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, nr);
    }
}

static inline void trace_usb_hub_detach(int addr, int nr)
{
    if (true) {
        _nocheck__trace_usb_hub_detach(addr, nr);
    }
}

#define TRACE_USB_HUB_STATUS_REPORT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_HUB_STATUS_REPORT) || \
    false)

static inline void _nocheck__trace_usb_hub_status_report(int addr, int status)
{
    if (trace_event_get_state(TRACE_USB_HUB_STATUS_REPORT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_hub_status_report " "dev %d, status 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, status);
    }
}

static inline void trace_usb_hub_status_report(int addr, int status)
{
    if (true) {
        _nocheck__trace_usb_hub_status_report(addr, status);
    }
}

#define TRACE_USB_MSD_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_MSD_RESET) || \
    false)

static inline void _nocheck__trace_usb_msd_reset(void)
{
    if (trace_event_get_state(TRACE_USB_MSD_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_msd_reset " "" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_msd_reset(void)
{
    if (true) {
        _nocheck__trace_usb_msd_reset();
    }
}

#define TRACE_USB_MSD_MAXLUN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_MSD_MAXLUN) || \
    false)

static inline void _nocheck__trace_usb_msd_maxlun(unsigned maxlun)
{
    if (trace_event_get_state(TRACE_USB_MSD_MAXLUN) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_msd_maxlun " "%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , maxlun);
    }
}

static inline void trace_usb_msd_maxlun(unsigned maxlun)
{
    if (true) {
        _nocheck__trace_usb_msd_maxlun(maxlun);
    }
}

#define TRACE_USB_MSD_SEND_STATUS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_MSD_SEND_STATUS) || \
    false)

static inline void _nocheck__trace_usb_msd_send_status(unsigned status, unsigned tag, size_t size)
{
    if (trace_event_get_state(TRACE_USB_MSD_SEND_STATUS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_msd_send_status " "status %d, tag 0x%x, len %zd" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , status, tag, size);
    }
}

static inline void trace_usb_msd_send_status(unsigned status, unsigned tag, size_t size)
{
    if (true) {
        _nocheck__trace_usb_msd_send_status(status, tag, size);
    }
}

#define TRACE_USB_MSD_DATA_IN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_MSD_DATA_IN) || \
    false)

static inline void _nocheck__trace_usb_msd_data_in(unsigned packet, unsigned remaining, unsigned total)
{
    if (trace_event_get_state(TRACE_USB_MSD_DATA_IN) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_msd_data_in " "%d/%d (scsi %d)" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , packet, remaining, total);
    }
}

static inline void trace_usb_msd_data_in(unsigned packet, unsigned remaining, unsigned total)
{
    if (true) {
        _nocheck__trace_usb_msd_data_in(packet, remaining, total);
    }
}

#define TRACE_USB_MSD_DATA_OUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_MSD_DATA_OUT) || \
    false)

static inline void _nocheck__trace_usb_msd_data_out(unsigned packet, unsigned remaining)
{
    if (trace_event_get_state(TRACE_USB_MSD_DATA_OUT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_msd_data_out " "%d/%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , packet, remaining);
    }
}

static inline void trace_usb_msd_data_out(unsigned packet, unsigned remaining)
{
    if (true) {
        _nocheck__trace_usb_msd_data_out(packet, remaining);
    }
}

#define TRACE_USB_MSD_PACKET_ASYNC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_MSD_PACKET_ASYNC) || \
    false)

static inline void _nocheck__trace_usb_msd_packet_async(void)
{
    if (trace_event_get_state(TRACE_USB_MSD_PACKET_ASYNC) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_msd_packet_async " "" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_msd_packet_async(void)
{
    if (true) {
        _nocheck__trace_usb_msd_packet_async();
    }
}

#define TRACE_USB_MSD_PACKET_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_MSD_PACKET_COMPLETE) || \
    false)

static inline void _nocheck__trace_usb_msd_packet_complete(void)
{
    if (trace_event_get_state(TRACE_USB_MSD_PACKET_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_msd_packet_complete " "" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_msd_packet_complete(void)
{
    if (true) {
        _nocheck__trace_usb_msd_packet_complete();
    }
}

#define TRACE_USB_MSD_CMD_SUBMIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_MSD_CMD_SUBMIT) || \
    false)

static inline void _nocheck__trace_usb_msd_cmd_submit(unsigned lun, unsigned tag, unsigned flags, unsigned len, unsigned data_len)
{
    if (trace_event_get_state(TRACE_USB_MSD_CMD_SUBMIT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_msd_cmd_submit " "lun %u, tag 0x%x, flags 0x%08x, len %d, data-len %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , lun, tag, flags, len, data_len);
    }
}

static inline void trace_usb_msd_cmd_submit(unsigned lun, unsigned tag, unsigned flags, unsigned len, unsigned data_len)
{
    if (true) {
        _nocheck__trace_usb_msd_cmd_submit(lun, tag, flags, len, data_len);
    }
}

#define TRACE_USB_MSD_CMD_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_MSD_CMD_COMPLETE) || \
    false)

static inline void _nocheck__trace_usb_msd_cmd_complete(unsigned status, unsigned tag)
{
    if (trace_event_get_state(TRACE_USB_MSD_CMD_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_msd_cmd_complete " "status %d, tag 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , status, tag);
    }
}

static inline void trace_usb_msd_cmd_complete(unsigned status, unsigned tag)
{
    if (true) {
        _nocheck__trace_usb_msd_cmd_complete(status, tag);
    }
}

#define TRACE_USB_MSD_CMD_CANCEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_MSD_CMD_CANCEL) || \
    false)

static inline void _nocheck__trace_usb_msd_cmd_cancel(unsigned tag)
{
    if (trace_event_get_state(TRACE_USB_MSD_CMD_CANCEL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_msd_cmd_cancel " "tag 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , tag);
    }
}

static inline void trace_usb_msd_cmd_cancel(unsigned tag)
{
    if (true) {
        _nocheck__trace_usb_msd_cmd_cancel(tag);
    }
}

#define TRACE_USB_UAS_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UAS_RESET) || \
    false)

static inline void _nocheck__trace_usb_uas_reset(int addr)
{
    if (trace_event_get_state(TRACE_USB_UAS_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uas_reset " "dev %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr);
    }
}

static inline void trace_usb_uas_reset(int addr)
{
    if (true) {
        _nocheck__trace_usb_uas_reset(addr);
    }
}

#define TRACE_USB_UAS_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UAS_COMMAND) || \
    false)

static inline void _nocheck__trace_usb_uas_command(int addr, uint16_t tag, int lun, uint32_t lun64_1, uint32_t lun64_2)
{
    if (trace_event_get_state(TRACE_USB_UAS_COMMAND) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uas_command " "dev %d, tag 0x%x, lun %d, lun64 0x%08x-0x%08x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, tag, lun, lun64_1, lun64_2);
    }
}

static inline void trace_usb_uas_command(int addr, uint16_t tag, int lun, uint32_t lun64_1, uint32_t lun64_2)
{
    if (true) {
        _nocheck__trace_usb_uas_command(addr, tag, lun, lun64_1, lun64_2);
    }
}

#define TRACE_USB_UAS_RESPONSE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UAS_RESPONSE) || \
    false)

static inline void _nocheck__trace_usb_uas_response(int addr, uint16_t tag, uint8_t code)
{
    if (trace_event_get_state(TRACE_USB_UAS_RESPONSE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uas_response " "dev %d, tag 0x%x, code 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, tag, code);
    }
}

static inline void trace_usb_uas_response(int addr, uint16_t tag, uint8_t code)
{
    if (true) {
        _nocheck__trace_usb_uas_response(addr, tag, code);
    }
}

#define TRACE_USB_UAS_SENSE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UAS_SENSE) || \
    false)

static inline void _nocheck__trace_usb_uas_sense(int addr, uint16_t tag, uint8_t status)
{
    if (trace_event_get_state(TRACE_USB_UAS_SENSE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uas_sense " "dev %d, tag 0x%x, status 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, tag, status);
    }
}

static inline void trace_usb_uas_sense(int addr, uint16_t tag, uint8_t status)
{
    if (true) {
        _nocheck__trace_usb_uas_sense(addr, tag, status);
    }
}

#define TRACE_USB_UAS_READ_READY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UAS_READ_READY) || \
    false)

static inline void _nocheck__trace_usb_uas_read_ready(int addr, uint16_t tag)
{
    if (trace_event_get_state(TRACE_USB_UAS_READ_READY) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uas_read_ready " "dev %d, tag 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, tag);
    }
}

static inline void trace_usb_uas_read_ready(int addr, uint16_t tag)
{
    if (true) {
        _nocheck__trace_usb_uas_read_ready(addr, tag);
    }
}

#define TRACE_USB_UAS_WRITE_READY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UAS_WRITE_READY) || \
    false)

static inline void _nocheck__trace_usb_uas_write_ready(int addr, uint16_t tag)
{
    if (trace_event_get_state(TRACE_USB_UAS_WRITE_READY) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uas_write_ready " "dev %d, tag 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, tag);
    }
}

static inline void trace_usb_uas_write_ready(int addr, uint16_t tag)
{
    if (true) {
        _nocheck__trace_usb_uas_write_ready(addr, tag);
    }
}

#define TRACE_USB_UAS_XFER_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UAS_XFER_DATA) || \
    false)

static inline void _nocheck__trace_usb_uas_xfer_data(int addr, uint16_t tag, uint32_t copy, uint32_t uoff, uint32_t usize, uint32_t soff, uint32_t ssize)
{
    if (trace_event_get_state(TRACE_USB_UAS_XFER_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uas_xfer_data " "dev %d, tag 0x%x, copy %d, usb-pkt %d/%d, scsi-buf %d/%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, tag, copy, uoff, usize, soff, ssize);
    }
}

static inline void trace_usb_uas_xfer_data(int addr, uint16_t tag, uint32_t copy, uint32_t uoff, uint32_t usize, uint32_t soff, uint32_t ssize)
{
    if (true) {
        _nocheck__trace_usb_uas_xfer_data(addr, tag, copy, uoff, usize, soff, ssize);
    }
}

#define TRACE_USB_UAS_SCSI_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UAS_SCSI_DATA) || \
    false)

static inline void _nocheck__trace_usb_uas_scsi_data(int addr, uint16_t tag, uint32_t bytes)
{
    if (trace_event_get_state(TRACE_USB_UAS_SCSI_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uas_scsi_data " "dev %d, tag 0x%x, bytes %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, tag, bytes);
    }
}

static inline void trace_usb_uas_scsi_data(int addr, uint16_t tag, uint32_t bytes)
{
    if (true) {
        _nocheck__trace_usb_uas_scsi_data(addr, tag, bytes);
    }
}

#define TRACE_USB_UAS_SCSI_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UAS_SCSI_COMPLETE) || \
    false)

static inline void _nocheck__trace_usb_uas_scsi_complete(int addr, uint16_t tag, uint32_t status, uint32_t resid)
{
    if (trace_event_get_state(TRACE_USB_UAS_SCSI_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uas_scsi_complete " "dev %d, tag 0x%x, status 0x%x, residue %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, tag, status, resid);
    }
}

static inline void trace_usb_uas_scsi_complete(int addr, uint16_t tag, uint32_t status, uint32_t resid)
{
    if (true) {
        _nocheck__trace_usb_uas_scsi_complete(addr, tag, status, resid);
    }
}

#define TRACE_USB_UAS_TMF_ABORT_TASK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UAS_TMF_ABORT_TASK) || \
    false)

static inline void _nocheck__trace_usb_uas_tmf_abort_task(int addr, uint16_t tag, uint16_t task_tag)
{
    if (trace_event_get_state(TRACE_USB_UAS_TMF_ABORT_TASK) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uas_tmf_abort_task " "dev %d, tag 0x%x, task-tag 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, tag, task_tag);
    }
}

static inline void trace_usb_uas_tmf_abort_task(int addr, uint16_t tag, uint16_t task_tag)
{
    if (true) {
        _nocheck__trace_usb_uas_tmf_abort_task(addr, tag, task_tag);
    }
}

#define TRACE_USB_UAS_TMF_LOGICAL_UNIT_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UAS_TMF_LOGICAL_UNIT_RESET) || \
    false)

static inline void _nocheck__trace_usb_uas_tmf_logical_unit_reset(int addr, uint16_t tag, int lun)
{
    if (trace_event_get_state(TRACE_USB_UAS_TMF_LOGICAL_UNIT_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uas_tmf_logical_unit_reset " "dev %d, tag 0x%x, lun %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, tag, lun);
    }
}

static inline void trace_usb_uas_tmf_logical_unit_reset(int addr, uint16_t tag, int lun)
{
    if (true) {
        _nocheck__trace_usb_uas_tmf_logical_unit_reset(addr, tag, lun);
    }
}

#define TRACE_USB_UAS_TMF_UNSUPPORTED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_UAS_TMF_UNSUPPORTED) || \
    false)

static inline void _nocheck__trace_usb_uas_tmf_unsupported(int addr, uint16_t tag, uint32_t function)
{
    if (trace_event_get_state(TRACE_USB_UAS_TMF_UNSUPPORTED) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_uas_tmf_unsupported " "dev %d, tag 0x%x, function 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, tag, function);
    }
}

static inline void trace_usb_uas_tmf_unsupported(int addr, uint16_t tag, uint32_t function)
{
    if (true) {
        _nocheck__trace_usb_uas_tmf_unsupported(addr, tag, function);
    }
}

#define TRACE_USB_MTP_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_MTP_RESET) || \
    false)

static inline void _nocheck__trace_usb_mtp_reset(int addr)
{
    if (trace_event_get_state(TRACE_USB_MTP_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_mtp_reset " "dev %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr);
    }
}

static inline void trace_usb_mtp_reset(int addr)
{
    if (true) {
        _nocheck__trace_usb_mtp_reset(addr);
    }
}

#define TRACE_USB_MTP_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_MTP_COMMAND) || \
    false)

static inline void _nocheck__trace_usb_mtp_command(int dev, uint16_t code, uint32_t trans, uint32_t arg0, uint32_t arg1, uint32_t arg2, uint32_t arg3, uint32_t arg4)
{
    if (trace_event_get_state(TRACE_USB_MTP_COMMAND) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_mtp_command " "dev %d, code 0x%x, trans 0x%x, args 0x%x, 0x%x, 0x%x, 0x%x, 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , dev, code, trans, arg0, arg1, arg2, arg3, arg4);
    }
}

static inline void trace_usb_mtp_command(int dev, uint16_t code, uint32_t trans, uint32_t arg0, uint32_t arg1, uint32_t arg2, uint32_t arg3, uint32_t arg4)
{
    if (true) {
        _nocheck__trace_usb_mtp_command(dev, code, trans, arg0, arg1, arg2, arg3, arg4);
    }
}

#define TRACE_USB_MTP_SUCCESS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_MTP_SUCCESS) || \
    false)

static inline void _nocheck__trace_usb_mtp_success(int dev, uint32_t trans, uint32_t arg0, uint32_t arg1)
{
    if (trace_event_get_state(TRACE_USB_MTP_SUCCESS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_mtp_success " "dev %d, trans 0x%x, args 0x%x, 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , dev, trans, arg0, arg1);
    }
}

static inline void trace_usb_mtp_success(int dev, uint32_t trans, uint32_t arg0, uint32_t arg1)
{
    if (true) {
        _nocheck__trace_usb_mtp_success(dev, trans, arg0, arg1);
    }
}

#define TRACE_USB_MTP_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_MTP_ERROR) || \
    false)

static inline void _nocheck__trace_usb_mtp_error(int dev, uint16_t code, uint32_t trans, uint32_t arg0, uint32_t arg1)
{
    if (trace_event_get_state(TRACE_USB_MTP_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_mtp_error " "dev %d, code 0x%x, trans 0x%x, args 0x%x, 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , dev, code, trans, arg0, arg1);
    }
}

static inline void trace_usb_mtp_error(int dev, uint16_t code, uint32_t trans, uint32_t arg0, uint32_t arg1)
{
    if (true) {
        _nocheck__trace_usb_mtp_error(dev, code, trans, arg0, arg1);
    }
}

#define TRACE_USB_MTP_DATA_IN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_MTP_DATA_IN) || \
    false)

static inline void _nocheck__trace_usb_mtp_data_in(int dev, uint32_t trans, uint32_t len)
{
    if (trace_event_get_state(TRACE_USB_MTP_DATA_IN) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_mtp_data_in " "dev %d, trans 0x%x, len %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , dev, trans, len);
    }
}

static inline void trace_usb_mtp_data_in(int dev, uint32_t trans, uint32_t len)
{
    if (true) {
        _nocheck__trace_usb_mtp_data_in(dev, trans, len);
    }
}

#define TRACE_USB_MTP_XFER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_MTP_XFER) || \
    false)

static inline void _nocheck__trace_usb_mtp_xfer(int dev, uint32_t ep, uint32_t dlen, uint32_t plen)
{
    if (trace_event_get_state(TRACE_USB_MTP_XFER) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_mtp_xfer " "dev %d, ep %d, %d/%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , dev, ep, dlen, plen);
    }
}

static inline void trace_usb_mtp_xfer(int dev, uint32_t ep, uint32_t dlen, uint32_t plen)
{
    if (true) {
        _nocheck__trace_usb_mtp_xfer(dev, ep, dlen, plen);
    }
}

#define TRACE_USB_MTP_NAK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_MTP_NAK) || \
    false)

static inline void _nocheck__trace_usb_mtp_nak(int dev, uint32_t ep)
{
    if (trace_event_get_state(TRACE_USB_MTP_NAK) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_mtp_nak " "dev %d, ep %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , dev, ep);
    }
}

static inline void trace_usb_mtp_nak(int dev, uint32_t ep)
{
    if (true) {
        _nocheck__trace_usb_mtp_nak(dev, ep);
    }
}

#define TRACE_USB_MTP_STALL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_MTP_STALL) || \
    false)

static inline void _nocheck__trace_usb_mtp_stall(int dev, const char * reason)
{
    if (trace_event_get_state(TRACE_USB_MTP_STALL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_mtp_stall " "dev %d, reason: %s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , dev, reason);
    }
}

static inline void trace_usb_mtp_stall(int dev, const char * reason)
{
    if (true) {
        _nocheck__trace_usb_mtp_stall(dev, reason);
    }
}

#define TRACE_USB_MTP_OP_GET_DEVICE_INFO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_MTP_OP_GET_DEVICE_INFO) || \
    false)

static inline void _nocheck__trace_usb_mtp_op_get_device_info(int dev)
{
    if (trace_event_get_state(TRACE_USB_MTP_OP_GET_DEVICE_INFO) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_mtp_op_get_device_info " "dev %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , dev);
    }
}

static inline void trace_usb_mtp_op_get_device_info(int dev)
{
    if (true) {
        _nocheck__trace_usb_mtp_op_get_device_info(dev);
    }
}

#define TRACE_USB_MTP_OP_OPEN_SESSION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_MTP_OP_OPEN_SESSION) || \
    false)

static inline void _nocheck__trace_usb_mtp_op_open_session(int dev)
{
    if (trace_event_get_state(TRACE_USB_MTP_OP_OPEN_SESSION) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_mtp_op_open_session " "dev %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , dev);
    }
}

static inline void trace_usb_mtp_op_open_session(int dev)
{
    if (true) {
        _nocheck__trace_usb_mtp_op_open_session(dev);
    }
}

#define TRACE_USB_MTP_OP_CLOSE_SESSION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_MTP_OP_CLOSE_SESSION) || \
    false)

static inline void _nocheck__trace_usb_mtp_op_close_session(int dev)
{
    if (trace_event_get_state(TRACE_USB_MTP_OP_CLOSE_SESSION) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_mtp_op_close_session " "dev %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , dev);
    }
}

static inline void trace_usb_mtp_op_close_session(int dev)
{
    if (true) {
        _nocheck__trace_usb_mtp_op_close_session(dev);
    }
}

#define TRACE_USB_MTP_OP_GET_STORAGE_IDS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_MTP_OP_GET_STORAGE_IDS) || \
    false)

static inline void _nocheck__trace_usb_mtp_op_get_storage_ids(int dev)
{
    if (trace_event_get_state(TRACE_USB_MTP_OP_GET_STORAGE_IDS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_mtp_op_get_storage_ids " "dev %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , dev);
    }
}

static inline void trace_usb_mtp_op_get_storage_ids(int dev)
{
    if (true) {
        _nocheck__trace_usb_mtp_op_get_storage_ids(dev);
    }
}

#define TRACE_USB_MTP_OP_GET_STORAGE_INFO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_MTP_OP_GET_STORAGE_INFO) || \
    false)

static inline void _nocheck__trace_usb_mtp_op_get_storage_info(int dev)
{
    if (trace_event_get_state(TRACE_USB_MTP_OP_GET_STORAGE_INFO) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_mtp_op_get_storage_info " "dev %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , dev);
    }
}

static inline void trace_usb_mtp_op_get_storage_info(int dev)
{
    if (true) {
        _nocheck__trace_usb_mtp_op_get_storage_info(dev);
    }
}

#define TRACE_USB_MTP_OP_GET_NUM_OBJECTS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_MTP_OP_GET_NUM_OBJECTS) || \
    false)

static inline void _nocheck__trace_usb_mtp_op_get_num_objects(int dev, uint32_t handle, const char * path)
{
    if (trace_event_get_state(TRACE_USB_MTP_OP_GET_NUM_OBJECTS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_mtp_op_get_num_objects " "dev %d, handle 0x%x, path %s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , dev, handle, path);
    }
}

static inline void trace_usb_mtp_op_get_num_objects(int dev, uint32_t handle, const char * path)
{
    if (true) {
        _nocheck__trace_usb_mtp_op_get_num_objects(dev, handle, path);
    }
}

#define TRACE_USB_MTP_OP_GET_OBJECT_HANDLES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_MTP_OP_GET_OBJECT_HANDLES) || \
    false)

static inline void _nocheck__trace_usb_mtp_op_get_object_handles(int dev, uint32_t handle, const char * path)
{
    if (trace_event_get_state(TRACE_USB_MTP_OP_GET_OBJECT_HANDLES) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_mtp_op_get_object_handles " "dev %d, handle 0x%x, path %s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , dev, handle, path);
    }
}

static inline void trace_usb_mtp_op_get_object_handles(int dev, uint32_t handle, const char * path)
{
    if (true) {
        _nocheck__trace_usb_mtp_op_get_object_handles(dev, handle, path);
    }
}

#define TRACE_USB_MTP_OP_GET_OBJECT_INFO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_MTP_OP_GET_OBJECT_INFO) || \
    false)

static inline void _nocheck__trace_usb_mtp_op_get_object_info(int dev, uint32_t handle, const char * path)
{
    if (trace_event_get_state(TRACE_USB_MTP_OP_GET_OBJECT_INFO) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_mtp_op_get_object_info " "dev %d, handle 0x%x, path %s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , dev, handle, path);
    }
}

static inline void trace_usb_mtp_op_get_object_info(int dev, uint32_t handle, const char * path)
{
    if (true) {
        _nocheck__trace_usb_mtp_op_get_object_info(dev, handle, path);
    }
}

#define TRACE_USB_MTP_OP_GET_OBJECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_MTP_OP_GET_OBJECT) || \
    false)

static inline void _nocheck__trace_usb_mtp_op_get_object(int dev, uint32_t handle, const char * path)
{
    if (trace_event_get_state(TRACE_USB_MTP_OP_GET_OBJECT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_mtp_op_get_object " "dev %d, handle 0x%x, path %s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , dev, handle, path);
    }
}

static inline void trace_usb_mtp_op_get_object(int dev, uint32_t handle, const char * path)
{
    if (true) {
        _nocheck__trace_usb_mtp_op_get_object(dev, handle, path);
    }
}

#define TRACE_USB_MTP_OP_GET_PARTIAL_OBJECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_MTP_OP_GET_PARTIAL_OBJECT) || \
    false)

static inline void _nocheck__trace_usb_mtp_op_get_partial_object(int dev, uint32_t handle, const char * path, uint32_t offset, uint32_t length)
{
    if (trace_event_get_state(TRACE_USB_MTP_OP_GET_PARTIAL_OBJECT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_mtp_op_get_partial_object " "dev %d, handle 0x%x, path %s, off %d, len %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , dev, handle, path, offset, length);
    }
}

static inline void trace_usb_mtp_op_get_partial_object(int dev, uint32_t handle, const char * path, uint32_t offset, uint32_t length)
{
    if (true) {
        _nocheck__trace_usb_mtp_op_get_partial_object(dev, handle, path, offset, length);
    }
}

#define TRACE_USB_MTP_OP_UNKNOWN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_MTP_OP_UNKNOWN) || \
    false)

static inline void _nocheck__trace_usb_mtp_op_unknown(int dev, uint32_t code)
{
    if (trace_event_get_state(TRACE_USB_MTP_OP_UNKNOWN) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_mtp_op_unknown " "dev %d, command code 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , dev, code);
    }
}

static inline void trace_usb_mtp_op_unknown(int dev, uint32_t code)
{
    if (true) {
        _nocheck__trace_usb_mtp_op_unknown(dev, code);
    }
}

#define TRACE_USB_MTP_OBJECT_ALLOC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_MTP_OBJECT_ALLOC) || \
    false)

static inline void _nocheck__trace_usb_mtp_object_alloc(int dev, uint32_t handle, const char * path)
{
    if (trace_event_get_state(TRACE_USB_MTP_OBJECT_ALLOC) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_mtp_object_alloc " "dev %d, handle 0x%x, path %s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , dev, handle, path);
    }
}

static inline void trace_usb_mtp_object_alloc(int dev, uint32_t handle, const char * path)
{
    if (true) {
        _nocheck__trace_usb_mtp_object_alloc(dev, handle, path);
    }
}

#define TRACE_USB_MTP_OBJECT_FREE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_MTP_OBJECT_FREE) || \
    false)

static inline void _nocheck__trace_usb_mtp_object_free(int dev, uint32_t handle, const char * path)
{
    if (trace_event_get_state(TRACE_USB_MTP_OBJECT_FREE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_mtp_object_free " "dev %d, handle 0x%x, path %s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , dev, handle, path);
    }
}

static inline void trace_usb_mtp_object_free(int dev, uint32_t handle, const char * path)
{
    if (true) {
        _nocheck__trace_usb_mtp_object_free(dev, handle, path);
    }
}

#define TRACE_USB_MTP_ADD_CHILD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_MTP_ADD_CHILD) || \
    false)

static inline void _nocheck__trace_usb_mtp_add_child(int dev, uint32_t handle, const char * path)
{
    if (trace_event_get_state(TRACE_USB_MTP_ADD_CHILD) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_mtp_add_child " "dev %d, handle 0x%x, path %s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , dev, handle, path);
    }
}

static inline void trace_usb_mtp_add_child(int dev, uint32_t handle, const char * path)
{
    if (true) {
        _nocheck__trace_usb_mtp_add_child(dev, handle, path);
    }
}

#define TRACE_USB_MTP_FILE_MONITOR_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_MTP_FILE_MONITOR_EVENT) || \
    false)

static inline void _nocheck__trace_usb_mtp_file_monitor_event(int dev, const char * path, const char * s)
{
    if (trace_event_get_state(TRACE_USB_MTP_FILE_MONITOR_EVENT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_mtp_file_monitor_event " "dev %d, path %s event %s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , dev, path, s);
    }
}

static inline void trace_usb_mtp_file_monitor_event(int dev, const char * path, const char * s)
{
    if (true) {
        _nocheck__trace_usb_mtp_file_monitor_event(dev, path, s);
    }
}

#define TRACE_USB_HOST_OPEN_STARTED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_HOST_OPEN_STARTED) || \
    false)

static inline void _nocheck__trace_usb_host_open_started(int bus, int addr)
{
    if (trace_event_get_state(TRACE_USB_HOST_OPEN_STARTED) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_host_open_started " "dev %d:%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, addr);
    }
}

static inline void trace_usb_host_open_started(int bus, int addr)
{
    if (true) {
        _nocheck__trace_usb_host_open_started(bus, addr);
    }
}

#define TRACE_USB_HOST_OPEN_HOSTFD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_HOST_OPEN_HOSTFD) || \
    false)

static inline void _nocheck__trace_usb_host_open_hostfd(int hostfd)
{
    if (trace_event_get_state(TRACE_USB_HOST_OPEN_HOSTFD) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_host_open_hostfd " "hostfd %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , hostfd);
    }
}

static inline void trace_usb_host_open_hostfd(int hostfd)
{
    if (true) {
        _nocheck__trace_usb_host_open_hostfd(hostfd);
    }
}

#define TRACE_USB_HOST_OPEN_SUCCESS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_HOST_OPEN_SUCCESS) || \
    false)

static inline void _nocheck__trace_usb_host_open_success(int bus, int addr)
{
    if (trace_event_get_state(TRACE_USB_HOST_OPEN_SUCCESS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_host_open_success " "dev %d:%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, addr);
    }
}

static inline void trace_usb_host_open_success(int bus, int addr)
{
    if (true) {
        _nocheck__trace_usb_host_open_success(bus, addr);
    }
}

#define TRACE_USB_HOST_OPEN_FAILURE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_HOST_OPEN_FAILURE) || \
    false)

static inline void _nocheck__trace_usb_host_open_failure(int bus, int addr)
{
    if (trace_event_get_state(TRACE_USB_HOST_OPEN_FAILURE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_host_open_failure " "dev %d:%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, addr);
    }
}

static inline void trace_usb_host_open_failure(int bus, int addr)
{
    if (true) {
        _nocheck__trace_usb_host_open_failure(bus, addr);
    }
}

#define TRACE_USB_HOST_CLOSE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_HOST_CLOSE) || \
    false)

static inline void _nocheck__trace_usb_host_close(int bus, int addr)
{
    if (trace_event_get_state(TRACE_USB_HOST_CLOSE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_host_close " "dev %d:%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, addr);
    }
}

static inline void trace_usb_host_close(int bus, int addr)
{
    if (true) {
        _nocheck__trace_usb_host_close(bus, addr);
    }
}

#define TRACE_USB_HOST_ATTACH_KERNEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_HOST_ATTACH_KERNEL) || \
    false)

static inline void _nocheck__trace_usb_host_attach_kernel(int bus, int addr, int interface)
{
    if (trace_event_get_state(TRACE_USB_HOST_ATTACH_KERNEL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_host_attach_kernel " "dev %d:%d, if %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, addr, interface);
    }
}

static inline void trace_usb_host_attach_kernel(int bus, int addr, int interface)
{
    if (true) {
        _nocheck__trace_usb_host_attach_kernel(bus, addr, interface);
    }
}

#define TRACE_USB_HOST_DETACH_KERNEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_HOST_DETACH_KERNEL) || \
    false)

static inline void _nocheck__trace_usb_host_detach_kernel(int bus, int addr, int interface)
{
    if (trace_event_get_state(TRACE_USB_HOST_DETACH_KERNEL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_host_detach_kernel " "dev %d:%d, if %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, addr, interface);
    }
}

static inline void trace_usb_host_detach_kernel(int bus, int addr, int interface)
{
    if (true) {
        _nocheck__trace_usb_host_detach_kernel(bus, addr, interface);
    }
}

#define TRACE_USB_HOST_SET_ADDRESS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_HOST_SET_ADDRESS) || \
    false)

static inline void _nocheck__trace_usb_host_set_address(int bus, int addr, int config)
{
    if (trace_event_get_state(TRACE_USB_HOST_SET_ADDRESS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_host_set_address " "dev %d:%d, address %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, addr, config);
    }
}

static inline void trace_usb_host_set_address(int bus, int addr, int config)
{
    if (true) {
        _nocheck__trace_usb_host_set_address(bus, addr, config);
    }
}

#define TRACE_USB_HOST_SET_CONFIG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_HOST_SET_CONFIG) || \
    false)

static inline void _nocheck__trace_usb_host_set_config(int bus, int addr, int config)
{
    if (trace_event_get_state(TRACE_USB_HOST_SET_CONFIG) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_host_set_config " "dev %d:%d, config %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, addr, config);
    }
}

static inline void trace_usb_host_set_config(int bus, int addr, int config)
{
    if (true) {
        _nocheck__trace_usb_host_set_config(bus, addr, config);
    }
}

#define TRACE_USB_HOST_SET_INTERFACE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_HOST_SET_INTERFACE) || \
    false)

static inline void _nocheck__trace_usb_host_set_interface(int bus, int addr, int interface, int alt)
{
    if (trace_event_get_state(TRACE_USB_HOST_SET_INTERFACE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_host_set_interface " "dev %d:%d, interface %d, alt %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, addr, interface, alt);
    }
}

static inline void trace_usb_host_set_interface(int bus, int addr, int interface, int alt)
{
    if (true) {
        _nocheck__trace_usb_host_set_interface(bus, addr, interface, alt);
    }
}

#define TRACE_USB_HOST_CLAIM_INTERFACE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_HOST_CLAIM_INTERFACE) || \
    false)

static inline void _nocheck__trace_usb_host_claim_interface(int bus, int addr, int config, int interface)
{
    if (trace_event_get_state(TRACE_USB_HOST_CLAIM_INTERFACE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_host_claim_interface " "dev %d:%d, config %d, if %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, addr, config, interface);
    }
}

static inline void trace_usb_host_claim_interface(int bus, int addr, int config, int interface)
{
    if (true) {
        _nocheck__trace_usb_host_claim_interface(bus, addr, config, interface);
    }
}

#define TRACE_USB_HOST_RELEASE_INTERFACE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_HOST_RELEASE_INTERFACE) || \
    false)

static inline void _nocheck__trace_usb_host_release_interface(int bus, int addr, int interface)
{
    if (trace_event_get_state(TRACE_USB_HOST_RELEASE_INTERFACE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_host_release_interface " "dev %d:%d, if %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, addr, interface);
    }
}

static inline void trace_usb_host_release_interface(int bus, int addr, int interface)
{
    if (true) {
        _nocheck__trace_usb_host_release_interface(bus, addr, interface);
    }
}

#define TRACE_USB_HOST_REQ_CONTROL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_HOST_REQ_CONTROL) || \
    false)

static inline void _nocheck__trace_usb_host_req_control(int bus, int addr, void * p, int req, int value, int index)
{
    if (trace_event_get_state(TRACE_USB_HOST_REQ_CONTROL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_host_req_control " "dev %d:%d, packet %p, req 0x%x, value %d, index %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, addr, p, req, value, index);
    }
}

static inline void trace_usb_host_req_control(int bus, int addr, void * p, int req, int value, int index)
{
    if (true) {
        _nocheck__trace_usb_host_req_control(bus, addr, p, req, value, index);
    }
}

#define TRACE_USB_HOST_REQ_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_HOST_REQ_DATA) || \
    false)

static inline void _nocheck__trace_usb_host_req_data(int bus, int addr, void * p, int in, int ep, int size)
{
    if (trace_event_get_state(TRACE_USB_HOST_REQ_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_host_req_data " "dev %d:%d, packet %p, in %d, ep %d, size %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, addr, p, in, ep, size);
    }
}

static inline void trace_usb_host_req_data(int bus, int addr, void * p, int in, int ep, int size)
{
    if (true) {
        _nocheck__trace_usb_host_req_data(bus, addr, p, in, ep, size);
    }
}

#define TRACE_USB_HOST_REQ_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_HOST_REQ_COMPLETE) || \
    false)

static inline void _nocheck__trace_usb_host_req_complete(int bus, int addr, void * p, int status, int length)
{
    if (trace_event_get_state(TRACE_USB_HOST_REQ_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_host_req_complete " "dev %d:%d, packet %p, status %d, length %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, addr, p, status, length);
    }
}

static inline void trace_usb_host_req_complete(int bus, int addr, void * p, int status, int length)
{
    if (true) {
        _nocheck__trace_usb_host_req_complete(bus, addr, p, status, length);
    }
}

#define TRACE_USB_HOST_REQ_EMULATED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_HOST_REQ_EMULATED) || \
    false)

static inline void _nocheck__trace_usb_host_req_emulated(int bus, int addr, void * p, int status)
{
    if (trace_event_get_state(TRACE_USB_HOST_REQ_EMULATED) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_host_req_emulated " "dev %d:%d, packet %p, status %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, addr, p, status);
    }
}

static inline void trace_usb_host_req_emulated(int bus, int addr, void * p, int status)
{
    if (true) {
        _nocheck__trace_usb_host_req_emulated(bus, addr, p, status);
    }
}

#define TRACE_USB_HOST_REQ_CANCELED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_HOST_REQ_CANCELED) || \
    false)

static inline void _nocheck__trace_usb_host_req_canceled(int bus, int addr, void * p)
{
    if (trace_event_get_state(TRACE_USB_HOST_REQ_CANCELED) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_host_req_canceled " "dev %d:%d, packet %p" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, addr, p);
    }
}

static inline void trace_usb_host_req_canceled(int bus, int addr, void * p)
{
    if (true) {
        _nocheck__trace_usb_host_req_canceled(bus, addr, p);
    }
}

#define TRACE_USB_HOST_ISO_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_HOST_ISO_START) || \
    false)

static inline void _nocheck__trace_usb_host_iso_start(int bus, int addr, int ep)
{
    if (trace_event_get_state(TRACE_USB_HOST_ISO_START) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_host_iso_start " "dev %d:%d, ep %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, addr, ep);
    }
}

static inline void trace_usb_host_iso_start(int bus, int addr, int ep)
{
    if (true) {
        _nocheck__trace_usb_host_iso_start(bus, addr, ep);
    }
}

#define TRACE_USB_HOST_ISO_STOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_HOST_ISO_STOP) || \
    false)

static inline void _nocheck__trace_usb_host_iso_stop(int bus, int addr, int ep)
{
    if (trace_event_get_state(TRACE_USB_HOST_ISO_STOP) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_host_iso_stop " "dev %d:%d, ep %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, addr, ep);
    }
}

static inline void trace_usb_host_iso_stop(int bus, int addr, int ep)
{
    if (true) {
        _nocheck__trace_usb_host_iso_stop(bus, addr, ep);
    }
}

#define TRACE_USB_HOST_ISO_OUT_OF_BUFS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_HOST_ISO_OUT_OF_BUFS) || \
    false)

static inline void _nocheck__trace_usb_host_iso_out_of_bufs(int bus, int addr, int ep)
{
    if (trace_event_get_state(TRACE_USB_HOST_ISO_OUT_OF_BUFS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_host_iso_out_of_bufs " "dev %d:%d, ep %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, addr, ep);
    }
}

static inline void trace_usb_host_iso_out_of_bufs(int bus, int addr, int ep)
{
    if (true) {
        _nocheck__trace_usb_host_iso_out_of_bufs(bus, addr, ep);
    }
}

#define TRACE_USB_HOST_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_HOST_RESET) || \
    false)

static inline void _nocheck__trace_usb_host_reset(int bus, int addr)
{
    if (trace_event_get_state(TRACE_USB_HOST_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_host_reset " "dev %d:%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, addr);
    }
}

static inline void trace_usb_host_reset(int bus, int addr)
{
    if (true) {
        _nocheck__trace_usb_host_reset(bus, addr);
    }
}

#define TRACE_USB_HOST_AUTO_SCAN_ENABLED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_HOST_AUTO_SCAN_ENABLED) || \
    false)

static inline void _nocheck__trace_usb_host_auto_scan_enabled(void)
{
    if (trace_event_get_state(TRACE_USB_HOST_AUTO_SCAN_ENABLED) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_host_auto_scan_enabled "  "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_host_auto_scan_enabled(void)
{
    if (true) {
        _nocheck__trace_usb_host_auto_scan_enabled();
    }
}

#define TRACE_USB_HOST_AUTO_SCAN_DISABLED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_HOST_AUTO_SCAN_DISABLED) || \
    false)

static inline void _nocheck__trace_usb_host_auto_scan_disabled(void)
{
    if (trace_event_get_state(TRACE_USB_HOST_AUTO_SCAN_DISABLED) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_host_auto_scan_disabled "  "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_usb_host_auto_scan_disabled(void)
{
    if (true) {
        _nocheck__trace_usb_host_auto_scan_disabled();
    }
}

#define TRACE_USB_HOST_PARSE_CONFIG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_HOST_PARSE_CONFIG) || \
    false)

static inline void _nocheck__trace_usb_host_parse_config(int bus, int addr, int value, int active)
{
    if (trace_event_get_state(TRACE_USB_HOST_PARSE_CONFIG) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_host_parse_config " "dev %d:%d, value %d, active %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, addr, value, active);
    }
}

static inline void trace_usb_host_parse_config(int bus, int addr, int value, int active)
{
    if (true) {
        _nocheck__trace_usb_host_parse_config(bus, addr, value, active);
    }
}

#define TRACE_USB_HOST_PARSE_INTERFACE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_HOST_PARSE_INTERFACE) || \
    false)

static inline void _nocheck__trace_usb_host_parse_interface(int bus, int addr, int num, int alt, int active)
{
    if (trace_event_get_state(TRACE_USB_HOST_PARSE_INTERFACE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_host_parse_interface " "dev %d:%d, num %d, alt %d, active %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, addr, num, alt, active);
    }
}

static inline void trace_usb_host_parse_interface(int bus, int addr, int num, int alt, int active)
{
    if (true) {
        _nocheck__trace_usb_host_parse_interface(bus, addr, num, alt, active);
    }
}

#define TRACE_USB_HOST_PARSE_ENDPOINT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_HOST_PARSE_ENDPOINT) || \
    false)

static inline void _nocheck__trace_usb_host_parse_endpoint(int bus, int addr, int ep, const char * dir, const char * type, int active)
{
    if (trace_event_get_state(TRACE_USB_HOST_PARSE_ENDPOINT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_host_parse_endpoint " "dev %d:%d, ep %d, %s, %s, active %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, addr, ep, dir, type, active);
    }
}

static inline void trace_usb_host_parse_endpoint(int bus, int addr, int ep, const char * dir, const char * type, int active)
{
    if (true) {
        _nocheck__trace_usb_host_parse_endpoint(bus, addr, ep, dir, type, active);
    }
}

#define TRACE_USB_HOST_PARSE_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_HOST_PARSE_ERROR) || \
    false)

static inline void _nocheck__trace_usb_host_parse_error(int bus, int addr, const char * errmsg)
{
    if (trace_event_get_state(TRACE_USB_HOST_PARSE_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_host_parse_error " "dev %d:%d, msg %s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, addr, errmsg);
    }
}

static inline void trace_usb_host_parse_error(int bus, int addr, const char * errmsg)
{
    if (true) {
        _nocheck__trace_usb_host_parse_error(bus, addr, errmsg);
    }
}

#define TRACE_USB_HOST_REMOTE_WAKEUP_REMOVED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_HOST_REMOTE_WAKEUP_REMOVED) || \
    false)

static inline void _nocheck__trace_usb_host_remote_wakeup_removed(int bus, int addr)
{
    if (trace_event_get_state(TRACE_USB_HOST_REMOTE_WAKEUP_REMOVED) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_host_remote_wakeup_removed " "dev %d:%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, addr);
    }
}

static inline void trace_usb_host_remote_wakeup_removed(int bus, int addr)
{
    if (true) {
        _nocheck__trace_usb_host_remote_wakeup_removed(bus, addr);
    }
}

#define TRACE_USB_SERIAL_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_SERIAL_RESET) || \
    false)

static inline void _nocheck__trace_usb_serial_reset(int bus, int addr)
{
    if (trace_event_get_state(TRACE_USB_SERIAL_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_serial_reset " "dev %d:%u reset" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, addr);
    }
}

static inline void trace_usb_serial_reset(int bus, int addr)
{
    if (true) {
        _nocheck__trace_usb_serial_reset(bus, addr);
    }
}

#define TRACE_USB_SERIAL_HANDLE_CONTROL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_SERIAL_HANDLE_CONTROL) || \
    false)

static inline void _nocheck__trace_usb_serial_handle_control(int bus, int addr, int request, int value)
{
    if (trace_event_get_state(TRACE_USB_SERIAL_HANDLE_CONTROL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_serial_handle_control " "dev %d:%u got control 0x%x, value 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, addr, request, value);
    }
}

static inline void trace_usb_serial_handle_control(int bus, int addr, int request, int value)
{
    if (true) {
        _nocheck__trace_usb_serial_handle_control(bus, addr, request, value);
    }
}

#define TRACE_USB_SERIAL_UNSUPPORTED_PARITY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_SERIAL_UNSUPPORTED_PARITY) || \
    false)

static inline void _nocheck__trace_usb_serial_unsupported_parity(int bus, int addr, int value)
{
    if (trace_event_get_state(TRACE_USB_SERIAL_UNSUPPORTED_PARITY) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_serial_unsupported_parity " "dev %d:%u unsupported parity %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, addr, value);
    }
}

static inline void trace_usb_serial_unsupported_parity(int bus, int addr, int value)
{
    if (true) {
        _nocheck__trace_usb_serial_unsupported_parity(bus, addr, value);
    }
}

#define TRACE_USB_SERIAL_UNSUPPORTED_STOPBITS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_SERIAL_UNSUPPORTED_STOPBITS) || \
    false)

static inline void _nocheck__trace_usb_serial_unsupported_stopbits(int bus, int addr, int value)
{
    if (trace_event_get_state(TRACE_USB_SERIAL_UNSUPPORTED_STOPBITS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_serial_unsupported_stopbits " "dev %d:%u unsupported stop bits %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, addr, value);
    }
}

static inline void trace_usb_serial_unsupported_stopbits(int bus, int addr, int value)
{
    if (true) {
        _nocheck__trace_usb_serial_unsupported_stopbits(bus, addr, value);
    }
}

#define TRACE_USB_SERIAL_UNSUPPORTED_CONTROL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_SERIAL_UNSUPPORTED_CONTROL) || \
    false)

static inline void _nocheck__trace_usb_serial_unsupported_control(int bus, int addr, int request, int value)
{
    if (trace_event_get_state(TRACE_USB_SERIAL_UNSUPPORTED_CONTROL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_serial_unsupported_control " "dev %d:%u got unsupported/bogus control 0x%x, value 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, addr, request, value);
    }
}

static inline void trace_usb_serial_unsupported_control(int bus, int addr, int request, int value)
{
    if (true) {
        _nocheck__trace_usb_serial_unsupported_control(bus, addr, request, value);
    }
}

#define TRACE_USB_SERIAL_UNSUPPORTED_DATA_BITS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_SERIAL_UNSUPPORTED_DATA_BITS) || \
    false)

static inline void _nocheck__trace_usb_serial_unsupported_data_bits(int bus, int addr, int value)
{
    if (trace_event_get_state(TRACE_USB_SERIAL_UNSUPPORTED_DATA_BITS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_serial_unsupported_data_bits " "dev %d:%u unsupported data bits %d, falling back to 8" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, addr, value);
    }
}

static inline void trace_usb_serial_unsupported_data_bits(int bus, int addr, int value)
{
    if (true) {
        _nocheck__trace_usb_serial_unsupported_data_bits(bus, addr, value);
    }
}

#define TRACE_USB_SERIAL_BAD_TOKEN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_SERIAL_BAD_TOKEN) || \
    false)

static inline void _nocheck__trace_usb_serial_bad_token(int bus, int addr)
{
    if (trace_event_get_state(TRACE_USB_SERIAL_BAD_TOKEN) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_serial_bad_token " "dev %d:%u bad token" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, addr);
    }
}

static inline void trace_usb_serial_bad_token(int bus, int addr)
{
    if (true) {
        _nocheck__trace_usb_serial_bad_token(bus, addr);
    }
}

#define TRACE_USB_SERIAL_SET_BAUD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_SERIAL_SET_BAUD) || \
    false)

static inline void _nocheck__trace_usb_serial_set_baud(int bus, int addr, int baud)
{
    if (trace_event_get_state(TRACE_USB_SERIAL_SET_BAUD) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_serial_set_baud " "dev %d:%u baud rate %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, addr, baud);
    }
}

static inline void trace_usb_serial_set_baud(int bus, int addr, int baud)
{
    if (true) {
        _nocheck__trace_usb_serial_set_baud(bus, addr, baud);
    }
}

#define TRACE_USB_SERIAL_SET_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_SERIAL_SET_DATA) || \
    false)

static inline void _nocheck__trace_usb_serial_set_data(int bus, int addr, int parity, int data, int stop)
{
    if (trace_event_get_state(TRACE_USB_SERIAL_SET_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_serial_set_data " "dev %d:%u parity %c, data bits %d, stop bits %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, addr, parity, data, stop);
    }
}

static inline void trace_usb_serial_set_data(int bus, int addr, int parity, int data, int stop)
{
    if (true) {
        _nocheck__trace_usb_serial_set_data(bus, addr, parity, data, stop);
    }
}

#define TRACE_USB_SERIAL_SET_FLOW_CONTROL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_SERIAL_SET_FLOW_CONTROL) || \
    false)

static inline void _nocheck__trace_usb_serial_set_flow_control(int bus, int addr, int index)
{
    if (trace_event_get_state(TRACE_USB_SERIAL_SET_FLOW_CONTROL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_serial_set_flow_control " "dev %d:%u flow control %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, addr, index);
    }
}

static inline void trace_usb_serial_set_flow_control(int bus, int addr, int index)
{
    if (true) {
        _nocheck__trace_usb_serial_set_flow_control(bus, addr, index);
    }
}

#define TRACE_USB_SERIAL_SET_XONXOFF_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_USB_SERIAL_SET_XONXOFF) || \
    false)

static inline void _nocheck__trace_usb_serial_set_xonxoff(int bus, int addr, uint8_t xon, uint8_t xoff)
{
    if (trace_event_get_state(TRACE_USB_SERIAL_SET_XONXOFF) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:usb_serial_set_xonxoff " "dev %d:%u xon 0x%x xoff 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, addr, xon, xoff);
    }
}

static inline void trace_usb_serial_set_xonxoff(int bus, int addr, uint8_t xon, uint8_t xoff)
{
    if (true) {
        _nocheck__trace_usb_serial_set_xonxoff(bus, addr, xon, xoff);
    }
}
#endif /* TRACE_HW_USB_GENERATED_TRACERS_H */
