/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_IDE_GENERATED_TRACERS_H
#define TRACE_HW_IDE_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_IDE_IOPORT_READ_EVENT;
extern TraceEvent _TRACE_IDE_IOPORT_WRITE_EVENT;
extern TraceEvent _TRACE_IDE_STATUS_READ_EVENT;
extern TraceEvent _TRACE_IDE_CTRL_WRITE_EVENT;
extern TraceEvent _TRACE_IDE_DATA_READW_EVENT;
extern TraceEvent _TRACE_IDE_DATA_WRITEW_EVENT;
extern TraceEvent _TRACE_IDE_DATA_READL_EVENT;
extern TraceEvent _TRACE_IDE_DATA_WRITEL_EVENT;
extern TraceEvent _TRACE_IDE_EXEC_CMD_EVENT;
extern TraceEvent _TRACE_IDE_CANCEL_DMA_SYNC_BUFFERED_EVENT;
extern TraceEvent _TRACE_IDE_CANCEL_DMA_SYNC_REMAINING_EVENT;
extern TraceEvent _TRACE_IDE_SECTOR_READ_EVENT;
extern TraceEvent _TRACE_IDE_SECTOR_WRITE_EVENT;
extern TraceEvent _TRACE_IDE_RESET_EVENT;
extern TraceEvent _TRACE_IDE_BUS_RESET_AIO_EVENT;
extern TraceEvent _TRACE_IDE_DMA_CB_EVENT;
extern TraceEvent _TRACE_BMDMA_READ_CMD646_EVENT;
extern TraceEvent _TRACE_BMDMA_WRITE_CMD646_EVENT;
extern TraceEvent _TRACE_BMDMA_RESET_EVENT;
extern TraceEvent _TRACE_BMDMA_CMD_WRITEB_EVENT;
extern TraceEvent _TRACE_BMDMA_ADDR_READ_EVENT;
extern TraceEvent _TRACE_BMDMA_ADDR_WRITE_EVENT;
extern TraceEvent _TRACE_BMDMA_READ_EVENT;
extern TraceEvent _TRACE_BMDMA_WRITE_EVENT;
extern TraceEvent _TRACE_SII3112_READ_EVENT;
extern TraceEvent _TRACE_SII3112_WRITE_EVENT;
extern TraceEvent _TRACE_SII3112_SET_IRQ_EVENT;
extern TraceEvent _TRACE_BMDMA_READ_VIA_EVENT;
extern TraceEvent _TRACE_BMDMA_WRITE_VIA_EVENT;
extern TraceEvent _TRACE_CD_READ_SECTOR_SYNC_EVENT;
extern TraceEvent _TRACE_CD_READ_SECTOR_CB_EVENT;
extern TraceEvent _TRACE_CD_READ_SECTOR_EVENT;
extern TraceEvent _TRACE_IDE_ATAPI_CMD_ERROR_EVENT;
extern TraceEvent _TRACE_IDE_ATAPI_CMD_REPLY_END_EVENT;
extern TraceEvent _TRACE_IDE_ATAPI_CMD_REPLY_END_EOT_EVENT;
extern TraceEvent _TRACE_IDE_ATAPI_CMD_REPLY_END_BCL_EVENT;
extern TraceEvent _TRACE_IDE_ATAPI_CMD_REPLY_END_NEW_EVENT;
extern TraceEvent _TRACE_IDE_ATAPI_CMD_CHECK_STATUS_EVENT;
extern TraceEvent _TRACE_IDE_ATAPI_CMD_READ_EVENT;
extern TraceEvent _TRACE_IDE_ATAPI_CMD_EVENT;
extern TraceEvent _TRACE_IDE_ATAPI_CMD_READ_DMA_CB_AIO_EVENT;
extern TraceEvent _TRACE_IDE_ATAPI_CMD_PACKET_EVENT;
extern TraceEvent _TRACE_AHCI_PORT_READ_EVENT;
extern TraceEvent _TRACE_AHCI_PORT_READ_DEFAULT_EVENT;
extern TraceEvent _TRACE_AHCI_IRQ_RAISE_EVENT;
extern TraceEvent _TRACE_AHCI_IRQ_LOWER_EVENT;
extern TraceEvent _TRACE_AHCI_CHECK_IRQ_EVENT;
extern TraceEvent _TRACE_AHCI_TRIGGER_IRQ_EVENT;
extern TraceEvent _TRACE_AHCI_PORT_WRITE_EVENT;
extern TraceEvent _TRACE_AHCI_PORT_WRITE_UNIMPL_EVENT;
extern TraceEvent _TRACE_AHCI_MEM_READ_32_EVENT;
extern TraceEvent _TRACE_AHCI_MEM_READ_32_DEFAULT_EVENT;
extern TraceEvent _TRACE_AHCI_MEM_READ_32_HOST_EVENT;
extern TraceEvent _TRACE_AHCI_MEM_READ_32_HOST_DEFAULT_EVENT;
extern TraceEvent _TRACE_AHCI_MEM_READ_EVENT;
extern TraceEvent _TRACE_AHCI_MEM_WRITE_EVENT;
extern TraceEvent _TRACE_AHCI_MEM_WRITE_HOST_UNIMPL_EVENT;
extern TraceEvent _TRACE_AHCI_MEM_WRITE_HOST_EVENT;
extern TraceEvent _TRACE_AHCI_MEM_WRITE_UNIMPL_EVENT;
extern TraceEvent _TRACE_AHCI_SET_SIGNATURE_EVENT;
extern TraceEvent _TRACE_AHCI_RESET_PORT_EVENT;
extern TraceEvent _TRACE_AHCI_UNMAP_FIS_ADDRESS_NULL_EVENT;
extern TraceEvent _TRACE_AHCI_UNMAP_CLB_ADDRESS_NULL_EVENT;
extern TraceEvent _TRACE_AHCI_POPULATE_SGLIST_EVENT;
extern TraceEvent _TRACE_AHCI_POPULATE_SGLIST_NO_PRDTL_EVENT;
extern TraceEvent _TRACE_AHCI_POPULATE_SGLIST_NO_MAP_EVENT;
extern TraceEvent _TRACE_AHCI_POPULATE_SGLIST_SHORT_MAP_EVENT;
extern TraceEvent _TRACE_AHCI_POPULATE_SGLIST_BAD_OFFSET_EVENT;
extern TraceEvent _TRACE_NCQ_FINISH_EVENT;
extern TraceEvent _TRACE_EXECUTE_NCQ_COMMAND_READ_EVENT;
extern TraceEvent _TRACE_EXECUTE_NCQ_COMMAND_UNSUP_EVENT;
extern TraceEvent _TRACE_PROCESS_NCQ_COMMAND_MISMATCH_EVENT;
extern TraceEvent _TRACE_PROCESS_NCQ_COMMAND_AUX_EVENT;
extern TraceEvent _TRACE_PROCESS_NCQ_COMMAND_PRIOICC_EVENT;
extern TraceEvent _TRACE_PROCESS_NCQ_COMMAND_FUA_EVENT;
extern TraceEvent _TRACE_PROCESS_NCQ_COMMAND_RARC_EVENT;
extern TraceEvent _TRACE_PROCESS_NCQ_COMMAND_LARGE_EVENT;
extern TraceEvent _TRACE_PROCESS_NCQ_COMMAND_EVENT;
extern TraceEvent _TRACE_HANDLE_REG_H2D_FIS_PMP_EVENT;
extern TraceEvent _TRACE_HANDLE_REG_H2D_FIS_RES_EVENT;
extern TraceEvent _TRACE_HANDLE_CMD_BUSY_EVENT;
extern TraceEvent _TRACE_HANDLE_CMD_NOLIST_EVENT;
extern TraceEvent _TRACE_HANDLE_CMD_BADPORT_EVENT;
extern TraceEvent _TRACE_HANDLE_CMD_BADFIS_EVENT;
extern TraceEvent _TRACE_HANDLE_CMD_BADMAP_EVENT;
extern TraceEvent _TRACE_HANDLE_CMD_UNHANDLED_FIS_EVENT;
extern TraceEvent _TRACE_AHCI_PIO_TRANSFER_EVENT;
extern TraceEvent _TRACE_AHCI_START_DMA_EVENT;
extern TraceEvent _TRACE_AHCI_DMA_PREPARE_BUF_EVENT;
extern TraceEvent _TRACE_AHCI_DMA_PREPARE_BUF_FAIL_EVENT;
extern TraceEvent _TRACE_AHCI_DMA_RW_BUF_EVENT;
extern TraceEvent _TRACE_AHCI_CMD_DONE_EVENT;
extern TraceEvent _TRACE_AHCI_RESET_EVENT;
extern TraceEvent _TRACE_HANDLE_REG_H2D_FIS_DUMP_EVENT;
extern TraceEvent _TRACE_HANDLE_CMD_FIS_DUMP_EVENT;
extern TraceEvent _TRACE_ALLWINNER_AHCI_MEM_READ_EVENT;
extern TraceEvent _TRACE_ALLWINNER_AHCI_MEM_WRITE_EVENT;
extern uint16_t _TRACE_IDE_IOPORT_READ_DSTATE;
extern uint16_t _TRACE_IDE_IOPORT_WRITE_DSTATE;
extern uint16_t _TRACE_IDE_STATUS_READ_DSTATE;
extern uint16_t _TRACE_IDE_CTRL_WRITE_DSTATE;
extern uint16_t _TRACE_IDE_DATA_READW_DSTATE;
extern uint16_t _TRACE_IDE_DATA_WRITEW_DSTATE;
extern uint16_t _TRACE_IDE_DATA_READL_DSTATE;
extern uint16_t _TRACE_IDE_DATA_WRITEL_DSTATE;
extern uint16_t _TRACE_IDE_EXEC_CMD_DSTATE;
extern uint16_t _TRACE_IDE_CANCEL_DMA_SYNC_BUFFERED_DSTATE;
extern uint16_t _TRACE_IDE_CANCEL_DMA_SYNC_REMAINING_DSTATE;
extern uint16_t _TRACE_IDE_SECTOR_READ_DSTATE;
extern uint16_t _TRACE_IDE_SECTOR_WRITE_DSTATE;
extern uint16_t _TRACE_IDE_RESET_DSTATE;
extern uint16_t _TRACE_IDE_BUS_RESET_AIO_DSTATE;
extern uint16_t _TRACE_IDE_DMA_CB_DSTATE;
extern uint16_t _TRACE_BMDMA_READ_CMD646_DSTATE;
extern uint16_t _TRACE_BMDMA_WRITE_CMD646_DSTATE;
extern uint16_t _TRACE_BMDMA_RESET_DSTATE;
extern uint16_t _TRACE_BMDMA_CMD_WRITEB_DSTATE;
extern uint16_t _TRACE_BMDMA_ADDR_READ_DSTATE;
extern uint16_t _TRACE_BMDMA_ADDR_WRITE_DSTATE;
extern uint16_t _TRACE_BMDMA_READ_DSTATE;
extern uint16_t _TRACE_BMDMA_WRITE_DSTATE;
extern uint16_t _TRACE_SII3112_READ_DSTATE;
extern uint16_t _TRACE_SII3112_WRITE_DSTATE;
extern uint16_t _TRACE_SII3112_SET_IRQ_DSTATE;
extern uint16_t _TRACE_BMDMA_READ_VIA_DSTATE;
extern uint16_t _TRACE_BMDMA_WRITE_VIA_DSTATE;
extern uint16_t _TRACE_CD_READ_SECTOR_SYNC_DSTATE;
extern uint16_t _TRACE_CD_READ_SECTOR_CB_DSTATE;
extern uint16_t _TRACE_CD_READ_SECTOR_DSTATE;
extern uint16_t _TRACE_IDE_ATAPI_CMD_ERROR_DSTATE;
extern uint16_t _TRACE_IDE_ATAPI_CMD_REPLY_END_DSTATE;
extern uint16_t _TRACE_IDE_ATAPI_CMD_REPLY_END_EOT_DSTATE;
extern uint16_t _TRACE_IDE_ATAPI_CMD_REPLY_END_BCL_DSTATE;
extern uint16_t _TRACE_IDE_ATAPI_CMD_REPLY_END_NEW_DSTATE;
extern uint16_t _TRACE_IDE_ATAPI_CMD_CHECK_STATUS_DSTATE;
extern uint16_t _TRACE_IDE_ATAPI_CMD_READ_DSTATE;
extern uint16_t _TRACE_IDE_ATAPI_CMD_DSTATE;
extern uint16_t _TRACE_IDE_ATAPI_CMD_READ_DMA_CB_AIO_DSTATE;
extern uint16_t _TRACE_IDE_ATAPI_CMD_PACKET_DSTATE;
extern uint16_t _TRACE_AHCI_PORT_READ_DSTATE;
extern uint16_t _TRACE_AHCI_PORT_READ_DEFAULT_DSTATE;
extern uint16_t _TRACE_AHCI_IRQ_RAISE_DSTATE;
extern uint16_t _TRACE_AHCI_IRQ_LOWER_DSTATE;
extern uint16_t _TRACE_AHCI_CHECK_IRQ_DSTATE;
extern uint16_t _TRACE_AHCI_TRIGGER_IRQ_DSTATE;
extern uint16_t _TRACE_AHCI_PORT_WRITE_DSTATE;
extern uint16_t _TRACE_AHCI_PORT_WRITE_UNIMPL_DSTATE;
extern uint16_t _TRACE_AHCI_MEM_READ_32_DSTATE;
extern uint16_t _TRACE_AHCI_MEM_READ_32_DEFAULT_DSTATE;
extern uint16_t _TRACE_AHCI_MEM_READ_32_HOST_DSTATE;
extern uint16_t _TRACE_AHCI_MEM_READ_32_HOST_DEFAULT_DSTATE;
extern uint16_t _TRACE_AHCI_MEM_READ_DSTATE;
extern uint16_t _TRACE_AHCI_MEM_WRITE_DSTATE;
extern uint16_t _TRACE_AHCI_MEM_WRITE_HOST_UNIMPL_DSTATE;
extern uint16_t _TRACE_AHCI_MEM_WRITE_HOST_DSTATE;
extern uint16_t _TRACE_AHCI_MEM_WRITE_UNIMPL_DSTATE;
extern uint16_t _TRACE_AHCI_SET_SIGNATURE_DSTATE;
extern uint16_t _TRACE_AHCI_RESET_PORT_DSTATE;
extern uint16_t _TRACE_AHCI_UNMAP_FIS_ADDRESS_NULL_DSTATE;
extern uint16_t _TRACE_AHCI_UNMAP_CLB_ADDRESS_NULL_DSTATE;
extern uint16_t _TRACE_AHCI_POPULATE_SGLIST_DSTATE;
extern uint16_t _TRACE_AHCI_POPULATE_SGLIST_NO_PRDTL_DSTATE;
extern uint16_t _TRACE_AHCI_POPULATE_SGLIST_NO_MAP_DSTATE;
extern uint16_t _TRACE_AHCI_POPULATE_SGLIST_SHORT_MAP_DSTATE;
extern uint16_t _TRACE_AHCI_POPULATE_SGLIST_BAD_OFFSET_DSTATE;
extern uint16_t _TRACE_NCQ_FINISH_DSTATE;
extern uint16_t _TRACE_EXECUTE_NCQ_COMMAND_READ_DSTATE;
extern uint16_t _TRACE_EXECUTE_NCQ_COMMAND_UNSUP_DSTATE;
extern uint16_t _TRACE_PROCESS_NCQ_COMMAND_MISMATCH_DSTATE;
extern uint16_t _TRACE_PROCESS_NCQ_COMMAND_AUX_DSTATE;
extern uint16_t _TRACE_PROCESS_NCQ_COMMAND_PRIOICC_DSTATE;
extern uint16_t _TRACE_PROCESS_NCQ_COMMAND_FUA_DSTATE;
extern uint16_t _TRACE_PROCESS_NCQ_COMMAND_RARC_DSTATE;
extern uint16_t _TRACE_PROCESS_NCQ_COMMAND_LARGE_DSTATE;
extern uint16_t _TRACE_PROCESS_NCQ_COMMAND_DSTATE;
extern uint16_t _TRACE_HANDLE_REG_H2D_FIS_PMP_DSTATE;
extern uint16_t _TRACE_HANDLE_REG_H2D_FIS_RES_DSTATE;
extern uint16_t _TRACE_HANDLE_CMD_BUSY_DSTATE;
extern uint16_t _TRACE_HANDLE_CMD_NOLIST_DSTATE;
extern uint16_t _TRACE_HANDLE_CMD_BADPORT_DSTATE;
extern uint16_t _TRACE_HANDLE_CMD_BADFIS_DSTATE;
extern uint16_t _TRACE_HANDLE_CMD_BADMAP_DSTATE;
extern uint16_t _TRACE_HANDLE_CMD_UNHANDLED_FIS_DSTATE;
extern uint16_t _TRACE_AHCI_PIO_TRANSFER_DSTATE;
extern uint16_t _TRACE_AHCI_START_DMA_DSTATE;
extern uint16_t _TRACE_AHCI_DMA_PREPARE_BUF_DSTATE;
extern uint16_t _TRACE_AHCI_DMA_PREPARE_BUF_FAIL_DSTATE;
extern uint16_t _TRACE_AHCI_DMA_RW_BUF_DSTATE;
extern uint16_t _TRACE_AHCI_CMD_DONE_DSTATE;
extern uint16_t _TRACE_AHCI_RESET_DSTATE;
extern uint16_t _TRACE_HANDLE_REG_H2D_FIS_DUMP_DSTATE;
extern uint16_t _TRACE_HANDLE_CMD_FIS_DUMP_DSTATE;
extern uint16_t _TRACE_ALLWINNER_AHCI_MEM_READ_DSTATE;
extern uint16_t _TRACE_ALLWINNER_AHCI_MEM_WRITE_DSTATE;
#define TRACE_IDE_IOPORT_READ_ENABLED 1
#define TRACE_IDE_IOPORT_WRITE_ENABLED 1
#define TRACE_IDE_STATUS_READ_ENABLED 1
#define TRACE_IDE_CTRL_WRITE_ENABLED 1
#define TRACE_IDE_DATA_READW_ENABLED 1
#define TRACE_IDE_DATA_WRITEW_ENABLED 1
#define TRACE_IDE_DATA_READL_ENABLED 1
#define TRACE_IDE_DATA_WRITEL_ENABLED 1
#define TRACE_IDE_EXEC_CMD_ENABLED 1
#define TRACE_IDE_CANCEL_DMA_SYNC_BUFFERED_ENABLED 1
#define TRACE_IDE_CANCEL_DMA_SYNC_REMAINING_ENABLED 1
#define TRACE_IDE_SECTOR_READ_ENABLED 1
#define TRACE_IDE_SECTOR_WRITE_ENABLED 1
#define TRACE_IDE_RESET_ENABLED 1
#define TRACE_IDE_BUS_RESET_AIO_ENABLED 1
#define TRACE_IDE_DMA_CB_ENABLED 1
#define TRACE_BMDMA_READ_CMD646_ENABLED 1
#define TRACE_BMDMA_WRITE_CMD646_ENABLED 1
#define TRACE_BMDMA_RESET_ENABLED 1
#define TRACE_BMDMA_CMD_WRITEB_ENABLED 1
#define TRACE_BMDMA_ADDR_READ_ENABLED 1
#define TRACE_BMDMA_ADDR_WRITE_ENABLED 1
#define TRACE_BMDMA_READ_ENABLED 1
#define TRACE_BMDMA_WRITE_ENABLED 1
#define TRACE_SII3112_READ_ENABLED 1
#define TRACE_SII3112_WRITE_ENABLED 1
#define TRACE_SII3112_SET_IRQ_ENABLED 1
#define TRACE_BMDMA_READ_VIA_ENABLED 1
#define TRACE_BMDMA_WRITE_VIA_ENABLED 1
#define TRACE_CD_READ_SECTOR_SYNC_ENABLED 1
#define TRACE_CD_READ_SECTOR_CB_ENABLED 1
#define TRACE_CD_READ_SECTOR_ENABLED 1
#define TRACE_IDE_ATAPI_CMD_ERROR_ENABLED 1
#define TRACE_IDE_ATAPI_CMD_REPLY_END_ENABLED 1
#define TRACE_IDE_ATAPI_CMD_REPLY_END_EOT_ENABLED 1
#define TRACE_IDE_ATAPI_CMD_REPLY_END_BCL_ENABLED 1
#define TRACE_IDE_ATAPI_CMD_REPLY_END_NEW_ENABLED 1
#define TRACE_IDE_ATAPI_CMD_CHECK_STATUS_ENABLED 1
#define TRACE_IDE_ATAPI_CMD_READ_ENABLED 1
#define TRACE_IDE_ATAPI_CMD_ENABLED 1
#define TRACE_IDE_ATAPI_CMD_READ_DMA_CB_AIO_ENABLED 1
#define TRACE_IDE_ATAPI_CMD_PACKET_ENABLED 1
#define TRACE_AHCI_PORT_READ_ENABLED 1
#define TRACE_AHCI_PORT_READ_DEFAULT_ENABLED 1
#define TRACE_AHCI_IRQ_RAISE_ENABLED 1
#define TRACE_AHCI_IRQ_LOWER_ENABLED 1
#define TRACE_AHCI_CHECK_IRQ_ENABLED 1
#define TRACE_AHCI_TRIGGER_IRQ_ENABLED 1
#define TRACE_AHCI_PORT_WRITE_ENABLED 1
#define TRACE_AHCI_PORT_WRITE_UNIMPL_ENABLED 1
#define TRACE_AHCI_MEM_READ_32_ENABLED 1
#define TRACE_AHCI_MEM_READ_32_DEFAULT_ENABLED 1
#define TRACE_AHCI_MEM_READ_32_HOST_ENABLED 1
#define TRACE_AHCI_MEM_READ_32_HOST_DEFAULT_ENABLED 1
#define TRACE_AHCI_MEM_READ_ENABLED 1
#define TRACE_AHCI_MEM_WRITE_ENABLED 1
#define TRACE_AHCI_MEM_WRITE_HOST_UNIMPL_ENABLED 1
#define TRACE_AHCI_MEM_WRITE_HOST_ENABLED 1
#define TRACE_AHCI_MEM_WRITE_UNIMPL_ENABLED 1
#define TRACE_AHCI_SET_SIGNATURE_ENABLED 1
#define TRACE_AHCI_RESET_PORT_ENABLED 1
#define TRACE_AHCI_UNMAP_FIS_ADDRESS_NULL_ENABLED 1
#define TRACE_AHCI_UNMAP_CLB_ADDRESS_NULL_ENABLED 1
#define TRACE_AHCI_POPULATE_SGLIST_ENABLED 1
#define TRACE_AHCI_POPULATE_SGLIST_NO_PRDTL_ENABLED 1
#define TRACE_AHCI_POPULATE_SGLIST_NO_MAP_ENABLED 1
#define TRACE_AHCI_POPULATE_SGLIST_SHORT_MAP_ENABLED 1
#define TRACE_AHCI_POPULATE_SGLIST_BAD_OFFSET_ENABLED 1
#define TRACE_NCQ_FINISH_ENABLED 1
#define TRACE_EXECUTE_NCQ_COMMAND_READ_ENABLED 1
#define TRACE_EXECUTE_NCQ_COMMAND_UNSUP_ENABLED 1
#define TRACE_PROCESS_NCQ_COMMAND_MISMATCH_ENABLED 1
#define TRACE_PROCESS_NCQ_COMMAND_AUX_ENABLED 1
#define TRACE_PROCESS_NCQ_COMMAND_PRIOICC_ENABLED 1
#define TRACE_PROCESS_NCQ_COMMAND_FUA_ENABLED 1
#define TRACE_PROCESS_NCQ_COMMAND_RARC_ENABLED 1
#define TRACE_PROCESS_NCQ_COMMAND_LARGE_ENABLED 1
#define TRACE_PROCESS_NCQ_COMMAND_ENABLED 1
#define TRACE_HANDLE_REG_H2D_FIS_PMP_ENABLED 1
#define TRACE_HANDLE_REG_H2D_FIS_RES_ENABLED 1
#define TRACE_HANDLE_CMD_BUSY_ENABLED 1
#define TRACE_HANDLE_CMD_NOLIST_ENABLED 1
#define TRACE_HANDLE_CMD_BADPORT_ENABLED 1
#define TRACE_HANDLE_CMD_BADFIS_ENABLED 1
#define TRACE_HANDLE_CMD_BADMAP_ENABLED 1
#define TRACE_HANDLE_CMD_UNHANDLED_FIS_ENABLED 1
#define TRACE_AHCI_PIO_TRANSFER_ENABLED 1
#define TRACE_AHCI_START_DMA_ENABLED 1
#define TRACE_AHCI_DMA_PREPARE_BUF_ENABLED 1
#define TRACE_AHCI_DMA_PREPARE_BUF_FAIL_ENABLED 1
#define TRACE_AHCI_DMA_RW_BUF_ENABLED 1
#define TRACE_AHCI_CMD_DONE_ENABLED 1
#define TRACE_AHCI_RESET_ENABLED 1
#define TRACE_HANDLE_REG_H2D_FIS_DUMP_ENABLED 1
#define TRACE_HANDLE_CMD_FIS_DUMP_ENABLED 1
#define TRACE_ALLWINNER_AHCI_MEM_READ_ENABLED 1
#define TRACE_ALLWINNER_AHCI_MEM_WRITE_ENABLED 1
#include "qemu/log-for-trace.h"


#define TRACE_IDE_IOPORT_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_IOPORT_READ) || \
    false)

static inline void _nocheck__trace_ide_ioport_read(uint32_t addr, const char * reg, uint32_t val, void * bus, void * s)
{
    if (trace_event_get_state(TRACE_IDE_IOPORT_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ide_ioport_read " "IDE PIO rd @ 0x%"PRIx32" (%s); val 0x%02"PRIx32"; bus %p IDEState %p" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, reg, val, bus, s);
    }
}

static inline void trace_ide_ioport_read(uint32_t addr, const char * reg, uint32_t val, void * bus, void * s)
{
    if (true) {
        _nocheck__trace_ide_ioport_read(addr, reg, val, bus, s);
    }
}

#define TRACE_IDE_IOPORT_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_IOPORT_WRITE) || \
    false)

static inline void _nocheck__trace_ide_ioport_write(uint32_t addr, const char * reg, uint32_t val, void * bus, void * s)
{
    if (trace_event_get_state(TRACE_IDE_IOPORT_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ide_ioport_write " "IDE PIO wr @ 0x%"PRIx32" (%s); val 0x%02"PRIx32"; bus %p IDEState %p" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, reg, val, bus, s);
    }
}

static inline void trace_ide_ioport_write(uint32_t addr, const char * reg, uint32_t val, void * bus, void * s)
{
    if (true) {
        _nocheck__trace_ide_ioport_write(addr, reg, val, bus, s);
    }
}

#define TRACE_IDE_STATUS_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_STATUS_READ) || \
    false)

static inline void _nocheck__trace_ide_status_read(uint32_t addr, uint32_t val, void * bus, void * s)
{
    if (trace_event_get_state(TRACE_IDE_STATUS_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ide_status_read " "IDE PIO rd @ 0x%"PRIx32" (Alt Status); val 0x%02"PRIx32"; bus %p; IDEState %p" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, val, bus, s);
    }
}

static inline void trace_ide_status_read(uint32_t addr, uint32_t val, void * bus, void * s)
{
    if (true) {
        _nocheck__trace_ide_status_read(addr, val, bus, s);
    }
}

#define TRACE_IDE_CTRL_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_CTRL_WRITE) || \
    false)

static inline void _nocheck__trace_ide_ctrl_write(uint32_t addr, uint32_t val, void * bus)
{
    if (trace_event_get_state(TRACE_IDE_CTRL_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ide_ctrl_write " "IDE PIO wr @ 0x%"PRIx32" (Device Control); val 0x%02"PRIx32"; bus %p" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, val, bus);
    }
}

static inline void trace_ide_ctrl_write(uint32_t addr, uint32_t val, void * bus)
{
    if (true) {
        _nocheck__trace_ide_ctrl_write(addr, val, bus);
    }
}

#define TRACE_IDE_DATA_READW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_DATA_READW) || \
    false)

static inline void _nocheck__trace_ide_data_readw(uint32_t addr, uint32_t val, void * bus, void * s)
{
    if (trace_event_get_state(TRACE_IDE_DATA_READW) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ide_data_readw " "IDE PIO rd @ 0x%"PRIx32" (Data: Word); val 0x%04"PRIx32"; bus %p; IDEState %p" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, val, bus, s);
    }
}

static inline void trace_ide_data_readw(uint32_t addr, uint32_t val, void * bus, void * s)
{
    if (true) {
        _nocheck__trace_ide_data_readw(addr, val, bus, s);
    }
}

#define TRACE_IDE_DATA_WRITEW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_DATA_WRITEW) || \
    false)

static inline void _nocheck__trace_ide_data_writew(uint32_t addr, uint32_t val, void * bus, void * s)
{
    if (trace_event_get_state(TRACE_IDE_DATA_WRITEW) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ide_data_writew " "IDE PIO wr @ 0x%"PRIx32" (Data: Word); val 0x%04"PRIx32"; bus %p; IDEState %p" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, val, bus, s);
    }
}

static inline void trace_ide_data_writew(uint32_t addr, uint32_t val, void * bus, void * s)
{
    if (true) {
        _nocheck__trace_ide_data_writew(addr, val, bus, s);
    }
}

#define TRACE_IDE_DATA_READL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_DATA_READL) || \
    false)

static inline void _nocheck__trace_ide_data_readl(uint32_t addr, uint32_t val, void * bus, void * s)
{
    if (trace_event_get_state(TRACE_IDE_DATA_READL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ide_data_readl " "IDE PIO rd @ 0x%"PRIx32" (Data: Long); val 0x%08"PRIx32"; bus %p; IDEState %p" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, val, bus, s);
    }
}

static inline void trace_ide_data_readl(uint32_t addr, uint32_t val, void * bus, void * s)
{
    if (true) {
        _nocheck__trace_ide_data_readl(addr, val, bus, s);
    }
}

#define TRACE_IDE_DATA_WRITEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_DATA_WRITEL) || \
    false)

static inline void _nocheck__trace_ide_data_writel(uint32_t addr, uint32_t val, void * bus, void * s)
{
    if (trace_event_get_state(TRACE_IDE_DATA_WRITEL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ide_data_writel " "IDE PIO wr @ 0x%"PRIx32" (Data: Long); val 0x%08"PRIx32"; bus %p; IDEState %p" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, val, bus, s);
    }
}

static inline void trace_ide_data_writel(uint32_t addr, uint32_t val, void * bus, void * s)
{
    if (true) {
        _nocheck__trace_ide_data_writel(addr, val, bus, s);
    }
}

#define TRACE_IDE_EXEC_CMD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_EXEC_CMD) || \
    false)

static inline void _nocheck__trace_ide_exec_cmd(void * bus, void * state, uint32_t cmd)
{
    if (trace_event_get_state(TRACE_IDE_EXEC_CMD) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ide_exec_cmd " "IDE exec cmd: bus %p; state %p; cmd 0x%02x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, state, cmd);
    }
}

static inline void trace_ide_exec_cmd(void * bus, void * state, uint32_t cmd)
{
    if (true) {
        _nocheck__trace_ide_exec_cmd(bus, state, cmd);
    }
}

#define TRACE_IDE_CANCEL_DMA_SYNC_BUFFERED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_CANCEL_DMA_SYNC_BUFFERED) || \
    false)

static inline void _nocheck__trace_ide_cancel_dma_sync_buffered(void * fn, void * req)
{
    if (trace_event_get_state(TRACE_IDE_CANCEL_DMA_SYNC_BUFFERED) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ide_cancel_dma_sync_buffered " "invoking cb %p of buffered request %p with -ECANCELED" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , fn, req);
    }
}

static inline void trace_ide_cancel_dma_sync_buffered(void * fn, void * req)
{
    if (true) {
        _nocheck__trace_ide_cancel_dma_sync_buffered(fn, req);
    }
}

#define TRACE_IDE_CANCEL_DMA_SYNC_REMAINING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_CANCEL_DMA_SYNC_REMAINING) || \
    false)

static inline void _nocheck__trace_ide_cancel_dma_sync_remaining(void)
{
    if (trace_event_get_state(TRACE_IDE_CANCEL_DMA_SYNC_REMAINING) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ide_cancel_dma_sync_remaining " "draining all remaining requests" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_ide_cancel_dma_sync_remaining(void)
{
    if (true) {
        _nocheck__trace_ide_cancel_dma_sync_remaining();
    }
}

#define TRACE_IDE_SECTOR_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_SECTOR_READ) || \
    false)

static inline void _nocheck__trace_ide_sector_read(int64_t sector_num, int nsectors)
{
    if (trace_event_get_state(TRACE_IDE_SECTOR_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ide_sector_read " "sector=%"PRId64" nsectors=%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , sector_num, nsectors);
    }
}

static inline void trace_ide_sector_read(int64_t sector_num, int nsectors)
{
    if (true) {
        _nocheck__trace_ide_sector_read(sector_num, nsectors);
    }
}

#define TRACE_IDE_SECTOR_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_SECTOR_WRITE) || \
    false)

static inline void _nocheck__trace_ide_sector_write(int64_t sector_num, int nsectors)
{
    if (trace_event_get_state(TRACE_IDE_SECTOR_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ide_sector_write " "sector=%"PRId64" nsectors=%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , sector_num, nsectors);
    }
}

static inline void trace_ide_sector_write(int64_t sector_num, int nsectors)
{
    if (true) {
        _nocheck__trace_ide_sector_write(sector_num, nsectors);
    }
}

#define TRACE_IDE_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_RESET) || \
    false)

static inline void _nocheck__trace_ide_reset(void * s)
{
    if (trace_event_get_state(TRACE_IDE_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ide_reset " "IDEstate %p" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s);
    }
}

static inline void trace_ide_reset(void * s)
{
    if (true) {
        _nocheck__trace_ide_reset(s);
    }
}

#define TRACE_IDE_BUS_RESET_AIO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_BUS_RESET_AIO) || \
    false)

static inline void _nocheck__trace_ide_bus_reset_aio(void)
{
    if (trace_event_get_state(TRACE_IDE_BUS_RESET_AIO) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ide_bus_reset_aio " "aio_cancel" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_ide_bus_reset_aio(void)
{
    if (true) {
        _nocheck__trace_ide_bus_reset_aio();
    }
}

#define TRACE_IDE_DMA_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_DMA_CB) || \
    false)

static inline void _nocheck__trace_ide_dma_cb(void * s, int64_t sector_num, int n, const char * dma)
{
    if (trace_event_get_state(TRACE_IDE_DMA_CB) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ide_dma_cb " "IDEState %p; sector_num=%"PRId64" n=%d cmd=%s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, sector_num, n, dma);
    }
}

static inline void trace_ide_dma_cb(void * s, int64_t sector_num, int n, const char * dma)
{
    if (true) {
        _nocheck__trace_ide_dma_cb(s, sector_num, n, dma);
    }
}

#define TRACE_BMDMA_READ_CMD646_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BMDMA_READ_CMD646) || \
    false)

static inline void _nocheck__trace_bmdma_read_cmd646(uint64_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_BMDMA_READ_CMD646) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:bmdma_read_cmd646 " "bmdma: readb 0x%"PRIx64" : 0x%02x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, val);
    }
}

static inline void trace_bmdma_read_cmd646(uint64_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_bmdma_read_cmd646(addr, val);
    }
}

#define TRACE_BMDMA_WRITE_CMD646_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BMDMA_WRITE_CMD646) || \
    false)

static inline void _nocheck__trace_bmdma_write_cmd646(uint64_t addr, uint64_t val)
{
    if (trace_event_get_state(TRACE_BMDMA_WRITE_CMD646) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:bmdma_write_cmd646 " "bmdma: writeb 0x%"PRIx64" : 0x%02"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, val);
    }
}

static inline void trace_bmdma_write_cmd646(uint64_t addr, uint64_t val)
{
    if (true) {
        _nocheck__trace_bmdma_write_cmd646(addr, val);
    }
}

#define TRACE_BMDMA_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BMDMA_RESET) || \
    false)

static inline void _nocheck__trace_bmdma_reset(void)
{
    if (trace_event_get_state(TRACE_BMDMA_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:bmdma_reset " "" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_bmdma_reset(void)
{
    if (true) {
        _nocheck__trace_bmdma_reset();
    }
}

#define TRACE_BMDMA_CMD_WRITEB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BMDMA_CMD_WRITEB) || \
    false)

static inline void _nocheck__trace_bmdma_cmd_writeb(uint32_t val)
{
    if (trace_event_get_state(TRACE_BMDMA_CMD_WRITEB) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:bmdma_cmd_writeb " "val: 0x%08x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , val);
    }
}

static inline void trace_bmdma_cmd_writeb(uint32_t val)
{
    if (true) {
        _nocheck__trace_bmdma_cmd_writeb(val);
    }
}

#define TRACE_BMDMA_ADDR_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BMDMA_ADDR_READ) || \
    false)

static inline void _nocheck__trace_bmdma_addr_read(uint64_t data)
{
    if (trace_event_get_state(TRACE_BMDMA_ADDR_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:bmdma_addr_read " "data: 0x%016"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , data);
    }
}

static inline void trace_bmdma_addr_read(uint64_t data)
{
    if (true) {
        _nocheck__trace_bmdma_addr_read(data);
    }
}

#define TRACE_BMDMA_ADDR_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BMDMA_ADDR_WRITE) || \
    false)

static inline void _nocheck__trace_bmdma_addr_write(uint64_t data)
{
    if (trace_event_get_state(TRACE_BMDMA_ADDR_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:bmdma_addr_write " "data: 0x%016"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , data);
    }
}

static inline void trace_bmdma_addr_write(uint64_t data)
{
    if (true) {
        _nocheck__trace_bmdma_addr_write(data);
    }
}

#define TRACE_BMDMA_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BMDMA_READ) || \
    false)

static inline void _nocheck__trace_bmdma_read(uint64_t addr, uint8_t val)
{
    if (trace_event_get_state(TRACE_BMDMA_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:bmdma_read " "bmdma: readb 0x%"PRIx64" : 0x%02x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, val);
    }
}

static inline void trace_bmdma_read(uint64_t addr, uint8_t val)
{
    if (true) {
        _nocheck__trace_bmdma_read(addr, val);
    }
}

#define TRACE_BMDMA_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BMDMA_WRITE) || \
    false)

static inline void _nocheck__trace_bmdma_write(uint64_t addr, uint64_t val)
{
    if (trace_event_get_state(TRACE_BMDMA_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:bmdma_write " "bmdma: writeb 0x%"PRIx64" : 0x%02"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, val);
    }
}

static inline void trace_bmdma_write(uint64_t addr, uint64_t val)
{
    if (true) {
        _nocheck__trace_bmdma_write(addr, val);
    }
}

#define TRACE_SII3112_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SII3112_READ) || \
    false)

static inline void _nocheck__trace_sii3112_read(int size, uint64_t addr, uint64_t val)
{
    if (trace_event_get_state(TRACE_SII3112_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:sii3112_read " "bmdma: read (size %d) 0x%"PRIx64" : 0x%02"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , size, addr, val);
    }
}

static inline void trace_sii3112_read(int size, uint64_t addr, uint64_t val)
{
    if (true) {
        _nocheck__trace_sii3112_read(size, addr, val);
    }
}

#define TRACE_SII3112_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SII3112_WRITE) || \
    false)

static inline void _nocheck__trace_sii3112_write(int size, uint64_t addr, uint64_t val)
{
    if (trace_event_get_state(TRACE_SII3112_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:sii3112_write " "bmdma: write (size %d) 0x%"PRIx64" : 0x%02"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , size, addr, val);
    }
}

static inline void trace_sii3112_write(int size, uint64_t addr, uint64_t val)
{
    if (true) {
        _nocheck__trace_sii3112_write(size, addr, val);
    }
}

#define TRACE_SII3112_SET_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SII3112_SET_IRQ) || \
    false)

static inline void _nocheck__trace_sii3112_set_irq(int channel, int level)
{
    if (trace_event_get_state(TRACE_SII3112_SET_IRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:sii3112_set_irq " "channel %d level %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , channel, level);
    }
}

static inline void trace_sii3112_set_irq(int channel, int level)
{
    if (true) {
        _nocheck__trace_sii3112_set_irq(channel, level);
    }
}

#define TRACE_BMDMA_READ_VIA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BMDMA_READ_VIA) || \
    false)

static inline void _nocheck__trace_bmdma_read_via(uint64_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_BMDMA_READ_VIA) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:bmdma_read_via " "bmdma: readb 0x%"PRIx64" : 0x%02x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, val);
    }
}

static inline void trace_bmdma_read_via(uint64_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_bmdma_read_via(addr, val);
    }
}

#define TRACE_BMDMA_WRITE_VIA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BMDMA_WRITE_VIA) || \
    false)

static inline void _nocheck__trace_bmdma_write_via(uint64_t addr, uint64_t val)
{
    if (trace_event_get_state(TRACE_BMDMA_WRITE_VIA) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:bmdma_write_via " "bmdma: writeb 0x%"PRIx64" : 0x%02"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, val);
    }
}

static inline void trace_bmdma_write_via(uint64_t addr, uint64_t val)
{
    if (true) {
        _nocheck__trace_bmdma_write_via(addr, val);
    }
}

#define TRACE_CD_READ_SECTOR_SYNC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CD_READ_SECTOR_SYNC) || \
    false)

static inline void _nocheck__trace_cd_read_sector_sync(int lba)
{
    if (trace_event_get_state(TRACE_CD_READ_SECTOR_SYNC) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:cd_read_sector_sync " "lba=%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , lba);
    }
}

static inline void trace_cd_read_sector_sync(int lba)
{
    if (true) {
        _nocheck__trace_cd_read_sector_sync(lba);
    }
}

#define TRACE_CD_READ_SECTOR_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CD_READ_SECTOR_CB) || \
    false)

static inline void _nocheck__trace_cd_read_sector_cb(int lba, int ret)
{
    if (trace_event_get_state(TRACE_CD_READ_SECTOR_CB) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:cd_read_sector_cb " "lba=%d ret=%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , lba, ret);
    }
}

static inline void trace_cd_read_sector_cb(int lba, int ret)
{
    if (true) {
        _nocheck__trace_cd_read_sector_cb(lba, ret);
    }
}

#define TRACE_CD_READ_SECTOR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CD_READ_SECTOR) || \
    false)

static inline void _nocheck__trace_cd_read_sector(int lba)
{
    if (trace_event_get_state(TRACE_CD_READ_SECTOR) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:cd_read_sector " "lba=%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , lba);
    }
}

static inline void trace_cd_read_sector(int lba)
{
    if (true) {
        _nocheck__trace_cd_read_sector(lba);
    }
}

#define TRACE_IDE_ATAPI_CMD_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_ATAPI_CMD_ERROR) || \
    false)

static inline void _nocheck__trace_ide_atapi_cmd_error(void * s, int sense_key, int asc)
{
    if (trace_event_get_state(TRACE_IDE_ATAPI_CMD_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ide_atapi_cmd_error " "IDEState: %p; sense=0x%x asc=0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, sense_key, asc);
    }
}

static inline void trace_ide_atapi_cmd_error(void * s, int sense_key, int asc)
{
    if (true) {
        _nocheck__trace_ide_atapi_cmd_error(s, sense_key, asc);
    }
}

#define TRACE_IDE_ATAPI_CMD_REPLY_END_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_ATAPI_CMD_REPLY_END) || \
    false)

static inline void _nocheck__trace_ide_atapi_cmd_reply_end(void * s, int tx_size, int elem_tx_size, int32_t index)
{
    if (trace_event_get_state(TRACE_IDE_ATAPI_CMD_REPLY_END) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ide_atapi_cmd_reply_end " "IDEState %p; reply: tx_size=%d elem_tx_size=%d index=%"PRId32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, tx_size, elem_tx_size, index);
    }
}

static inline void trace_ide_atapi_cmd_reply_end(void * s, int tx_size, int elem_tx_size, int32_t index)
{
    if (true) {
        _nocheck__trace_ide_atapi_cmd_reply_end(s, tx_size, elem_tx_size, index);
    }
}

#define TRACE_IDE_ATAPI_CMD_REPLY_END_EOT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_ATAPI_CMD_REPLY_END_EOT) || \
    false)

static inline void _nocheck__trace_ide_atapi_cmd_reply_end_eot(void * s, int status)
{
    if (trace_event_get_state(TRACE_IDE_ATAPI_CMD_REPLY_END_EOT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ide_atapi_cmd_reply_end_eot " "IDEState: %p; end of transfer, status=0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, status);
    }
}

static inline void trace_ide_atapi_cmd_reply_end_eot(void * s, int status)
{
    if (true) {
        _nocheck__trace_ide_atapi_cmd_reply_end_eot(s, status);
    }
}

#define TRACE_IDE_ATAPI_CMD_REPLY_END_BCL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_ATAPI_CMD_REPLY_END_BCL) || \
    false)

static inline void _nocheck__trace_ide_atapi_cmd_reply_end_bcl(void * s, int bcl)
{
    if (trace_event_get_state(TRACE_IDE_ATAPI_CMD_REPLY_END_BCL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ide_atapi_cmd_reply_end_bcl " "IDEState: %p; byte_count_limit=%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, bcl);
    }
}

static inline void trace_ide_atapi_cmd_reply_end_bcl(void * s, int bcl)
{
    if (true) {
        _nocheck__trace_ide_atapi_cmd_reply_end_bcl(s, bcl);
    }
}

#define TRACE_IDE_ATAPI_CMD_REPLY_END_NEW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_ATAPI_CMD_REPLY_END_NEW) || \
    false)

static inline void _nocheck__trace_ide_atapi_cmd_reply_end_new(void * s, int status)
{
    if (trace_event_get_state(TRACE_IDE_ATAPI_CMD_REPLY_END_NEW) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ide_atapi_cmd_reply_end_new " "IDEState: %p; new transfer started, status=0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, status);
    }
}

static inline void trace_ide_atapi_cmd_reply_end_new(void * s, int status)
{
    if (true) {
        _nocheck__trace_ide_atapi_cmd_reply_end_new(s, status);
    }
}

#define TRACE_IDE_ATAPI_CMD_CHECK_STATUS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_ATAPI_CMD_CHECK_STATUS) || \
    false)

static inline void _nocheck__trace_ide_atapi_cmd_check_status(void * s)
{
    if (trace_event_get_state(TRACE_IDE_ATAPI_CMD_CHECK_STATUS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ide_atapi_cmd_check_status " "IDEState: %p" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s);
    }
}

static inline void trace_ide_atapi_cmd_check_status(void * s)
{
    if (true) {
        _nocheck__trace_ide_atapi_cmd_check_status(s);
    }
}

#define TRACE_IDE_ATAPI_CMD_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_ATAPI_CMD_READ) || \
    false)

static inline void _nocheck__trace_ide_atapi_cmd_read(void * s, const char * method, int lba, int nb_sectors)
{
    if (trace_event_get_state(TRACE_IDE_ATAPI_CMD_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ide_atapi_cmd_read " "IDEState: %p; read %s: LBA=%d nb_sectors=%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, method, lba, nb_sectors);
    }
}

static inline void trace_ide_atapi_cmd_read(void * s, const char * method, int lba, int nb_sectors)
{
    if (true) {
        _nocheck__trace_ide_atapi_cmd_read(s, method, lba, nb_sectors);
    }
}

#define TRACE_IDE_ATAPI_CMD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_ATAPI_CMD) || \
    false)

static inline void _nocheck__trace_ide_atapi_cmd(void * s, uint8_t cmd)
{
    if (trace_event_get_state(TRACE_IDE_ATAPI_CMD) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ide_atapi_cmd " "IDEState: %p; cmd: 0x%02x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, cmd);
    }
}

static inline void trace_ide_atapi_cmd(void * s, uint8_t cmd)
{
    if (true) {
        _nocheck__trace_ide_atapi_cmd(s, cmd);
    }
}

#define TRACE_IDE_ATAPI_CMD_READ_DMA_CB_AIO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_ATAPI_CMD_READ_DMA_CB_AIO) || \
    false)

static inline void _nocheck__trace_ide_atapi_cmd_read_dma_cb_aio(void * s, int lba, int n)
{
    if (trace_event_get_state(TRACE_IDE_ATAPI_CMD_READ_DMA_CB_AIO) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ide_atapi_cmd_read_dma_cb_aio " "IDEState: %p; aio read: lba=%d n=%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, lba, n);
    }
}

static inline void trace_ide_atapi_cmd_read_dma_cb_aio(void * s, int lba, int n)
{
    if (true) {
        _nocheck__trace_ide_atapi_cmd_read_dma_cb_aio(s, lba, n);
    }
}

#define TRACE_IDE_ATAPI_CMD_PACKET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_ATAPI_CMD_PACKET) || \
    false)

static inline void _nocheck__trace_ide_atapi_cmd_packet(void * s, uint16_t limit, const char * packet)
{
    if (trace_event_get_state(TRACE_IDE_ATAPI_CMD_PACKET) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ide_atapi_cmd_packet " "IDEState: %p; limit=0x%x packet: %s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, limit, packet);
    }
}

static inline void trace_ide_atapi_cmd_packet(void * s, uint16_t limit, const char * packet)
{
    if (true) {
        _nocheck__trace_ide_atapi_cmd_packet(s, limit, packet);
    }
}

#define TRACE_AHCI_PORT_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_PORT_READ) || \
    false)

static inline void _nocheck__trace_ahci_port_read(void * s, int port, const char * reg, int offset, uint32_t ret)
{
    if (trace_event_get_state(TRACE_AHCI_PORT_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ahci_port_read " "ahci(%p)[%d]: port read [reg:%s] @ 0x%x: 0x%08x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port, reg, offset, ret);
    }
}

static inline void trace_ahci_port_read(void * s, int port, const char * reg, int offset, uint32_t ret)
{
    if (true) {
        _nocheck__trace_ahci_port_read(s, port, reg, offset, ret);
    }
}

#define TRACE_AHCI_PORT_READ_DEFAULT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_PORT_READ_DEFAULT) || \
    false)

static inline void _nocheck__trace_ahci_port_read_default(void * s, int port, const char * reg, int offset)
{
    if (trace_event_get_state(TRACE_AHCI_PORT_READ_DEFAULT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ahci_port_read_default " "ahci(%p)[%d]: unimplemented port read [reg:%s] @ 0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port, reg, offset);
    }
}

static inline void trace_ahci_port_read_default(void * s, int port, const char * reg, int offset)
{
    if (true) {
        _nocheck__trace_ahci_port_read_default(s, port, reg, offset);
    }
}

#define TRACE_AHCI_IRQ_RAISE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_IRQ_RAISE) || \
    false)

static inline void _nocheck__trace_ahci_irq_raise(void * s)
{
    if (trace_event_get_state(TRACE_AHCI_IRQ_RAISE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ahci_irq_raise " "ahci(%p): raise irq" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s);
    }
}

static inline void trace_ahci_irq_raise(void * s)
{
    if (true) {
        _nocheck__trace_ahci_irq_raise(s);
    }
}

#define TRACE_AHCI_IRQ_LOWER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_IRQ_LOWER) || \
    false)

static inline void _nocheck__trace_ahci_irq_lower(void * s)
{
    if (trace_event_get_state(TRACE_AHCI_IRQ_LOWER) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ahci_irq_lower " "ahci(%p): lower irq" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s);
    }
}

static inline void trace_ahci_irq_lower(void * s)
{
    if (true) {
        _nocheck__trace_ahci_irq_lower(s);
    }
}

#define TRACE_AHCI_CHECK_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_CHECK_IRQ) || \
    false)

static inline void _nocheck__trace_ahci_check_irq(void * s, uint32_t old, uint32_t new)
{
    if (trace_event_get_state(TRACE_AHCI_CHECK_IRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ahci_check_irq " "ahci(%p): check irq 0x%08x --> 0x%08x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, old, new);
    }
}

static inline void trace_ahci_check_irq(void * s, uint32_t old, uint32_t new)
{
    if (true) {
        _nocheck__trace_ahci_check_irq(s, old, new);
    }
}

#define TRACE_AHCI_TRIGGER_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_TRIGGER_IRQ) || \
    false)

static inline void _nocheck__trace_ahci_trigger_irq(void * s, int port, const char * name, uint32_t val, uint32_t old, uint32_t new, uint32_t effective)
{
    if (trace_event_get_state(TRACE_AHCI_TRIGGER_IRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ahci_trigger_irq " "ahci(%p)[%d]: trigger irq +%s (0x%08x); irqstat: 0x%08x --> 0x%08x; effective: 0x%08x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port, name, val, old, new, effective);
    }
}

static inline void trace_ahci_trigger_irq(void * s, int port, const char * name, uint32_t val, uint32_t old, uint32_t new, uint32_t effective)
{
    if (true) {
        _nocheck__trace_ahci_trigger_irq(s, port, name, val, old, new, effective);
    }
}

#define TRACE_AHCI_PORT_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_PORT_WRITE) || \
    false)

static inline void _nocheck__trace_ahci_port_write(void * s, int port, const char * reg, int offset, uint32_t val)
{
    if (trace_event_get_state(TRACE_AHCI_PORT_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ahci_port_write " "ahci(%p)[%d]: port write [reg:%s] @ 0x%x: 0x%08x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port, reg, offset, val);
    }
}

static inline void trace_ahci_port_write(void * s, int port, const char * reg, int offset, uint32_t val)
{
    if (true) {
        _nocheck__trace_ahci_port_write(s, port, reg, offset, val);
    }
}

#define TRACE_AHCI_PORT_WRITE_UNIMPL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_PORT_WRITE_UNIMPL) || \
    false)

static inline void _nocheck__trace_ahci_port_write_unimpl(void * s, int port, const char * reg, int offset, uint32_t val)
{
    if (trace_event_get_state(TRACE_AHCI_PORT_WRITE_UNIMPL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ahci_port_write_unimpl " "ahci(%p)[%d]: unimplemented port write [reg:%s] @ 0x%x: 0x%08x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port, reg, offset, val);
    }
}

static inline void trace_ahci_port_write_unimpl(void * s, int port, const char * reg, int offset, uint32_t val)
{
    if (true) {
        _nocheck__trace_ahci_port_write_unimpl(s, port, reg, offset, val);
    }
}

#define TRACE_AHCI_MEM_READ_32_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_MEM_READ_32) || \
    false)

static inline void _nocheck__trace_ahci_mem_read_32(void * s, uint64_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_AHCI_MEM_READ_32) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ahci_mem_read_32 " "ahci(%p): mem read @ 0x%"PRIx64": 0x%08x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, addr, val);
    }
}

static inline void trace_ahci_mem_read_32(void * s, uint64_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_ahci_mem_read_32(s, addr, val);
    }
}

#define TRACE_AHCI_MEM_READ_32_DEFAULT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_MEM_READ_32_DEFAULT) || \
    false)

static inline void _nocheck__trace_ahci_mem_read_32_default(void * s, uint64_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_AHCI_MEM_READ_32_DEFAULT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ahci_mem_read_32_default " "ahci(%p): mem read @ 0x%"PRIx64": 0x%08x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, addr, val);
    }
}

static inline void trace_ahci_mem_read_32_default(void * s, uint64_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_ahci_mem_read_32_default(s, addr, val);
    }
}

#define TRACE_AHCI_MEM_READ_32_HOST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_MEM_READ_32_HOST) || \
    false)

static inline void _nocheck__trace_ahci_mem_read_32_host(void * s, const char * reg, uint64_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_AHCI_MEM_READ_32_HOST) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ahci_mem_read_32_host " "ahci(%p): mem read [reg:%s] @ 0x%"PRIx64": 0x%08x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, reg, addr, val);
    }
}

static inline void trace_ahci_mem_read_32_host(void * s, const char * reg, uint64_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_ahci_mem_read_32_host(s, reg, addr, val);
    }
}

#define TRACE_AHCI_MEM_READ_32_HOST_DEFAULT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_MEM_READ_32_HOST_DEFAULT) || \
    false)

static inline void _nocheck__trace_ahci_mem_read_32_host_default(void * s, const char * reg, uint64_t addr)
{
    if (trace_event_get_state(TRACE_AHCI_MEM_READ_32_HOST_DEFAULT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ahci_mem_read_32_host_default " "ahci(%p): unimplemented mem read [reg:%s] @ 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, reg, addr);
    }
}

static inline void trace_ahci_mem_read_32_host_default(void * s, const char * reg, uint64_t addr)
{
    if (true) {
        _nocheck__trace_ahci_mem_read_32_host_default(s, reg, addr);
    }
}

#define TRACE_AHCI_MEM_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_MEM_READ) || \
    false)

static inline void _nocheck__trace_ahci_mem_read(void * s, unsigned size, uint64_t addr, uint64_t val)
{
    if (trace_event_get_state(TRACE_AHCI_MEM_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ahci_mem_read " "ahci(%p): read%u @ 0x%"PRIx64": 0x%016"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, size, addr, val);
    }
}

static inline void trace_ahci_mem_read(void * s, unsigned size, uint64_t addr, uint64_t val)
{
    if (true) {
        _nocheck__trace_ahci_mem_read(s, size, addr, val);
    }
}

#define TRACE_AHCI_MEM_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_MEM_WRITE) || \
    false)

static inline void _nocheck__trace_ahci_mem_write(void * s, unsigned size, uint64_t addr, uint64_t val)
{
    if (trace_event_get_state(TRACE_AHCI_MEM_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ahci_mem_write " "ahci(%p): write%u @ 0x%"PRIx64": 0x%016"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, size, addr, val);
    }
}

static inline void trace_ahci_mem_write(void * s, unsigned size, uint64_t addr, uint64_t val)
{
    if (true) {
        _nocheck__trace_ahci_mem_write(s, size, addr, val);
    }
}

#define TRACE_AHCI_MEM_WRITE_HOST_UNIMPL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_MEM_WRITE_HOST_UNIMPL) || \
    false)

static inline void _nocheck__trace_ahci_mem_write_host_unimpl(void * s, unsigned size, const char * reg, uint64_t addr)
{
    if (trace_event_get_state(TRACE_AHCI_MEM_WRITE_HOST_UNIMPL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ahci_mem_write_host_unimpl " "ahci(%p) unimplemented write%u [reg:%s] @ 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, size, reg, addr);
    }
}

static inline void trace_ahci_mem_write_host_unimpl(void * s, unsigned size, const char * reg, uint64_t addr)
{
    if (true) {
        _nocheck__trace_ahci_mem_write_host_unimpl(s, size, reg, addr);
    }
}

#define TRACE_AHCI_MEM_WRITE_HOST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_MEM_WRITE_HOST) || \
    false)

static inline void _nocheck__trace_ahci_mem_write_host(void * s, unsigned size, const char * reg, uint64_t addr, uint64_t val)
{
    if (trace_event_get_state(TRACE_AHCI_MEM_WRITE_HOST) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ahci_mem_write_host " "ahci(%p) write%u [reg:%s] @ 0x%"PRIx64": 0x%016"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, size, reg, addr, val);
    }
}

static inline void trace_ahci_mem_write_host(void * s, unsigned size, const char * reg, uint64_t addr, uint64_t val)
{
    if (true) {
        _nocheck__trace_ahci_mem_write_host(s, size, reg, addr, val);
    }
}

#define TRACE_AHCI_MEM_WRITE_UNIMPL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_MEM_WRITE_UNIMPL) || \
    false)

static inline void _nocheck__trace_ahci_mem_write_unimpl(void * s, unsigned size, uint64_t addr, uint64_t val)
{
    if (trace_event_get_state(TRACE_AHCI_MEM_WRITE_UNIMPL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ahci_mem_write_unimpl " "ahci(%p): write%u to unknown register 0x%"PRIx64": 0x%016"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, size, addr, val);
    }
}

static inline void trace_ahci_mem_write_unimpl(void * s, unsigned size, uint64_t addr, uint64_t val)
{
    if (true) {
        _nocheck__trace_ahci_mem_write_unimpl(s, size, addr, val);
    }
}

#define TRACE_AHCI_SET_SIGNATURE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_SET_SIGNATURE) || \
    false)

static inline void _nocheck__trace_ahci_set_signature(void * s, int port, uint8_t nsector, uint8_t sector, uint8_t lcyl, uint8_t hcyl, uint32_t sig)
{
    if (trace_event_get_state(TRACE_AHCI_SET_SIGNATURE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ahci_set_signature " "ahci(%p)[%d]: set signature sector:0x%02x nsector:0x%02x lcyl:0x%02x hcyl:0x%02x (cumulatively: 0x%08x)" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port, nsector, sector, lcyl, hcyl, sig);
    }
}

static inline void trace_ahci_set_signature(void * s, int port, uint8_t nsector, uint8_t sector, uint8_t lcyl, uint8_t hcyl, uint32_t sig)
{
    if (true) {
        _nocheck__trace_ahci_set_signature(s, port, nsector, sector, lcyl, hcyl, sig);
    }
}

#define TRACE_AHCI_RESET_PORT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_RESET_PORT) || \
    false)

static inline void _nocheck__trace_ahci_reset_port(void * s, int port)
{
    if (trace_event_get_state(TRACE_AHCI_RESET_PORT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ahci_reset_port " "ahci(%p)[%d]: reset port" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port);
    }
}

static inline void trace_ahci_reset_port(void * s, int port)
{
    if (true) {
        _nocheck__trace_ahci_reset_port(s, port);
    }
}

#define TRACE_AHCI_UNMAP_FIS_ADDRESS_NULL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_UNMAP_FIS_ADDRESS_NULL) || \
    false)

static inline void _nocheck__trace_ahci_unmap_fis_address_null(void * s, int port)
{
    if (trace_event_get_state(TRACE_AHCI_UNMAP_FIS_ADDRESS_NULL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ahci_unmap_fis_address_null " "ahci(%p)[%d]: Attempt to unmap NULL FIS address" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port);
    }
}

static inline void trace_ahci_unmap_fis_address_null(void * s, int port)
{
    if (true) {
        _nocheck__trace_ahci_unmap_fis_address_null(s, port);
    }
}

#define TRACE_AHCI_UNMAP_CLB_ADDRESS_NULL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_UNMAP_CLB_ADDRESS_NULL) || \
    false)

static inline void _nocheck__trace_ahci_unmap_clb_address_null(void * s, int port)
{
    if (trace_event_get_state(TRACE_AHCI_UNMAP_CLB_ADDRESS_NULL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ahci_unmap_clb_address_null " "ahci(%p)[%d]: Attempt to unmap NULL CLB address" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port);
    }
}

static inline void trace_ahci_unmap_clb_address_null(void * s, int port)
{
    if (true) {
        _nocheck__trace_ahci_unmap_clb_address_null(s, port);
    }
}

#define TRACE_AHCI_POPULATE_SGLIST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_POPULATE_SGLIST) || \
    false)

static inline void _nocheck__trace_ahci_populate_sglist(void * s, int port)
{
    if (trace_event_get_state(TRACE_AHCI_POPULATE_SGLIST) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ahci_populate_sglist " "ahci(%p)[%d]" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port);
    }
}

static inline void trace_ahci_populate_sglist(void * s, int port)
{
    if (true) {
        _nocheck__trace_ahci_populate_sglist(s, port);
    }
}

#define TRACE_AHCI_POPULATE_SGLIST_NO_PRDTL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_POPULATE_SGLIST_NO_PRDTL) || \
    false)

static inline void _nocheck__trace_ahci_populate_sglist_no_prdtl(void * s, int port, uint16_t opts)
{
    if (trace_event_get_state(TRACE_AHCI_POPULATE_SGLIST_NO_PRDTL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ahci_populate_sglist_no_prdtl " "ahci(%p)[%d]: no sg list given by guest: 0x%04x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port, opts);
    }
}

static inline void trace_ahci_populate_sglist_no_prdtl(void * s, int port, uint16_t opts)
{
    if (true) {
        _nocheck__trace_ahci_populate_sglist_no_prdtl(s, port, opts);
    }
}

#define TRACE_AHCI_POPULATE_SGLIST_NO_MAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_POPULATE_SGLIST_NO_MAP) || \
    false)

static inline void _nocheck__trace_ahci_populate_sglist_no_map(void * s, int port)
{
    if (trace_event_get_state(TRACE_AHCI_POPULATE_SGLIST_NO_MAP) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ahci_populate_sglist_no_map " "ahci(%p)[%d]: DMA mapping failed" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port);
    }
}

static inline void trace_ahci_populate_sglist_no_map(void * s, int port)
{
    if (true) {
        _nocheck__trace_ahci_populate_sglist_no_map(s, port);
    }
}

#define TRACE_AHCI_POPULATE_SGLIST_SHORT_MAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_POPULATE_SGLIST_SHORT_MAP) || \
    false)

static inline void _nocheck__trace_ahci_populate_sglist_short_map(void * s, int port)
{
    if (trace_event_get_state(TRACE_AHCI_POPULATE_SGLIST_SHORT_MAP) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ahci_populate_sglist_short_map " "ahci(%p)[%d]: mapped less than expected" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port);
    }
}

static inline void trace_ahci_populate_sglist_short_map(void * s, int port)
{
    if (true) {
        _nocheck__trace_ahci_populate_sglist_short_map(s, port);
    }
}

#define TRACE_AHCI_POPULATE_SGLIST_BAD_OFFSET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_POPULATE_SGLIST_BAD_OFFSET) || \
    false)

static inline void _nocheck__trace_ahci_populate_sglist_bad_offset(void * s, int port, int off_idx, int64_t off_pos)
{
    if (trace_event_get_state(TRACE_AHCI_POPULATE_SGLIST_BAD_OFFSET) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ahci_populate_sglist_bad_offset " "ahci(%p)[%d]: Incorrect offset! off_idx: %d, off_pos: %"PRId64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port, off_idx, off_pos);
    }
}

static inline void trace_ahci_populate_sglist_bad_offset(void * s, int port, int off_idx, int64_t off_pos)
{
    if (true) {
        _nocheck__trace_ahci_populate_sglist_bad_offset(s, port, off_idx, off_pos);
    }
}

#define TRACE_NCQ_FINISH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NCQ_FINISH) || \
    false)

static inline void _nocheck__trace_ncq_finish(void * s, int port, uint8_t tag)
{
    if (trace_event_get_state(TRACE_NCQ_FINISH) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ncq_finish " "ahci(%p)[%d][tag:%d]: NCQ transfer finished" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port, tag);
    }
}

static inline void trace_ncq_finish(void * s, int port, uint8_t tag)
{
    if (true) {
        _nocheck__trace_ncq_finish(s, port, tag);
    }
}

#define TRACE_EXECUTE_NCQ_COMMAND_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXECUTE_NCQ_COMMAND_READ) || \
    false)

static inline void _nocheck__trace_execute_ncq_command_read(void * s, int port, uint8_t tag, int count, int64_t lba)
{
    if (trace_event_get_state(TRACE_EXECUTE_NCQ_COMMAND_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:execute_ncq_command_read " "ahci(%p)[%d][tag:%d]: NCQ reading %d sectors from LBA %"PRId64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port, tag, count, lba);
    }
}

static inline void trace_execute_ncq_command_read(void * s, int port, uint8_t tag, int count, int64_t lba)
{
    if (true) {
        _nocheck__trace_execute_ncq_command_read(s, port, tag, count, lba);
    }
}

#define TRACE_EXECUTE_NCQ_COMMAND_UNSUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXECUTE_NCQ_COMMAND_UNSUP) || \
    false)

static inline void _nocheck__trace_execute_ncq_command_unsup(void * s, int port, uint8_t tag, uint8_t cmd)
{
    if (trace_event_get_state(TRACE_EXECUTE_NCQ_COMMAND_UNSUP) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:execute_ncq_command_unsup " "ahci(%p)[%d][tag:%d]: error: unsupported NCQ command (0x%02x) received" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port, tag, cmd);
    }
}

static inline void trace_execute_ncq_command_unsup(void * s, int port, uint8_t tag, uint8_t cmd)
{
    if (true) {
        _nocheck__trace_execute_ncq_command_unsup(s, port, tag, cmd);
    }
}

#define TRACE_PROCESS_NCQ_COMMAND_MISMATCH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PROCESS_NCQ_COMMAND_MISMATCH) || \
    false)

static inline void _nocheck__trace_process_ncq_command_mismatch(void * s, int port, uint8_t tag, uint8_t slot)
{
    if (trace_event_get_state(TRACE_PROCESS_NCQ_COMMAND_MISMATCH) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:process_ncq_command_mismatch " "ahci(%p)[%d][tag:%d]: Warning: NCQ slot (%d) did not match the given tag" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port, tag, slot);
    }
}

static inline void trace_process_ncq_command_mismatch(void * s, int port, uint8_t tag, uint8_t slot)
{
    if (true) {
        _nocheck__trace_process_ncq_command_mismatch(s, port, tag, slot);
    }
}

#define TRACE_PROCESS_NCQ_COMMAND_AUX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PROCESS_NCQ_COMMAND_AUX) || \
    false)

static inline void _nocheck__trace_process_ncq_command_aux(void * s, int port, uint8_t tag)
{
    if (trace_event_get_state(TRACE_PROCESS_NCQ_COMMAND_AUX) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:process_ncq_command_aux " "ahci(%p)[%d][tag:%d]: Warn: Attempt to use NCQ auxiliary fields" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port, tag);
    }
}

static inline void trace_process_ncq_command_aux(void * s, int port, uint8_t tag)
{
    if (true) {
        _nocheck__trace_process_ncq_command_aux(s, port, tag);
    }
}

#define TRACE_PROCESS_NCQ_COMMAND_PRIOICC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PROCESS_NCQ_COMMAND_PRIOICC) || \
    false)

static inline void _nocheck__trace_process_ncq_command_prioicc(void * s, int port, uint8_t tag)
{
    if (trace_event_get_state(TRACE_PROCESS_NCQ_COMMAND_PRIOICC) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:process_ncq_command_prioicc " "ahci(%p)[%d][tag:%d]: Warn: Unsupported attempt to use PRIO/ICC fields" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port, tag);
    }
}

static inline void trace_process_ncq_command_prioicc(void * s, int port, uint8_t tag)
{
    if (true) {
        _nocheck__trace_process_ncq_command_prioicc(s, port, tag);
    }
}

#define TRACE_PROCESS_NCQ_COMMAND_FUA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PROCESS_NCQ_COMMAND_FUA) || \
    false)

static inline void _nocheck__trace_process_ncq_command_fua(void * s, int port, uint8_t tag)
{
    if (trace_event_get_state(TRACE_PROCESS_NCQ_COMMAND_FUA) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:process_ncq_command_fua " "ahci(%p)[%d][tag:%d]: Warn: Unsupported attempt to use Force Unit Access" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port, tag);
    }
}

static inline void trace_process_ncq_command_fua(void * s, int port, uint8_t tag)
{
    if (true) {
        _nocheck__trace_process_ncq_command_fua(s, port, tag);
    }
}

#define TRACE_PROCESS_NCQ_COMMAND_RARC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PROCESS_NCQ_COMMAND_RARC) || \
    false)

static inline void _nocheck__trace_process_ncq_command_rarc(void * s, int port, uint8_t tag)
{
    if (trace_event_get_state(TRACE_PROCESS_NCQ_COMMAND_RARC) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:process_ncq_command_rarc " "ahci(%p)[%d][tag:%d]: Warn: Unsupported attempt to use Rebuild Assist" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port, tag);
    }
}

static inline void trace_process_ncq_command_rarc(void * s, int port, uint8_t tag)
{
    if (true) {
        _nocheck__trace_process_ncq_command_rarc(s, port, tag);
    }
}

#define TRACE_PROCESS_NCQ_COMMAND_LARGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PROCESS_NCQ_COMMAND_LARGE) || \
    false)

static inline void _nocheck__trace_process_ncq_command_large(void * s, int port, uint8_t tag, size_t prdtl, size_t size)
{
    if (trace_event_get_state(TRACE_PROCESS_NCQ_COMMAND_LARGE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:process_ncq_command_large " "ahci(%p)[%d][tag:%d]: Warn: PRDTL (0x%zx) does not match requested size (0x%zx)" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port, tag, prdtl, size);
    }
}

static inline void trace_process_ncq_command_large(void * s, int port, uint8_t tag, size_t prdtl, size_t size)
{
    if (true) {
        _nocheck__trace_process_ncq_command_large(s, port, tag, prdtl, size);
    }
}

#define TRACE_PROCESS_NCQ_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PROCESS_NCQ_COMMAND) || \
    false)

static inline void _nocheck__trace_process_ncq_command(void * s, int port, uint8_t tag, uint8_t cmd, uint64_t lba, uint64_t end)
{
    if (trace_event_get_state(TRACE_PROCESS_NCQ_COMMAND) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:process_ncq_command " "ahci(%p)[%d][tag:%d]: NCQ op 0x%02x on sectors [%"PRId64",%"PRId64"]" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port, tag, cmd, lba, end);
    }
}

static inline void trace_process_ncq_command(void * s, int port, uint8_t tag, uint8_t cmd, uint64_t lba, uint64_t end)
{
    if (true) {
        _nocheck__trace_process_ncq_command(s, port, tag, cmd, lba, end);
    }
}

#define TRACE_HANDLE_REG_H2D_FIS_PMP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HANDLE_REG_H2D_FIS_PMP) || \
    false)

static inline void _nocheck__trace_handle_reg_h2d_fis_pmp(void * s, int port, char b0, char b1, char b2)
{
    if (trace_event_get_state(TRACE_HANDLE_REG_H2D_FIS_PMP) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:handle_reg_h2d_fis_pmp " "ahci(%p)[%d]: Port Multiplier not supported, FIS: 0x%02x-%02x-%02x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port, b0, b1, b2);
    }
}

static inline void trace_handle_reg_h2d_fis_pmp(void * s, int port, char b0, char b1, char b2)
{
    if (true) {
        _nocheck__trace_handle_reg_h2d_fis_pmp(s, port, b0, b1, b2);
    }
}

#define TRACE_HANDLE_REG_H2D_FIS_RES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HANDLE_REG_H2D_FIS_RES) || \
    false)

static inline void _nocheck__trace_handle_reg_h2d_fis_res(void * s, int port, char b0, char b1, char b2)
{
    if (trace_event_get_state(TRACE_HANDLE_REG_H2D_FIS_RES) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:handle_reg_h2d_fis_res " "ahci(%p)[%d]: Reserved flags set in H2D Register FIS, FIS: 0x%02x-%02x-%02x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port, b0, b1, b2);
    }
}

static inline void trace_handle_reg_h2d_fis_res(void * s, int port, char b0, char b1, char b2)
{
    if (true) {
        _nocheck__trace_handle_reg_h2d_fis_res(s, port, b0, b1, b2);
    }
}

#define TRACE_HANDLE_CMD_BUSY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HANDLE_CMD_BUSY) || \
    false)

static inline void _nocheck__trace_handle_cmd_busy(void * s, int port)
{
    if (trace_event_get_state(TRACE_HANDLE_CMD_BUSY) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:handle_cmd_busy " "ahci(%p)[%d]: engine busy" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port);
    }
}

static inline void trace_handle_cmd_busy(void * s, int port)
{
    if (true) {
        _nocheck__trace_handle_cmd_busy(s, port);
    }
}

#define TRACE_HANDLE_CMD_NOLIST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HANDLE_CMD_NOLIST) || \
    false)

static inline void _nocheck__trace_handle_cmd_nolist(void * s, int port)
{
    if (trace_event_get_state(TRACE_HANDLE_CMD_NOLIST) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:handle_cmd_nolist " "ahci(%p)[%d]: handle_cmd called without s->dev[port].lst" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port);
    }
}

static inline void trace_handle_cmd_nolist(void * s, int port)
{
    if (true) {
        _nocheck__trace_handle_cmd_nolist(s, port);
    }
}

#define TRACE_HANDLE_CMD_BADPORT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HANDLE_CMD_BADPORT) || \
    false)

static inline void _nocheck__trace_handle_cmd_badport(void * s, int port)
{
    if (trace_event_get_state(TRACE_HANDLE_CMD_BADPORT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:handle_cmd_badport " "ahci(%p)[%d]: guest accessed unused port" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port);
    }
}

static inline void trace_handle_cmd_badport(void * s, int port)
{
    if (true) {
        _nocheck__trace_handle_cmd_badport(s, port);
    }
}

#define TRACE_HANDLE_CMD_BADFIS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HANDLE_CMD_BADFIS) || \
    false)

static inline void _nocheck__trace_handle_cmd_badfis(void * s, int port)
{
    if (trace_event_get_state(TRACE_HANDLE_CMD_BADFIS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:handle_cmd_badfis " "ahci(%p)[%d]: guest provided an invalid cmd FIS" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port);
    }
}

static inline void trace_handle_cmd_badfis(void * s, int port)
{
    if (true) {
        _nocheck__trace_handle_cmd_badfis(s, port);
    }
}

#define TRACE_HANDLE_CMD_BADMAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HANDLE_CMD_BADMAP) || \
    false)

static inline void _nocheck__trace_handle_cmd_badmap(void * s, int port, uint64_t len)
{
    if (trace_event_get_state(TRACE_HANDLE_CMD_BADMAP) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:handle_cmd_badmap " "ahci(%p)[%d]: dma_memory_map failed, 0x%02"PRIx64" != 0x80" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port, len);
    }
}

static inline void trace_handle_cmd_badmap(void * s, int port, uint64_t len)
{
    if (true) {
        _nocheck__trace_handle_cmd_badmap(s, port, len);
    }
}

#define TRACE_HANDLE_CMD_UNHANDLED_FIS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HANDLE_CMD_UNHANDLED_FIS) || \
    false)

static inline void _nocheck__trace_handle_cmd_unhandled_fis(void * s, int port, uint8_t b0, uint8_t b1, uint8_t b2)
{
    if (trace_event_get_state(TRACE_HANDLE_CMD_UNHANDLED_FIS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:handle_cmd_unhandled_fis " "ahci(%p)[%d]: unhandled FIS type. cmd_fis: 0x%02x-%02x-%02x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port, b0, b1, b2);
    }
}

static inline void trace_handle_cmd_unhandled_fis(void * s, int port, uint8_t b0, uint8_t b1, uint8_t b2)
{
    if (true) {
        _nocheck__trace_handle_cmd_unhandled_fis(s, port, b0, b1, b2);
    }
}

#define TRACE_AHCI_PIO_TRANSFER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_PIO_TRANSFER) || \
    false)

static inline void _nocheck__trace_ahci_pio_transfer(void * s, int port, const char * rw, uint32_t size, const char * tgt, const char * sgl)
{
    if (trace_event_get_state(TRACE_AHCI_PIO_TRANSFER) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ahci_pio_transfer " "ahci(%p)[%d]: %sing %d bytes on %s w/%s sglist" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port, rw, size, tgt, sgl);
    }
}

static inline void trace_ahci_pio_transfer(void * s, int port, const char * rw, uint32_t size, const char * tgt, const char * sgl)
{
    if (true) {
        _nocheck__trace_ahci_pio_transfer(s, port, rw, size, tgt, sgl);
    }
}

#define TRACE_AHCI_START_DMA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_START_DMA) || \
    false)

static inline void _nocheck__trace_ahci_start_dma(void * s, int port)
{
    if (trace_event_get_state(TRACE_AHCI_START_DMA) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ahci_start_dma " "ahci(%p)[%d]: start dma" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port);
    }
}

static inline void trace_ahci_start_dma(void * s, int port)
{
    if (true) {
        _nocheck__trace_ahci_start_dma(s, port);
    }
}

#define TRACE_AHCI_DMA_PREPARE_BUF_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_DMA_PREPARE_BUF) || \
    false)

static inline void _nocheck__trace_ahci_dma_prepare_buf(void * s, int port, int32_t io_buffer_size, int32_t limit)
{
    if (trace_event_get_state(TRACE_AHCI_DMA_PREPARE_BUF) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ahci_dma_prepare_buf " "ahci(%p)[%d]: prepare buf limit=%"PRId32" prepared=%"PRId32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port, io_buffer_size, limit);
    }
}

static inline void trace_ahci_dma_prepare_buf(void * s, int port, int32_t io_buffer_size, int32_t limit)
{
    if (true) {
        _nocheck__trace_ahci_dma_prepare_buf(s, port, io_buffer_size, limit);
    }
}

#define TRACE_AHCI_DMA_PREPARE_BUF_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_DMA_PREPARE_BUF_FAIL) || \
    false)

static inline void _nocheck__trace_ahci_dma_prepare_buf_fail(void * s, int port)
{
    if (trace_event_get_state(TRACE_AHCI_DMA_PREPARE_BUF_FAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ahci_dma_prepare_buf_fail " "ahci(%p)[%d]: sglist population failed" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port);
    }
}

static inline void trace_ahci_dma_prepare_buf_fail(void * s, int port)
{
    if (true) {
        _nocheck__trace_ahci_dma_prepare_buf_fail(s, port);
    }
}

#define TRACE_AHCI_DMA_RW_BUF_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_DMA_RW_BUF) || \
    false)

static inline void _nocheck__trace_ahci_dma_rw_buf(void * s, int port, int l)
{
    if (trace_event_get_state(TRACE_AHCI_DMA_RW_BUF) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ahci_dma_rw_buf " "ahci(%p)[%d] len=0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port, l);
    }
}

static inline void trace_ahci_dma_rw_buf(void * s, int port, int l)
{
    if (true) {
        _nocheck__trace_ahci_dma_rw_buf(s, port, l);
    }
}

#define TRACE_AHCI_CMD_DONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_CMD_DONE) || \
    false)

static inline void _nocheck__trace_ahci_cmd_done(void * s, int port)
{
    if (trace_event_get_state(TRACE_AHCI_CMD_DONE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ahci_cmd_done " "ahci(%p)[%d]: cmd done" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port);
    }
}

static inline void trace_ahci_cmd_done(void * s, int port)
{
    if (true) {
        _nocheck__trace_ahci_cmd_done(s, port);
    }
}

#define TRACE_AHCI_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_RESET) || \
    false)

static inline void _nocheck__trace_ahci_reset(void * s)
{
    if (trace_event_get_state(TRACE_AHCI_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:ahci_reset " "ahci(%p): HBA reset" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s);
    }
}

static inline void trace_ahci_reset(void * s)
{
    if (true) {
        _nocheck__trace_ahci_reset(s);
    }
}

#define TRACE_HANDLE_REG_H2D_FIS_DUMP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HANDLE_REG_H2D_FIS_DUMP) || \
    false)

static inline void _nocheck__trace_handle_reg_h2d_fis_dump(void * s, int port, const char * fis)
{
    if (trace_event_get_state(TRACE_HANDLE_REG_H2D_FIS_DUMP) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:handle_reg_h2d_fis_dump " "ahci(%p)[%d]: %s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port, fis);
    }
}

static inline void trace_handle_reg_h2d_fis_dump(void * s, int port, const char * fis)
{
    if (true) {
        _nocheck__trace_handle_reg_h2d_fis_dump(s, port, fis);
    }
}

#define TRACE_HANDLE_CMD_FIS_DUMP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HANDLE_CMD_FIS_DUMP) || \
    false)

static inline void _nocheck__trace_handle_cmd_fis_dump(void * s, int port, const char * fis)
{
    if (trace_event_get_state(TRACE_HANDLE_CMD_FIS_DUMP) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:handle_cmd_fis_dump " "ahci(%p)[%d]: %s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, port, fis);
    }
}

static inline void trace_handle_cmd_fis_dump(void * s, int port, const char * fis)
{
    if (true) {
        _nocheck__trace_handle_cmd_fis_dump(s, port, fis);
    }
}

#define TRACE_ALLWINNER_AHCI_MEM_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ALLWINNER_AHCI_MEM_READ) || \
    false)

static inline void _nocheck__trace_allwinner_ahci_mem_read(void * s, void * a, uint64_t addr, uint64_t val, unsigned size)
{
    if (trace_event_get_state(TRACE_ALLWINNER_AHCI_MEM_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:allwinner_ahci_mem_read " "ahci(%p): read a=%p addr=0x%"PRIx64" val=0x%"PRIx64", size=%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, a, addr, val, size);
    }
}

static inline void trace_allwinner_ahci_mem_read(void * s, void * a, uint64_t addr, uint64_t val, unsigned size)
{
    if (true) {
        _nocheck__trace_allwinner_ahci_mem_read(s, a, addr, val, size);
    }
}

#define TRACE_ALLWINNER_AHCI_MEM_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ALLWINNER_AHCI_MEM_WRITE) || \
    false)

static inline void _nocheck__trace_allwinner_ahci_mem_write(void * s, void * a, uint64_t addr, uint64_t val, unsigned size)
{
    if (trace_event_get_state(TRACE_ALLWINNER_AHCI_MEM_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:allwinner_ahci_mem_write " "ahci(%p): write a=%p addr=0x%"PRIx64" val=0x%"PRIx64", size=%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , s, a, addr, val, size);
    }
}

static inline void trace_allwinner_ahci_mem_write(void * s, void * a, uint64_t addr, uint64_t val, unsigned size)
{
    if (true) {
        _nocheck__trace_allwinner_ahci_mem_write(s, a, addr, val, size);
    }
}
#endif /* TRACE_HW_IDE_GENERATED_TRACERS_H */
