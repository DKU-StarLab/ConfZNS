/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_MONITOR_GENERATED_TRACERS_H
#define TRACE_MONITOR_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_HANDLE_HMP_COMMAND_EVENT;
extern TraceEvent _TRACE_MONITOR_PROTOCOL_EVENT_HANDLER_EVENT;
extern TraceEvent _TRACE_MONITOR_PROTOCOL_EVENT_EMIT_EVENT;
extern TraceEvent _TRACE_MONITOR_PROTOCOL_EVENT_QUEUE_EVENT;
extern TraceEvent _TRACE_MONITOR_SUSPEND_EVENT;
extern TraceEvent _TRACE_MONITOR_QMP_CMD_IN_BAND_EVENT;
extern TraceEvent _TRACE_MONITOR_QMP_CMD_OUT_OF_BAND_EVENT;
extern TraceEvent _TRACE_HANDLE_QMP_COMMAND_EVENT;
extern uint16_t _TRACE_HANDLE_HMP_COMMAND_DSTATE;
extern uint16_t _TRACE_MONITOR_PROTOCOL_EVENT_HANDLER_DSTATE;
extern uint16_t _TRACE_MONITOR_PROTOCOL_EVENT_EMIT_DSTATE;
extern uint16_t _TRACE_MONITOR_PROTOCOL_EVENT_QUEUE_DSTATE;
extern uint16_t _TRACE_MONITOR_SUSPEND_DSTATE;
extern uint16_t _TRACE_MONITOR_QMP_CMD_IN_BAND_DSTATE;
extern uint16_t _TRACE_MONITOR_QMP_CMD_OUT_OF_BAND_DSTATE;
extern uint16_t _TRACE_HANDLE_QMP_COMMAND_DSTATE;
#define TRACE_HANDLE_HMP_COMMAND_ENABLED 1
#define TRACE_MONITOR_PROTOCOL_EVENT_HANDLER_ENABLED 1
#define TRACE_MONITOR_PROTOCOL_EVENT_EMIT_ENABLED 1
#define TRACE_MONITOR_PROTOCOL_EVENT_QUEUE_ENABLED 1
#define TRACE_MONITOR_SUSPEND_ENABLED 1
#define TRACE_MONITOR_QMP_CMD_IN_BAND_ENABLED 1
#define TRACE_MONITOR_QMP_CMD_OUT_OF_BAND_ENABLED 1
#define TRACE_HANDLE_QMP_COMMAND_ENABLED 1
#include "qemu/log-for-trace.h"


#define TRACE_HANDLE_HMP_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HANDLE_HMP_COMMAND) || \
    false)

static inline void _nocheck__trace_handle_hmp_command(void * mon, const char * cmdline)
{
    if (trace_event_get_state(TRACE_HANDLE_HMP_COMMAND) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:handle_hmp_command " "mon %p cmdline: %s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , mon, cmdline);
    }
}

static inline void trace_handle_hmp_command(void * mon, const char * cmdline)
{
    if (true) {
        _nocheck__trace_handle_hmp_command(mon, cmdline);
    }
}

#define TRACE_MONITOR_PROTOCOL_EVENT_HANDLER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MONITOR_PROTOCOL_EVENT_HANDLER) || \
    false)

static inline void _nocheck__trace_monitor_protocol_event_handler(uint32_t event, void * qdict)
{
    if (trace_event_get_state(TRACE_MONITOR_PROTOCOL_EVENT_HANDLER) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:monitor_protocol_event_handler " "event=%d data=%p" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , event, qdict);
    }
}

static inline void trace_monitor_protocol_event_handler(uint32_t event, void * qdict)
{
    if (true) {
        _nocheck__trace_monitor_protocol_event_handler(event, qdict);
    }
}

#define TRACE_MONITOR_PROTOCOL_EVENT_EMIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MONITOR_PROTOCOL_EVENT_EMIT) || \
    false)

static inline void _nocheck__trace_monitor_protocol_event_emit(uint32_t event, void * data)
{
    if (trace_event_get_state(TRACE_MONITOR_PROTOCOL_EVENT_EMIT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:monitor_protocol_event_emit " "event=%d data=%p" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , event, data);
    }
}

static inline void trace_monitor_protocol_event_emit(uint32_t event, void * data)
{
    if (true) {
        _nocheck__trace_monitor_protocol_event_emit(event, data);
    }
}

#define TRACE_MONITOR_PROTOCOL_EVENT_QUEUE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MONITOR_PROTOCOL_EVENT_QUEUE) || \
    false)

static inline void _nocheck__trace_monitor_protocol_event_queue(uint32_t event, void * qdict, uint64_t rate)
{
    if (trace_event_get_state(TRACE_MONITOR_PROTOCOL_EVENT_QUEUE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:monitor_protocol_event_queue " "event=%d data=%p rate=%" PRId64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , event, qdict, rate);
    }
}

static inline void trace_monitor_protocol_event_queue(uint32_t event, void * qdict, uint64_t rate)
{
    if (true) {
        _nocheck__trace_monitor_protocol_event_queue(event, qdict, rate);
    }
}

#define TRACE_MONITOR_SUSPEND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MONITOR_SUSPEND) || \
    false)

static inline void _nocheck__trace_monitor_suspend(void * ptr, int cnt)
{
    if (trace_event_get_state(TRACE_MONITOR_SUSPEND) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:monitor_suspend " "mon %p: %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , ptr, cnt);
    }
}

static inline void trace_monitor_suspend(void * ptr, int cnt)
{
    if (true) {
        _nocheck__trace_monitor_suspend(ptr, cnt);
    }
}

#define TRACE_MONITOR_QMP_CMD_IN_BAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MONITOR_QMP_CMD_IN_BAND) || \
    false)

static inline void _nocheck__trace_monitor_qmp_cmd_in_band(const char * id)
{
    if (trace_event_get_state(TRACE_MONITOR_QMP_CMD_IN_BAND) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:monitor_qmp_cmd_in_band " "%s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , id);
    }
}

static inline void trace_monitor_qmp_cmd_in_band(const char * id)
{
    if (true) {
        _nocheck__trace_monitor_qmp_cmd_in_band(id);
    }
}

#define TRACE_MONITOR_QMP_CMD_OUT_OF_BAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MONITOR_QMP_CMD_OUT_OF_BAND) || \
    false)

static inline void _nocheck__trace_monitor_qmp_cmd_out_of_band(const char * id)
{
    if (trace_event_get_state(TRACE_MONITOR_QMP_CMD_OUT_OF_BAND) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:monitor_qmp_cmd_out_of_band " "%s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , id);
    }
}

static inline void trace_monitor_qmp_cmd_out_of_band(const char * id)
{
    if (true) {
        _nocheck__trace_monitor_qmp_cmd_out_of_band(id);
    }
}

#define TRACE_HANDLE_QMP_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HANDLE_QMP_COMMAND) || \
    false)

static inline void _nocheck__trace_handle_qmp_command(void * mon, const char * req)
{
    if (trace_event_get_state(TRACE_HANDLE_QMP_COMMAND) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:handle_qmp_command " "mon %p req: %s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , mon, req);
    }
}

static inline void trace_handle_qmp_command(void * mon, const char * req)
{
    if (true) {
        _nocheck__trace_handle_qmp_command(mon, req);
    }
}
#endif /* TRACE_MONITOR_GENERATED_TRACERS_H */
