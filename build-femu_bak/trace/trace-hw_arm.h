/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_ARM_GENERATED_TRACERS_H
#define TRACE_HW_ARM_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_VIRT_ACPI_SETUP_EVENT;
extern TraceEvent _TRACE_SMMU_ADD_MR_EVENT;
extern TraceEvent _TRACE_SMMU_PTW_LEVEL_EVENT;
extern TraceEvent _TRACE_SMMU_PTW_INVALID_PTE_EVENT;
extern TraceEvent _TRACE_SMMU_PTW_PAGE_PTE_EVENT;
extern TraceEvent _TRACE_SMMU_PTW_BLOCK_PTE_EVENT;
extern TraceEvent _TRACE_SMMU_GET_PTE_EVENT;
extern TraceEvent _TRACE_SMMU_IOTLB_INV_ALL_EVENT;
extern TraceEvent _TRACE_SMMU_IOTLB_INV_ASID_EVENT;
extern TraceEvent _TRACE_SMMU_IOTLB_INV_IOVA_EVENT;
extern TraceEvent _TRACE_SMMU_INV_NOTIFIERS_MR_EVENT;
extern TraceEvent _TRACE_SMMU_IOTLB_LOOKUP_HIT_EVENT;
extern TraceEvent _TRACE_SMMU_IOTLB_LOOKUP_MISS_EVENT;
extern TraceEvent _TRACE_SMMU_IOTLB_INSERT_EVENT;
extern TraceEvent _TRACE_SMMUV3_READ_MMIO_EVENT;
extern TraceEvent _TRACE_SMMUV3_TRIGGER_IRQ_EVENT;
extern TraceEvent _TRACE_SMMUV3_WRITE_GERROR_EVENT;
extern TraceEvent _TRACE_SMMUV3_WRITE_GERRORN_EVENT;
extern TraceEvent _TRACE_SMMUV3_UNHANDLED_CMD_EVENT;
extern TraceEvent _TRACE_SMMUV3_CMDQ_CONSUME_EVENT;
extern TraceEvent _TRACE_SMMUV3_CMDQ_OPCODE_EVENT;
extern TraceEvent _TRACE_SMMUV3_CMDQ_CONSUME_OUT_EVENT;
extern TraceEvent _TRACE_SMMUV3_CMDQ_CONSUME_ERROR_EVENT;
extern TraceEvent _TRACE_SMMUV3_WRITE_MMIO_EVENT;
extern TraceEvent _TRACE_SMMUV3_RECORD_EVENT_EVENT;
extern TraceEvent _TRACE_SMMUV3_FIND_STE_EVENT;
extern TraceEvent _TRACE_SMMUV3_FIND_STE_2LVL_EVENT;
extern TraceEvent _TRACE_SMMUV3_GET_STE_EVENT;
extern TraceEvent _TRACE_SMMUV3_TRANSLATE_DISABLE_EVENT;
extern TraceEvent _TRACE_SMMUV3_TRANSLATE_BYPASS_EVENT;
extern TraceEvent _TRACE_SMMUV3_TRANSLATE_ABORT_EVENT;
extern TraceEvent _TRACE_SMMUV3_TRANSLATE_SUCCESS_EVENT;
extern TraceEvent _TRACE_SMMUV3_GET_CD_EVENT;
extern TraceEvent _TRACE_SMMUV3_DECODE_CD_EVENT;
extern TraceEvent _TRACE_SMMUV3_DECODE_CD_TT_EVENT;
extern TraceEvent _TRACE_SMMUV3_CMDQ_CFGI_STE_EVENT;
extern TraceEvent _TRACE_SMMUV3_CMDQ_CFGI_STE_RANGE_EVENT;
extern TraceEvent _TRACE_SMMUV3_CMDQ_CFGI_CD_EVENT;
extern TraceEvent _TRACE_SMMUV3_CONFIG_CACHE_HIT_EVENT;
extern TraceEvent _TRACE_SMMUV3_CONFIG_CACHE_MISS_EVENT;
extern TraceEvent _TRACE_SMMUV3_S1_RANGE_INVAL_EVENT;
extern TraceEvent _TRACE_SMMUV3_CMDQ_TLBI_NH_EVENT;
extern TraceEvent _TRACE_SMMUV3_CMDQ_TLBI_NH_ASID_EVENT;
extern TraceEvent _TRACE_SMMUV3_CONFIG_CACHE_INV_EVENT;
extern TraceEvent _TRACE_SMMUV3_NOTIFY_FLAG_ADD_EVENT;
extern TraceEvent _TRACE_SMMUV3_NOTIFY_FLAG_DEL_EVENT;
extern TraceEvent _TRACE_SMMUV3_INV_NOTIFIERS_IOVA_EVENT;
extern uint16_t _TRACE_VIRT_ACPI_SETUP_DSTATE;
extern uint16_t _TRACE_SMMU_ADD_MR_DSTATE;
extern uint16_t _TRACE_SMMU_PTW_LEVEL_DSTATE;
extern uint16_t _TRACE_SMMU_PTW_INVALID_PTE_DSTATE;
extern uint16_t _TRACE_SMMU_PTW_PAGE_PTE_DSTATE;
extern uint16_t _TRACE_SMMU_PTW_BLOCK_PTE_DSTATE;
extern uint16_t _TRACE_SMMU_GET_PTE_DSTATE;
extern uint16_t _TRACE_SMMU_IOTLB_INV_ALL_DSTATE;
extern uint16_t _TRACE_SMMU_IOTLB_INV_ASID_DSTATE;
extern uint16_t _TRACE_SMMU_IOTLB_INV_IOVA_DSTATE;
extern uint16_t _TRACE_SMMU_INV_NOTIFIERS_MR_DSTATE;
extern uint16_t _TRACE_SMMU_IOTLB_LOOKUP_HIT_DSTATE;
extern uint16_t _TRACE_SMMU_IOTLB_LOOKUP_MISS_DSTATE;
extern uint16_t _TRACE_SMMU_IOTLB_INSERT_DSTATE;
extern uint16_t _TRACE_SMMUV3_READ_MMIO_DSTATE;
extern uint16_t _TRACE_SMMUV3_TRIGGER_IRQ_DSTATE;
extern uint16_t _TRACE_SMMUV3_WRITE_GERROR_DSTATE;
extern uint16_t _TRACE_SMMUV3_WRITE_GERRORN_DSTATE;
extern uint16_t _TRACE_SMMUV3_UNHANDLED_CMD_DSTATE;
extern uint16_t _TRACE_SMMUV3_CMDQ_CONSUME_DSTATE;
extern uint16_t _TRACE_SMMUV3_CMDQ_OPCODE_DSTATE;
extern uint16_t _TRACE_SMMUV3_CMDQ_CONSUME_OUT_DSTATE;
extern uint16_t _TRACE_SMMUV3_CMDQ_CONSUME_ERROR_DSTATE;
extern uint16_t _TRACE_SMMUV3_WRITE_MMIO_DSTATE;
extern uint16_t _TRACE_SMMUV3_RECORD_EVENT_DSTATE;
extern uint16_t _TRACE_SMMUV3_FIND_STE_DSTATE;
extern uint16_t _TRACE_SMMUV3_FIND_STE_2LVL_DSTATE;
extern uint16_t _TRACE_SMMUV3_GET_STE_DSTATE;
extern uint16_t _TRACE_SMMUV3_TRANSLATE_DISABLE_DSTATE;
extern uint16_t _TRACE_SMMUV3_TRANSLATE_BYPASS_DSTATE;
extern uint16_t _TRACE_SMMUV3_TRANSLATE_ABORT_DSTATE;
extern uint16_t _TRACE_SMMUV3_TRANSLATE_SUCCESS_DSTATE;
extern uint16_t _TRACE_SMMUV3_GET_CD_DSTATE;
extern uint16_t _TRACE_SMMUV3_DECODE_CD_DSTATE;
extern uint16_t _TRACE_SMMUV3_DECODE_CD_TT_DSTATE;
extern uint16_t _TRACE_SMMUV3_CMDQ_CFGI_STE_DSTATE;
extern uint16_t _TRACE_SMMUV3_CMDQ_CFGI_STE_RANGE_DSTATE;
extern uint16_t _TRACE_SMMUV3_CMDQ_CFGI_CD_DSTATE;
extern uint16_t _TRACE_SMMUV3_CONFIG_CACHE_HIT_DSTATE;
extern uint16_t _TRACE_SMMUV3_CONFIG_CACHE_MISS_DSTATE;
extern uint16_t _TRACE_SMMUV3_S1_RANGE_INVAL_DSTATE;
extern uint16_t _TRACE_SMMUV3_CMDQ_TLBI_NH_DSTATE;
extern uint16_t _TRACE_SMMUV3_CMDQ_TLBI_NH_ASID_DSTATE;
extern uint16_t _TRACE_SMMUV3_CONFIG_CACHE_INV_DSTATE;
extern uint16_t _TRACE_SMMUV3_NOTIFY_FLAG_ADD_DSTATE;
extern uint16_t _TRACE_SMMUV3_NOTIFY_FLAG_DEL_DSTATE;
extern uint16_t _TRACE_SMMUV3_INV_NOTIFIERS_IOVA_DSTATE;
#define TRACE_VIRT_ACPI_SETUP_ENABLED 1
#define TRACE_SMMU_ADD_MR_ENABLED 1
#define TRACE_SMMU_PTW_LEVEL_ENABLED 1
#define TRACE_SMMU_PTW_INVALID_PTE_ENABLED 1
#define TRACE_SMMU_PTW_PAGE_PTE_ENABLED 1
#define TRACE_SMMU_PTW_BLOCK_PTE_ENABLED 1
#define TRACE_SMMU_GET_PTE_ENABLED 1
#define TRACE_SMMU_IOTLB_INV_ALL_ENABLED 1
#define TRACE_SMMU_IOTLB_INV_ASID_ENABLED 1
#define TRACE_SMMU_IOTLB_INV_IOVA_ENABLED 1
#define TRACE_SMMU_INV_NOTIFIERS_MR_ENABLED 1
#define TRACE_SMMU_IOTLB_LOOKUP_HIT_ENABLED 1
#define TRACE_SMMU_IOTLB_LOOKUP_MISS_ENABLED 1
#define TRACE_SMMU_IOTLB_INSERT_ENABLED 1
#define TRACE_SMMUV3_READ_MMIO_ENABLED 1
#define TRACE_SMMUV3_TRIGGER_IRQ_ENABLED 1
#define TRACE_SMMUV3_WRITE_GERROR_ENABLED 1
#define TRACE_SMMUV3_WRITE_GERRORN_ENABLED 1
#define TRACE_SMMUV3_UNHANDLED_CMD_ENABLED 1
#define TRACE_SMMUV3_CMDQ_CONSUME_ENABLED 1
#define TRACE_SMMUV3_CMDQ_OPCODE_ENABLED 1
#define TRACE_SMMUV3_CMDQ_CONSUME_OUT_ENABLED 1
#define TRACE_SMMUV3_CMDQ_CONSUME_ERROR_ENABLED 1
#define TRACE_SMMUV3_WRITE_MMIO_ENABLED 1
#define TRACE_SMMUV3_RECORD_EVENT_ENABLED 1
#define TRACE_SMMUV3_FIND_STE_ENABLED 1
#define TRACE_SMMUV3_FIND_STE_2LVL_ENABLED 1
#define TRACE_SMMUV3_GET_STE_ENABLED 1
#define TRACE_SMMUV3_TRANSLATE_DISABLE_ENABLED 1
#define TRACE_SMMUV3_TRANSLATE_BYPASS_ENABLED 1
#define TRACE_SMMUV3_TRANSLATE_ABORT_ENABLED 1
#define TRACE_SMMUV3_TRANSLATE_SUCCESS_ENABLED 1
#define TRACE_SMMUV3_GET_CD_ENABLED 1
#define TRACE_SMMUV3_DECODE_CD_ENABLED 1
#define TRACE_SMMUV3_DECODE_CD_TT_ENABLED 1
#define TRACE_SMMUV3_CMDQ_CFGI_STE_ENABLED 1
#define TRACE_SMMUV3_CMDQ_CFGI_STE_RANGE_ENABLED 1
#define TRACE_SMMUV3_CMDQ_CFGI_CD_ENABLED 1
#define TRACE_SMMUV3_CONFIG_CACHE_HIT_ENABLED 1
#define TRACE_SMMUV3_CONFIG_CACHE_MISS_ENABLED 1
#define TRACE_SMMUV3_S1_RANGE_INVAL_ENABLED 1
#define TRACE_SMMUV3_CMDQ_TLBI_NH_ENABLED 1
#define TRACE_SMMUV3_CMDQ_TLBI_NH_ASID_ENABLED 1
#define TRACE_SMMUV3_CONFIG_CACHE_INV_ENABLED 1
#define TRACE_SMMUV3_NOTIFY_FLAG_ADD_ENABLED 1
#define TRACE_SMMUV3_NOTIFY_FLAG_DEL_ENABLED 1
#define TRACE_SMMUV3_INV_NOTIFIERS_IOVA_ENABLED 1
#include "qemu/log-for-trace.h"


#define TRACE_VIRT_ACPI_SETUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRT_ACPI_SETUP) || \
    false)

static inline void _nocheck__trace_virt_acpi_setup(void)
{
    if (trace_event_get_state(TRACE_VIRT_ACPI_SETUP) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virt_acpi_setup " "No fw cfg or ACPI disabled. Bailing out." "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_virt_acpi_setup(void)
{
    if (true) {
        _nocheck__trace_virt_acpi_setup();
    }
}

#define TRACE_SMMU_ADD_MR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMU_ADD_MR) || \
    false)

static inline void _nocheck__trace_smmu_add_mr(const char * name)
{
    if (trace_event_get_state(TRACE_SMMU_ADD_MR) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmu_add_mr " "%s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , name);
    }
}

static inline void trace_smmu_add_mr(const char * name)
{
    if (true) {
        _nocheck__trace_smmu_add_mr(name);
    }
}

#define TRACE_SMMU_PTW_LEVEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMU_PTW_LEVEL) || \
    false)

static inline void _nocheck__trace_smmu_ptw_level(int level, uint64_t iova, size_t subpage_size, uint64_t baseaddr, uint32_t offset, uint64_t pte)
{
    if (trace_event_get_state(TRACE_SMMU_PTW_LEVEL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmu_ptw_level " "level=%d iova=0x%"PRIx64" subpage_sz=0x%zx baseaddr=0x%"PRIx64" offset=%d => pte=0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , level, iova, subpage_size, baseaddr, offset, pte);
    }
}

static inline void trace_smmu_ptw_level(int level, uint64_t iova, size_t subpage_size, uint64_t baseaddr, uint32_t offset, uint64_t pte)
{
    if (true) {
        _nocheck__trace_smmu_ptw_level(level, iova, subpage_size, baseaddr, offset, pte);
    }
}

#define TRACE_SMMU_PTW_INVALID_PTE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMU_PTW_INVALID_PTE) || \
    false)

static inline void _nocheck__trace_smmu_ptw_invalid_pte(int stage, int level, uint64_t baseaddr, uint64_t pteaddr, uint32_t offset, uint64_t pte)
{
    if (trace_event_get_state(TRACE_SMMU_PTW_INVALID_PTE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmu_ptw_invalid_pte " "stage=%d level=%d base@=0x%"PRIx64" pte@=0x%"PRIx64" offset=%d pte=0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , stage, level, baseaddr, pteaddr, offset, pte);
    }
}

static inline void trace_smmu_ptw_invalid_pte(int stage, int level, uint64_t baseaddr, uint64_t pteaddr, uint32_t offset, uint64_t pte)
{
    if (true) {
        _nocheck__trace_smmu_ptw_invalid_pte(stage, level, baseaddr, pteaddr, offset, pte);
    }
}

#define TRACE_SMMU_PTW_PAGE_PTE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMU_PTW_PAGE_PTE) || \
    false)

static inline void _nocheck__trace_smmu_ptw_page_pte(int stage, int level, uint64_t iova, uint64_t baseaddr, uint64_t pteaddr, uint64_t pte, uint64_t address)
{
    if (trace_event_get_state(TRACE_SMMU_PTW_PAGE_PTE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmu_ptw_page_pte " "stage=%d level=%d iova=0x%"PRIx64" base@=0x%"PRIx64" pte@=0x%"PRIx64" pte=0x%"PRIx64" page address = 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , stage, level, iova, baseaddr, pteaddr, pte, address);
    }
}

static inline void trace_smmu_ptw_page_pte(int stage, int level, uint64_t iova, uint64_t baseaddr, uint64_t pteaddr, uint64_t pte, uint64_t address)
{
    if (true) {
        _nocheck__trace_smmu_ptw_page_pte(stage, level, iova, baseaddr, pteaddr, pte, address);
    }
}

#define TRACE_SMMU_PTW_BLOCK_PTE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMU_PTW_BLOCK_PTE) || \
    false)

static inline void _nocheck__trace_smmu_ptw_block_pte(int stage, int level, uint64_t baseaddr, uint64_t pteaddr, uint64_t pte, uint64_t iova, uint64_t gpa, int bsize_mb)
{
    if (trace_event_get_state(TRACE_SMMU_PTW_BLOCK_PTE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmu_ptw_block_pte " "stage=%d level=%d base@=0x%"PRIx64" pte@=0x%"PRIx64" pte=0x%"PRIx64" iova=0x%"PRIx64" block address = 0x%"PRIx64" block size = %d MiB" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , stage, level, baseaddr, pteaddr, pte, iova, gpa, bsize_mb);
    }
}

static inline void trace_smmu_ptw_block_pte(int stage, int level, uint64_t baseaddr, uint64_t pteaddr, uint64_t pte, uint64_t iova, uint64_t gpa, int bsize_mb)
{
    if (true) {
        _nocheck__trace_smmu_ptw_block_pte(stage, level, baseaddr, pteaddr, pte, iova, gpa, bsize_mb);
    }
}

#define TRACE_SMMU_GET_PTE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMU_GET_PTE) || \
    false)

static inline void _nocheck__trace_smmu_get_pte(uint64_t baseaddr, int index, uint64_t pteaddr, uint64_t pte)
{
    if (trace_event_get_state(TRACE_SMMU_GET_PTE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmu_get_pte " "baseaddr=0x%"PRIx64" index=0x%x, pteaddr=0x%"PRIx64", pte=0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , baseaddr, index, pteaddr, pte);
    }
}

static inline void trace_smmu_get_pte(uint64_t baseaddr, int index, uint64_t pteaddr, uint64_t pte)
{
    if (true) {
        _nocheck__trace_smmu_get_pte(baseaddr, index, pteaddr, pte);
    }
}

#define TRACE_SMMU_IOTLB_INV_ALL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMU_IOTLB_INV_ALL) || \
    false)

static inline void _nocheck__trace_smmu_iotlb_inv_all(void)
{
    if (trace_event_get_state(TRACE_SMMU_IOTLB_INV_ALL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmu_iotlb_inv_all " "IOTLB invalidate all" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_smmu_iotlb_inv_all(void)
{
    if (true) {
        _nocheck__trace_smmu_iotlb_inv_all();
    }
}

#define TRACE_SMMU_IOTLB_INV_ASID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMU_IOTLB_INV_ASID) || \
    false)

static inline void _nocheck__trace_smmu_iotlb_inv_asid(uint16_t asid)
{
    if (trace_event_get_state(TRACE_SMMU_IOTLB_INV_ASID) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmu_iotlb_inv_asid " "IOTLB invalidate asid=%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , asid);
    }
}

static inline void trace_smmu_iotlb_inv_asid(uint16_t asid)
{
    if (true) {
        _nocheck__trace_smmu_iotlb_inv_asid(asid);
    }
}

#define TRACE_SMMU_IOTLB_INV_IOVA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMU_IOTLB_INV_IOVA) || \
    false)

static inline void _nocheck__trace_smmu_iotlb_inv_iova(uint16_t asid, uint64_t addr)
{
    if (trace_event_get_state(TRACE_SMMU_IOTLB_INV_IOVA) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmu_iotlb_inv_iova " "IOTLB invalidate asid=%d addr=0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , asid, addr);
    }
}

static inline void trace_smmu_iotlb_inv_iova(uint16_t asid, uint64_t addr)
{
    if (true) {
        _nocheck__trace_smmu_iotlb_inv_iova(asid, addr);
    }
}

#define TRACE_SMMU_INV_NOTIFIERS_MR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMU_INV_NOTIFIERS_MR) || \
    false)

static inline void _nocheck__trace_smmu_inv_notifiers_mr(const char * name)
{
    if (trace_event_get_state(TRACE_SMMU_INV_NOTIFIERS_MR) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmu_inv_notifiers_mr " "iommu mr=%s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , name);
    }
}

static inline void trace_smmu_inv_notifiers_mr(const char * name)
{
    if (true) {
        _nocheck__trace_smmu_inv_notifiers_mr(name);
    }
}

#define TRACE_SMMU_IOTLB_LOOKUP_HIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMU_IOTLB_LOOKUP_HIT) || \
    false)

static inline void _nocheck__trace_smmu_iotlb_lookup_hit(uint16_t asid, uint64_t addr, uint32_t hit, uint32_t miss, uint32_t p)
{
    if (trace_event_get_state(TRACE_SMMU_IOTLB_LOOKUP_HIT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmu_iotlb_lookup_hit " "IOTLB cache HIT asid=%d addr=0x%"PRIx64" hit=%d miss=%d hit rate=%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , asid, addr, hit, miss, p);
    }
}

static inline void trace_smmu_iotlb_lookup_hit(uint16_t asid, uint64_t addr, uint32_t hit, uint32_t miss, uint32_t p)
{
    if (true) {
        _nocheck__trace_smmu_iotlb_lookup_hit(asid, addr, hit, miss, p);
    }
}

#define TRACE_SMMU_IOTLB_LOOKUP_MISS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMU_IOTLB_LOOKUP_MISS) || \
    false)

static inline void _nocheck__trace_smmu_iotlb_lookup_miss(uint16_t asid, uint64_t addr, uint32_t hit, uint32_t miss, uint32_t p)
{
    if (trace_event_get_state(TRACE_SMMU_IOTLB_LOOKUP_MISS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmu_iotlb_lookup_miss " "IOTLB cache MISS asid=%d addr=0x%"PRIx64" hit=%d miss=%d hit rate=%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , asid, addr, hit, miss, p);
    }
}

static inline void trace_smmu_iotlb_lookup_miss(uint16_t asid, uint64_t addr, uint32_t hit, uint32_t miss, uint32_t p)
{
    if (true) {
        _nocheck__trace_smmu_iotlb_lookup_miss(asid, addr, hit, miss, p);
    }
}

#define TRACE_SMMU_IOTLB_INSERT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMU_IOTLB_INSERT) || \
    false)

static inline void _nocheck__trace_smmu_iotlb_insert(uint16_t asid, uint64_t addr, uint8_t tg, uint8_t level)
{
    if (trace_event_get_state(TRACE_SMMU_IOTLB_INSERT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmu_iotlb_insert " "IOTLB ++ asid=%d addr=0x%"PRIx64" tg=%d level=%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , asid, addr, tg, level);
    }
}

static inline void trace_smmu_iotlb_insert(uint16_t asid, uint64_t addr, uint8_t tg, uint8_t level)
{
    if (true) {
        _nocheck__trace_smmu_iotlb_insert(asid, addr, tg, level);
    }
}

#define TRACE_SMMUV3_READ_MMIO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_READ_MMIO) || \
    false)

static inline void _nocheck__trace_smmuv3_read_mmio(uint64_t addr, uint64_t val, unsigned size, uint32_t r)
{
    if (trace_event_get_state(TRACE_SMMUV3_READ_MMIO) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmuv3_read_mmio " "addr: 0x%"PRIx64" val:0x%"PRIx64" size: 0x%x(%d)" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, val, size, r);
    }
}

static inline void trace_smmuv3_read_mmio(uint64_t addr, uint64_t val, unsigned size, uint32_t r)
{
    if (true) {
        _nocheck__trace_smmuv3_read_mmio(addr, val, size, r);
    }
}

#define TRACE_SMMUV3_TRIGGER_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_TRIGGER_IRQ) || \
    false)

static inline void _nocheck__trace_smmuv3_trigger_irq(int irq)
{
    if (trace_event_get_state(TRACE_SMMUV3_TRIGGER_IRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmuv3_trigger_irq " "irq=%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , irq);
    }
}

static inline void trace_smmuv3_trigger_irq(int irq)
{
    if (true) {
        _nocheck__trace_smmuv3_trigger_irq(irq);
    }
}

#define TRACE_SMMUV3_WRITE_GERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_WRITE_GERROR) || \
    false)

static inline void _nocheck__trace_smmuv3_write_gerror(uint32_t toggled, uint32_t gerror)
{
    if (trace_event_get_state(TRACE_SMMUV3_WRITE_GERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmuv3_write_gerror " "toggled=0x%x, new GERROR=0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , toggled, gerror);
    }
}

static inline void trace_smmuv3_write_gerror(uint32_t toggled, uint32_t gerror)
{
    if (true) {
        _nocheck__trace_smmuv3_write_gerror(toggled, gerror);
    }
}

#define TRACE_SMMUV3_WRITE_GERRORN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_WRITE_GERRORN) || \
    false)

static inline void _nocheck__trace_smmuv3_write_gerrorn(uint32_t acked, uint32_t gerrorn)
{
    if (trace_event_get_state(TRACE_SMMUV3_WRITE_GERRORN) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmuv3_write_gerrorn " "acked=0x%x, new GERRORN=0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , acked, gerrorn);
    }
}

static inline void trace_smmuv3_write_gerrorn(uint32_t acked, uint32_t gerrorn)
{
    if (true) {
        _nocheck__trace_smmuv3_write_gerrorn(acked, gerrorn);
    }
}

#define TRACE_SMMUV3_UNHANDLED_CMD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_UNHANDLED_CMD) || \
    false)

static inline void _nocheck__trace_smmuv3_unhandled_cmd(uint32_t type)
{
    if (trace_event_get_state(TRACE_SMMUV3_UNHANDLED_CMD) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmuv3_unhandled_cmd " "Unhandled command type=%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , type);
    }
}

static inline void trace_smmuv3_unhandled_cmd(uint32_t type)
{
    if (true) {
        _nocheck__trace_smmuv3_unhandled_cmd(type);
    }
}

#define TRACE_SMMUV3_CMDQ_CONSUME_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_CMDQ_CONSUME) || \
    false)

static inline void _nocheck__trace_smmuv3_cmdq_consume(uint32_t prod, uint32_t cons, uint8_t prod_wrap, uint8_t cons_wrap)
{
    if (trace_event_get_state(TRACE_SMMUV3_CMDQ_CONSUME) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmuv3_cmdq_consume " "prod=%d cons=%d prod.wrap=%d cons.wrap=%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , prod, cons, prod_wrap, cons_wrap);
    }
}

static inline void trace_smmuv3_cmdq_consume(uint32_t prod, uint32_t cons, uint8_t prod_wrap, uint8_t cons_wrap)
{
    if (true) {
        _nocheck__trace_smmuv3_cmdq_consume(prod, cons, prod_wrap, cons_wrap);
    }
}

#define TRACE_SMMUV3_CMDQ_OPCODE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_CMDQ_OPCODE) || \
    false)

static inline void _nocheck__trace_smmuv3_cmdq_opcode(const char * opcode)
{
    if (trace_event_get_state(TRACE_SMMUV3_CMDQ_OPCODE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmuv3_cmdq_opcode " "<--- %s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , opcode);
    }
}

static inline void trace_smmuv3_cmdq_opcode(const char * opcode)
{
    if (true) {
        _nocheck__trace_smmuv3_cmdq_opcode(opcode);
    }
}

#define TRACE_SMMUV3_CMDQ_CONSUME_OUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_CMDQ_CONSUME_OUT) || \
    false)

static inline void _nocheck__trace_smmuv3_cmdq_consume_out(uint32_t prod, uint32_t cons, uint8_t prod_wrap, uint8_t cons_wrap)
{
    if (trace_event_get_state(TRACE_SMMUV3_CMDQ_CONSUME_OUT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmuv3_cmdq_consume_out " "prod:%d, cons:%d, prod_wrap:%d, cons_wrap:%d " "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , prod, cons, prod_wrap, cons_wrap);
    }
}

static inline void trace_smmuv3_cmdq_consume_out(uint32_t prod, uint32_t cons, uint8_t prod_wrap, uint8_t cons_wrap)
{
    if (true) {
        _nocheck__trace_smmuv3_cmdq_consume_out(prod, cons, prod_wrap, cons_wrap);
    }
}

#define TRACE_SMMUV3_CMDQ_CONSUME_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_CMDQ_CONSUME_ERROR) || \
    false)

static inline void _nocheck__trace_smmuv3_cmdq_consume_error(const char * cmd_name, uint8_t cmd_error)
{
    if (trace_event_get_state(TRACE_SMMUV3_CMDQ_CONSUME_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmuv3_cmdq_consume_error " "Error on %s command execution: %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , cmd_name, cmd_error);
    }
}

static inline void trace_smmuv3_cmdq_consume_error(const char * cmd_name, uint8_t cmd_error)
{
    if (true) {
        _nocheck__trace_smmuv3_cmdq_consume_error(cmd_name, cmd_error);
    }
}

#define TRACE_SMMUV3_WRITE_MMIO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_WRITE_MMIO) || \
    false)

static inline void _nocheck__trace_smmuv3_write_mmio(uint64_t addr, uint64_t val, unsigned size, uint32_t r)
{
    if (trace_event_get_state(TRACE_SMMUV3_WRITE_MMIO) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmuv3_write_mmio " "addr: 0x%"PRIx64" val:0x%"PRIx64" size: 0x%x(%d)" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, val, size, r);
    }
}

static inline void trace_smmuv3_write_mmio(uint64_t addr, uint64_t val, unsigned size, uint32_t r)
{
    if (true) {
        _nocheck__trace_smmuv3_write_mmio(addr, val, size, r);
    }
}

#define TRACE_SMMUV3_RECORD_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_RECORD_EVENT) || \
    false)

static inline void _nocheck__trace_smmuv3_record_event(const char * type, uint32_t sid)
{
    if (trace_event_get_state(TRACE_SMMUV3_RECORD_EVENT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmuv3_record_event " "%s sid=%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , type, sid);
    }
}

static inline void trace_smmuv3_record_event(const char * type, uint32_t sid)
{
    if (true) {
        _nocheck__trace_smmuv3_record_event(type, sid);
    }
}

#define TRACE_SMMUV3_FIND_STE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_FIND_STE) || \
    false)

static inline void _nocheck__trace_smmuv3_find_ste(uint16_t sid, uint32_t features, uint16_t sid_split)
{
    if (trace_event_get_state(TRACE_SMMUV3_FIND_STE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmuv3_find_ste " "SID:0x%x features:0x%x, sid_split:0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , sid, features, sid_split);
    }
}

static inline void trace_smmuv3_find_ste(uint16_t sid, uint32_t features, uint16_t sid_split)
{
    if (true) {
        _nocheck__trace_smmuv3_find_ste(sid, features, sid_split);
    }
}

#define TRACE_SMMUV3_FIND_STE_2LVL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_FIND_STE_2LVL) || \
    false)

static inline void _nocheck__trace_smmuv3_find_ste_2lvl(uint64_t strtab_base, uint64_t l1ptr, int l1_ste_offset, uint64_t l2ptr, int l2_ste_offset, int max_l2_ste)
{
    if (trace_event_get_state(TRACE_SMMUV3_FIND_STE_2LVL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmuv3_find_ste_2lvl " "strtab_base:0x%"PRIx64" l1ptr:0x%"PRIx64" l1_off:0x%x, l2ptr:0x%"PRIx64" l2_off:0x%x max_l2_ste:%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , strtab_base, l1ptr, l1_ste_offset, l2ptr, l2_ste_offset, max_l2_ste);
    }
}

static inline void trace_smmuv3_find_ste_2lvl(uint64_t strtab_base, uint64_t l1ptr, int l1_ste_offset, uint64_t l2ptr, int l2_ste_offset, int max_l2_ste)
{
    if (true) {
        _nocheck__trace_smmuv3_find_ste_2lvl(strtab_base, l1ptr, l1_ste_offset, l2ptr, l2_ste_offset, max_l2_ste);
    }
}

#define TRACE_SMMUV3_GET_STE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_GET_STE) || \
    false)

static inline void _nocheck__trace_smmuv3_get_ste(uint64_t addr)
{
    if (trace_event_get_state(TRACE_SMMUV3_GET_STE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmuv3_get_ste " "STE addr: 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr);
    }
}

static inline void trace_smmuv3_get_ste(uint64_t addr)
{
    if (true) {
        _nocheck__trace_smmuv3_get_ste(addr);
    }
}

#define TRACE_SMMUV3_TRANSLATE_DISABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_TRANSLATE_DISABLE) || \
    false)

static inline void _nocheck__trace_smmuv3_translate_disable(const char * n, uint16_t sid, uint64_t addr, bool is_write)
{
    if (trace_event_get_state(TRACE_SMMUV3_TRANSLATE_DISABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmuv3_translate_disable " "%s sid=%d bypass (smmu disabled) iova:0x%"PRIx64" is_write=%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , n, sid, addr, is_write);
    }
}

static inline void trace_smmuv3_translate_disable(const char * n, uint16_t sid, uint64_t addr, bool is_write)
{
    if (true) {
        _nocheck__trace_smmuv3_translate_disable(n, sid, addr, is_write);
    }
}

#define TRACE_SMMUV3_TRANSLATE_BYPASS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_TRANSLATE_BYPASS) || \
    false)

static inline void _nocheck__trace_smmuv3_translate_bypass(const char * n, uint16_t sid, uint64_t addr, bool is_write)
{
    if (trace_event_get_state(TRACE_SMMUV3_TRANSLATE_BYPASS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmuv3_translate_bypass " "%s sid=%d STE bypass iova:0x%"PRIx64" is_write=%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , n, sid, addr, is_write);
    }
}

static inline void trace_smmuv3_translate_bypass(const char * n, uint16_t sid, uint64_t addr, bool is_write)
{
    if (true) {
        _nocheck__trace_smmuv3_translate_bypass(n, sid, addr, is_write);
    }
}

#define TRACE_SMMUV3_TRANSLATE_ABORT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_TRANSLATE_ABORT) || \
    false)

static inline void _nocheck__trace_smmuv3_translate_abort(const char * n, uint16_t sid, uint64_t addr, bool is_write)
{
    if (trace_event_get_state(TRACE_SMMUV3_TRANSLATE_ABORT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmuv3_translate_abort " "%s sid=%d abort on iova:0x%"PRIx64" is_write=%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , n, sid, addr, is_write);
    }
}

static inline void trace_smmuv3_translate_abort(const char * n, uint16_t sid, uint64_t addr, bool is_write)
{
    if (true) {
        _nocheck__trace_smmuv3_translate_abort(n, sid, addr, is_write);
    }
}

#define TRACE_SMMUV3_TRANSLATE_SUCCESS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_TRANSLATE_SUCCESS) || \
    false)

static inline void _nocheck__trace_smmuv3_translate_success(const char * n, uint16_t sid, uint64_t iova, uint64_t translated, int perm)
{
    if (trace_event_get_state(TRACE_SMMUV3_TRANSLATE_SUCCESS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmuv3_translate_success " "%s sid=%d iova=0x%"PRIx64" translated=0x%"PRIx64" perm=0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , n, sid, iova, translated, perm);
    }
}

static inline void trace_smmuv3_translate_success(const char * n, uint16_t sid, uint64_t iova, uint64_t translated, int perm)
{
    if (true) {
        _nocheck__trace_smmuv3_translate_success(n, sid, iova, translated, perm);
    }
}

#define TRACE_SMMUV3_GET_CD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_GET_CD) || \
    false)

static inline void _nocheck__trace_smmuv3_get_cd(uint64_t addr)
{
    if (trace_event_get_state(TRACE_SMMUV3_GET_CD) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmuv3_get_cd " "CD addr: 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr);
    }
}

static inline void trace_smmuv3_get_cd(uint64_t addr)
{
    if (true) {
        _nocheck__trace_smmuv3_get_cd(addr);
    }
}

#define TRACE_SMMUV3_DECODE_CD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_DECODE_CD) || \
    false)

static inline void _nocheck__trace_smmuv3_decode_cd(uint32_t oas)
{
    if (trace_event_get_state(TRACE_SMMUV3_DECODE_CD) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmuv3_decode_cd " "oas=%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , oas);
    }
}

static inline void trace_smmuv3_decode_cd(uint32_t oas)
{
    if (true) {
        _nocheck__trace_smmuv3_decode_cd(oas);
    }
}

#define TRACE_SMMUV3_DECODE_CD_TT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_DECODE_CD_TT) || \
    false)

static inline void _nocheck__trace_smmuv3_decode_cd_tt(int i, uint32_t tsz, uint64_t ttb, uint32_t granule_sz, bool had)
{
    if (trace_event_get_state(TRACE_SMMUV3_DECODE_CD_TT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmuv3_decode_cd_tt " "TT[%d]:tsz:%d ttb:0x%"PRIx64" granule_sz:%d had:%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , i, tsz, ttb, granule_sz, had);
    }
}

static inline void trace_smmuv3_decode_cd_tt(int i, uint32_t tsz, uint64_t ttb, uint32_t granule_sz, bool had)
{
    if (true) {
        _nocheck__trace_smmuv3_decode_cd_tt(i, tsz, ttb, granule_sz, had);
    }
}

#define TRACE_SMMUV3_CMDQ_CFGI_STE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_CMDQ_CFGI_STE) || \
    false)

static inline void _nocheck__trace_smmuv3_cmdq_cfgi_ste(int streamid)
{
    if (trace_event_get_state(TRACE_SMMUV3_CMDQ_CFGI_STE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmuv3_cmdq_cfgi_ste " "streamid =%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , streamid);
    }
}

static inline void trace_smmuv3_cmdq_cfgi_ste(int streamid)
{
    if (true) {
        _nocheck__trace_smmuv3_cmdq_cfgi_ste(streamid);
    }
}

#define TRACE_SMMUV3_CMDQ_CFGI_STE_RANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_CMDQ_CFGI_STE_RANGE) || \
    false)

static inline void _nocheck__trace_smmuv3_cmdq_cfgi_ste_range(int start, int end)
{
    if (trace_event_get_state(TRACE_SMMUV3_CMDQ_CFGI_STE_RANGE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmuv3_cmdq_cfgi_ste_range " "start=0x%x - end=0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , start, end);
    }
}

static inline void trace_smmuv3_cmdq_cfgi_ste_range(int start, int end)
{
    if (true) {
        _nocheck__trace_smmuv3_cmdq_cfgi_ste_range(start, end);
    }
}

#define TRACE_SMMUV3_CMDQ_CFGI_CD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_CMDQ_CFGI_CD) || \
    false)

static inline void _nocheck__trace_smmuv3_cmdq_cfgi_cd(uint32_t sid)
{
    if (trace_event_get_state(TRACE_SMMUV3_CMDQ_CFGI_CD) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmuv3_cmdq_cfgi_cd " "streamid = %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , sid);
    }
}

static inline void trace_smmuv3_cmdq_cfgi_cd(uint32_t sid)
{
    if (true) {
        _nocheck__trace_smmuv3_cmdq_cfgi_cd(sid);
    }
}

#define TRACE_SMMUV3_CONFIG_CACHE_HIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_CONFIG_CACHE_HIT) || \
    false)

static inline void _nocheck__trace_smmuv3_config_cache_hit(uint32_t sid, uint32_t hits, uint32_t misses, uint32_t perc)
{
    if (trace_event_get_state(TRACE_SMMUV3_CONFIG_CACHE_HIT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmuv3_config_cache_hit " "Config cache HIT for sid %d (hits=%d, misses=%d, hit rate=%d)" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , sid, hits, misses, perc);
    }
}

static inline void trace_smmuv3_config_cache_hit(uint32_t sid, uint32_t hits, uint32_t misses, uint32_t perc)
{
    if (true) {
        _nocheck__trace_smmuv3_config_cache_hit(sid, hits, misses, perc);
    }
}

#define TRACE_SMMUV3_CONFIG_CACHE_MISS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_CONFIG_CACHE_MISS) || \
    false)

static inline void _nocheck__trace_smmuv3_config_cache_miss(uint32_t sid, uint32_t hits, uint32_t misses, uint32_t perc)
{
    if (trace_event_get_state(TRACE_SMMUV3_CONFIG_CACHE_MISS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmuv3_config_cache_miss " "Config cache MISS for sid %d (hits=%d, misses=%d, hit rate=%d)" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , sid, hits, misses, perc);
    }
}

static inline void trace_smmuv3_config_cache_miss(uint32_t sid, uint32_t hits, uint32_t misses, uint32_t perc)
{
    if (true) {
        _nocheck__trace_smmuv3_config_cache_miss(sid, hits, misses, perc);
    }
}

#define TRACE_SMMUV3_S1_RANGE_INVAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_S1_RANGE_INVAL) || \
    false)

static inline void _nocheck__trace_smmuv3_s1_range_inval(int vmid, int asid, uint64_t addr, uint8_t tg, uint64_t num_pages, uint8_t ttl, bool leaf)
{
    if (trace_event_get_state(TRACE_SMMUV3_S1_RANGE_INVAL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmuv3_s1_range_inval " "vmid =%d asid =%d addr=0x%"PRIx64" tg=%d num_pages=0x%"PRIx64" ttl=%d leaf=%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , vmid, asid, addr, tg, num_pages, ttl, leaf);
    }
}

static inline void trace_smmuv3_s1_range_inval(int vmid, int asid, uint64_t addr, uint8_t tg, uint64_t num_pages, uint8_t ttl, bool leaf)
{
    if (true) {
        _nocheck__trace_smmuv3_s1_range_inval(vmid, asid, addr, tg, num_pages, ttl, leaf);
    }
}

#define TRACE_SMMUV3_CMDQ_TLBI_NH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_CMDQ_TLBI_NH) || \
    false)

static inline void _nocheck__trace_smmuv3_cmdq_tlbi_nh(void)
{
    if (trace_event_get_state(TRACE_SMMUV3_CMDQ_TLBI_NH) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmuv3_cmdq_tlbi_nh " "" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_smmuv3_cmdq_tlbi_nh(void)
{
    if (true) {
        _nocheck__trace_smmuv3_cmdq_tlbi_nh();
    }
}

#define TRACE_SMMUV3_CMDQ_TLBI_NH_ASID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_CMDQ_TLBI_NH_ASID) || \
    false)

static inline void _nocheck__trace_smmuv3_cmdq_tlbi_nh_asid(uint16_t asid)
{
    if (trace_event_get_state(TRACE_SMMUV3_CMDQ_TLBI_NH_ASID) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmuv3_cmdq_tlbi_nh_asid " "asid=%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , asid);
    }
}

static inline void trace_smmuv3_cmdq_tlbi_nh_asid(uint16_t asid)
{
    if (true) {
        _nocheck__trace_smmuv3_cmdq_tlbi_nh_asid(asid);
    }
}

#define TRACE_SMMUV3_CONFIG_CACHE_INV_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_CONFIG_CACHE_INV) || \
    false)

static inline void _nocheck__trace_smmuv3_config_cache_inv(uint32_t sid)
{
    if (trace_event_get_state(TRACE_SMMUV3_CONFIG_CACHE_INV) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmuv3_config_cache_inv " "Config cache INV for sid %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , sid);
    }
}

static inline void trace_smmuv3_config_cache_inv(uint32_t sid)
{
    if (true) {
        _nocheck__trace_smmuv3_config_cache_inv(sid);
    }
}

#define TRACE_SMMUV3_NOTIFY_FLAG_ADD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_NOTIFY_FLAG_ADD) || \
    false)

static inline void _nocheck__trace_smmuv3_notify_flag_add(const char * iommu)
{
    if (trace_event_get_state(TRACE_SMMUV3_NOTIFY_FLAG_ADD) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmuv3_notify_flag_add " "ADD SMMUNotifier node for iommu mr=%s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , iommu);
    }
}

static inline void trace_smmuv3_notify_flag_add(const char * iommu)
{
    if (true) {
        _nocheck__trace_smmuv3_notify_flag_add(iommu);
    }
}

#define TRACE_SMMUV3_NOTIFY_FLAG_DEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_NOTIFY_FLAG_DEL) || \
    false)

static inline void _nocheck__trace_smmuv3_notify_flag_del(const char * iommu)
{
    if (trace_event_get_state(TRACE_SMMUV3_NOTIFY_FLAG_DEL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmuv3_notify_flag_del " "DEL SMMUNotifier node for iommu mr=%s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , iommu);
    }
}

static inline void trace_smmuv3_notify_flag_del(const char * iommu)
{
    if (true) {
        _nocheck__trace_smmuv3_notify_flag_del(iommu);
    }
}

#define TRACE_SMMUV3_INV_NOTIFIERS_IOVA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SMMUV3_INV_NOTIFIERS_IOVA) || \
    false)

static inline void _nocheck__trace_smmuv3_inv_notifiers_iova(const char * name, uint16_t asid, uint64_t iova, uint8_t tg, uint64_t num_pages)
{
    if (trace_event_get_state(TRACE_SMMUV3_INV_NOTIFIERS_IOVA) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:smmuv3_inv_notifiers_iova " "iommu mr=%s asid=%d iova=0x%"PRIx64" tg=%d num_pages=0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , name, asid, iova, tg, num_pages);
    }
}

static inline void trace_smmuv3_inv_notifiers_iova(const char * name, uint16_t asid, uint64_t iova, uint8_t tg, uint64_t num_pages)
{
    if (true) {
        _nocheck__trace_smmuv3_inv_notifiers_iova(name, asid, iova, tg, num_pages);
    }
}
#endif /* TRACE_HW_ARM_GENERATED_TRACERS_H */
