/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_I386_GENERATED_TRACERS_H
#define TRACE_HW_I386_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_X86_IOMMU_IEC_NOTIFY_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_CC_DOMAIN_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_CC_GLOBAL_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_CC_DEVICE_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_CC_DEVICES_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_IOTLB_GLOBAL_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_IOTLB_DOMAIN_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_IOTLB_PAGES_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_WAIT_SW_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_WAIT_IRQ_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_WAIT_WRITE_FAIL_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_IEC_EVENT;
extern TraceEvent _TRACE_VTD_INV_QI_ENABLE_EVENT;
extern TraceEvent _TRACE_VTD_INV_QI_SETUP_EVENT;
extern TraceEvent _TRACE_VTD_INV_QI_HEAD_EVENT;
extern TraceEvent _TRACE_VTD_INV_QI_TAIL_EVENT;
extern TraceEvent _TRACE_VTD_INV_QI_FETCH_EVENT;
extern TraceEvent _TRACE_VTD_CONTEXT_CACHE_RESET_EVENT;
extern TraceEvent _TRACE_VTD_RE_NOT_PRESENT_EVENT;
extern TraceEvent _TRACE_VTD_CE_NOT_PRESENT_EVENT;
extern TraceEvent _TRACE_VTD_IOTLB_PAGE_HIT_EVENT;
extern TraceEvent _TRACE_VTD_IOTLB_PAGE_UPDATE_EVENT;
extern TraceEvent _TRACE_VTD_IOTLB_CC_HIT_EVENT;
extern TraceEvent _TRACE_VTD_IOTLB_CC_UPDATE_EVENT;
extern TraceEvent _TRACE_VTD_IOTLB_RESET_EVENT;
extern TraceEvent _TRACE_VTD_FAULT_DISABLED_EVENT;
extern TraceEvent _TRACE_VTD_REPLAY_CE_VALID_EVENT;
extern TraceEvent _TRACE_VTD_REPLAY_CE_INVALID_EVENT;
extern TraceEvent _TRACE_VTD_PAGE_WALK_LEVEL_EVENT;
extern TraceEvent _TRACE_VTD_PAGE_WALK_ONE_EVENT;
extern TraceEvent _TRACE_VTD_PAGE_WALK_ONE_SKIP_MAP_EVENT;
extern TraceEvent _TRACE_VTD_PAGE_WALK_ONE_SKIP_UNMAP_EVENT;
extern TraceEvent _TRACE_VTD_PAGE_WALK_SKIP_READ_EVENT;
extern TraceEvent _TRACE_VTD_PAGE_WALK_SKIP_RESERVE_EVENT;
extern TraceEvent _TRACE_VTD_SWITCH_ADDRESS_SPACE_EVENT;
extern TraceEvent _TRACE_VTD_AS_UNMAP_WHOLE_EVENT;
extern TraceEvent _TRACE_VTD_TRANSLATE_PT_EVENT;
extern TraceEvent _TRACE_VTD_PT_ENABLE_FAST_PATH_EVENT;
extern TraceEvent _TRACE_VTD_IRQ_GENERATE_EVENT;
extern TraceEvent _TRACE_VTD_REG_READ_EVENT;
extern TraceEvent _TRACE_VTD_REG_WRITE_EVENT;
extern TraceEvent _TRACE_VTD_REG_DMAR_ROOT_EVENT;
extern TraceEvent _TRACE_VTD_REG_IR_ROOT_EVENT;
extern TraceEvent _TRACE_VTD_REG_WRITE_GCMD_EVENT;
extern TraceEvent _TRACE_VTD_REG_WRITE_FECTL_EVENT;
extern TraceEvent _TRACE_VTD_REG_WRITE_IECTL_EVENT;
extern TraceEvent _TRACE_VTD_REG_ICS_CLEAR_IP_EVENT;
extern TraceEvent _TRACE_VTD_DMAR_TRANSLATE_EVENT;
extern TraceEvent _TRACE_VTD_DMAR_ENABLE_EVENT;
extern TraceEvent _TRACE_VTD_DMAR_FAULT_EVENT;
extern TraceEvent _TRACE_VTD_IR_ENABLE_EVENT;
extern TraceEvent _TRACE_VTD_IR_IRTE_GET_EVENT;
extern TraceEvent _TRACE_VTD_IR_REMAP_EVENT;
extern TraceEvent _TRACE_VTD_IR_REMAP_TYPE_EVENT;
extern TraceEvent _TRACE_VTD_IR_REMAP_MSI_EVENT;
extern TraceEvent _TRACE_VTD_IR_REMAP_MSI_REQ_EVENT;
extern TraceEvent _TRACE_VTD_FSTS_PPF_EVENT;
extern TraceEvent _TRACE_VTD_FSTS_CLEAR_IP_EVENT;
extern TraceEvent _TRACE_VTD_FRR_NEW_EVENT;
extern TraceEvent _TRACE_VTD_WARN_INVALID_QI_TAIL_EVENT;
extern TraceEvent _TRACE_VTD_WARN_IR_VECTOR_EVENT;
extern TraceEvent _TRACE_VTD_WARN_IR_TRIGGER_EVENT;
extern TraceEvent _TRACE_AMDVI_EVNTLOG_FAIL_EVENT;
extern TraceEvent _TRACE_AMDVI_CACHE_UPDATE_EVENT;
extern TraceEvent _TRACE_AMDVI_COMPLETION_WAIT_FAIL_EVENT;
extern TraceEvent _TRACE_AMDVI_MMIO_WRITE_EVENT;
extern TraceEvent _TRACE_AMDVI_MMIO_READ_EVENT;
extern TraceEvent _TRACE_AMDVI_MMIO_READ_INVALID_EVENT;
extern TraceEvent _TRACE_AMDVI_COMMAND_ERROR_EVENT;
extern TraceEvent _TRACE_AMDVI_COMMAND_READ_FAIL_EVENT;
extern TraceEvent _TRACE_AMDVI_COMMAND_EXEC_EVENT;
extern TraceEvent _TRACE_AMDVI_UNHANDLED_COMMAND_EVENT;
extern TraceEvent _TRACE_AMDVI_INTR_INVAL_EVENT;
extern TraceEvent _TRACE_AMDVI_IOTLB_INVAL_EVENT;
extern TraceEvent _TRACE_AMDVI_PREFETCH_PAGES_EVENT;
extern TraceEvent _TRACE_AMDVI_PAGES_INVAL_EVENT;
extern TraceEvent _TRACE_AMDVI_ALL_INVAL_EVENT;
extern TraceEvent _TRACE_AMDVI_PPR_EXEC_EVENT;
extern TraceEvent _TRACE_AMDVI_DEVTAB_INVAL_EVENT;
extern TraceEvent _TRACE_AMDVI_COMPLETION_WAIT_EVENT;
extern TraceEvent _TRACE_AMDVI_CONTROL_STATUS_EVENT;
extern TraceEvent _TRACE_AMDVI_IOTLB_RESET_EVENT;
extern TraceEvent _TRACE_AMDVI_DTE_GET_FAIL_EVENT;
extern TraceEvent _TRACE_AMDVI_INVALID_DTE_EVENT;
extern TraceEvent _TRACE_AMDVI_GET_PTE_HWERROR_EVENT;
extern TraceEvent _TRACE_AMDVI_MODE_INVALID_EVENT;
extern TraceEvent _TRACE_AMDVI_PAGE_FAULT_EVENT;
extern TraceEvent _TRACE_AMDVI_IOTLB_HIT_EVENT;
extern TraceEvent _TRACE_AMDVI_TRANSLATION_RESULT_EVENT;
extern TraceEvent _TRACE_AMDVI_MEM_IR_WRITE_REQ_EVENT;
extern TraceEvent _TRACE_AMDVI_MEM_IR_WRITE_EVENT;
extern TraceEvent _TRACE_AMDVI_IR_REMAP_MSI_REQ_EVENT;
extern TraceEvent _TRACE_AMDVI_IR_REMAP_MSI_EVENT;
extern TraceEvent _TRACE_AMDVI_ERR_EVENT;
extern TraceEvent _TRACE_AMDVI_IR_IRTE_EVENT;
extern TraceEvent _TRACE_AMDVI_IR_IRTE_VAL_EVENT;
extern TraceEvent _TRACE_AMDVI_IR_ERR_EVENT;
extern TraceEvent _TRACE_AMDVI_IR_INTCTL_EVENT;
extern TraceEvent _TRACE_AMDVI_IR_TARGET_ABORT_EVENT;
extern TraceEvent _TRACE_AMDVI_IR_DELIVERY_MODE_EVENT;
extern TraceEvent _TRACE_AMDVI_IR_IRTE_GA_VAL_EVENT;
extern TraceEvent _TRACE_VMPORT_REGISTER_EVENT;
extern TraceEvent _TRACE_VMPORT_COMMAND_EVENT;
extern TraceEvent _TRACE_X86_GSI_INTERRUPT_EVENT;
extern TraceEvent _TRACE_X86_PIC_INTERRUPT_EVENT;
extern TraceEvent _TRACE_PORT92_READ_EVENT;
extern TraceEvent _TRACE_PORT92_WRITE_EVENT;
extern uint16_t _TRACE_X86_IOMMU_IEC_NOTIFY_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_CC_DOMAIN_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_CC_GLOBAL_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_CC_DEVICE_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_CC_DEVICES_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_IOTLB_GLOBAL_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_IOTLB_DOMAIN_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_IOTLB_PAGES_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_WAIT_SW_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_WAIT_IRQ_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_WAIT_WRITE_FAIL_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_IEC_DSTATE;
extern uint16_t _TRACE_VTD_INV_QI_ENABLE_DSTATE;
extern uint16_t _TRACE_VTD_INV_QI_SETUP_DSTATE;
extern uint16_t _TRACE_VTD_INV_QI_HEAD_DSTATE;
extern uint16_t _TRACE_VTD_INV_QI_TAIL_DSTATE;
extern uint16_t _TRACE_VTD_INV_QI_FETCH_DSTATE;
extern uint16_t _TRACE_VTD_CONTEXT_CACHE_RESET_DSTATE;
extern uint16_t _TRACE_VTD_RE_NOT_PRESENT_DSTATE;
extern uint16_t _TRACE_VTD_CE_NOT_PRESENT_DSTATE;
extern uint16_t _TRACE_VTD_IOTLB_PAGE_HIT_DSTATE;
extern uint16_t _TRACE_VTD_IOTLB_PAGE_UPDATE_DSTATE;
extern uint16_t _TRACE_VTD_IOTLB_CC_HIT_DSTATE;
extern uint16_t _TRACE_VTD_IOTLB_CC_UPDATE_DSTATE;
extern uint16_t _TRACE_VTD_IOTLB_RESET_DSTATE;
extern uint16_t _TRACE_VTD_FAULT_DISABLED_DSTATE;
extern uint16_t _TRACE_VTD_REPLAY_CE_VALID_DSTATE;
extern uint16_t _TRACE_VTD_REPLAY_CE_INVALID_DSTATE;
extern uint16_t _TRACE_VTD_PAGE_WALK_LEVEL_DSTATE;
extern uint16_t _TRACE_VTD_PAGE_WALK_ONE_DSTATE;
extern uint16_t _TRACE_VTD_PAGE_WALK_ONE_SKIP_MAP_DSTATE;
extern uint16_t _TRACE_VTD_PAGE_WALK_ONE_SKIP_UNMAP_DSTATE;
extern uint16_t _TRACE_VTD_PAGE_WALK_SKIP_READ_DSTATE;
extern uint16_t _TRACE_VTD_PAGE_WALK_SKIP_RESERVE_DSTATE;
extern uint16_t _TRACE_VTD_SWITCH_ADDRESS_SPACE_DSTATE;
extern uint16_t _TRACE_VTD_AS_UNMAP_WHOLE_DSTATE;
extern uint16_t _TRACE_VTD_TRANSLATE_PT_DSTATE;
extern uint16_t _TRACE_VTD_PT_ENABLE_FAST_PATH_DSTATE;
extern uint16_t _TRACE_VTD_IRQ_GENERATE_DSTATE;
extern uint16_t _TRACE_VTD_REG_READ_DSTATE;
extern uint16_t _TRACE_VTD_REG_WRITE_DSTATE;
extern uint16_t _TRACE_VTD_REG_DMAR_ROOT_DSTATE;
extern uint16_t _TRACE_VTD_REG_IR_ROOT_DSTATE;
extern uint16_t _TRACE_VTD_REG_WRITE_GCMD_DSTATE;
extern uint16_t _TRACE_VTD_REG_WRITE_FECTL_DSTATE;
extern uint16_t _TRACE_VTD_REG_WRITE_IECTL_DSTATE;
extern uint16_t _TRACE_VTD_REG_ICS_CLEAR_IP_DSTATE;
extern uint16_t _TRACE_VTD_DMAR_TRANSLATE_DSTATE;
extern uint16_t _TRACE_VTD_DMAR_ENABLE_DSTATE;
extern uint16_t _TRACE_VTD_DMAR_FAULT_DSTATE;
extern uint16_t _TRACE_VTD_IR_ENABLE_DSTATE;
extern uint16_t _TRACE_VTD_IR_IRTE_GET_DSTATE;
extern uint16_t _TRACE_VTD_IR_REMAP_DSTATE;
extern uint16_t _TRACE_VTD_IR_REMAP_TYPE_DSTATE;
extern uint16_t _TRACE_VTD_IR_REMAP_MSI_DSTATE;
extern uint16_t _TRACE_VTD_IR_REMAP_MSI_REQ_DSTATE;
extern uint16_t _TRACE_VTD_FSTS_PPF_DSTATE;
extern uint16_t _TRACE_VTD_FSTS_CLEAR_IP_DSTATE;
extern uint16_t _TRACE_VTD_FRR_NEW_DSTATE;
extern uint16_t _TRACE_VTD_WARN_INVALID_QI_TAIL_DSTATE;
extern uint16_t _TRACE_VTD_WARN_IR_VECTOR_DSTATE;
extern uint16_t _TRACE_VTD_WARN_IR_TRIGGER_DSTATE;
extern uint16_t _TRACE_AMDVI_EVNTLOG_FAIL_DSTATE;
extern uint16_t _TRACE_AMDVI_CACHE_UPDATE_DSTATE;
extern uint16_t _TRACE_AMDVI_COMPLETION_WAIT_FAIL_DSTATE;
extern uint16_t _TRACE_AMDVI_MMIO_WRITE_DSTATE;
extern uint16_t _TRACE_AMDVI_MMIO_READ_DSTATE;
extern uint16_t _TRACE_AMDVI_MMIO_READ_INVALID_DSTATE;
extern uint16_t _TRACE_AMDVI_COMMAND_ERROR_DSTATE;
extern uint16_t _TRACE_AMDVI_COMMAND_READ_FAIL_DSTATE;
extern uint16_t _TRACE_AMDVI_COMMAND_EXEC_DSTATE;
extern uint16_t _TRACE_AMDVI_UNHANDLED_COMMAND_DSTATE;
extern uint16_t _TRACE_AMDVI_INTR_INVAL_DSTATE;
extern uint16_t _TRACE_AMDVI_IOTLB_INVAL_DSTATE;
extern uint16_t _TRACE_AMDVI_PREFETCH_PAGES_DSTATE;
extern uint16_t _TRACE_AMDVI_PAGES_INVAL_DSTATE;
extern uint16_t _TRACE_AMDVI_ALL_INVAL_DSTATE;
extern uint16_t _TRACE_AMDVI_PPR_EXEC_DSTATE;
extern uint16_t _TRACE_AMDVI_DEVTAB_INVAL_DSTATE;
extern uint16_t _TRACE_AMDVI_COMPLETION_WAIT_DSTATE;
extern uint16_t _TRACE_AMDVI_CONTROL_STATUS_DSTATE;
extern uint16_t _TRACE_AMDVI_IOTLB_RESET_DSTATE;
extern uint16_t _TRACE_AMDVI_DTE_GET_FAIL_DSTATE;
extern uint16_t _TRACE_AMDVI_INVALID_DTE_DSTATE;
extern uint16_t _TRACE_AMDVI_GET_PTE_HWERROR_DSTATE;
extern uint16_t _TRACE_AMDVI_MODE_INVALID_DSTATE;
extern uint16_t _TRACE_AMDVI_PAGE_FAULT_DSTATE;
extern uint16_t _TRACE_AMDVI_IOTLB_HIT_DSTATE;
extern uint16_t _TRACE_AMDVI_TRANSLATION_RESULT_DSTATE;
extern uint16_t _TRACE_AMDVI_MEM_IR_WRITE_REQ_DSTATE;
extern uint16_t _TRACE_AMDVI_MEM_IR_WRITE_DSTATE;
extern uint16_t _TRACE_AMDVI_IR_REMAP_MSI_REQ_DSTATE;
extern uint16_t _TRACE_AMDVI_IR_REMAP_MSI_DSTATE;
extern uint16_t _TRACE_AMDVI_ERR_DSTATE;
extern uint16_t _TRACE_AMDVI_IR_IRTE_DSTATE;
extern uint16_t _TRACE_AMDVI_IR_IRTE_VAL_DSTATE;
extern uint16_t _TRACE_AMDVI_IR_ERR_DSTATE;
extern uint16_t _TRACE_AMDVI_IR_INTCTL_DSTATE;
extern uint16_t _TRACE_AMDVI_IR_TARGET_ABORT_DSTATE;
extern uint16_t _TRACE_AMDVI_IR_DELIVERY_MODE_DSTATE;
extern uint16_t _TRACE_AMDVI_IR_IRTE_GA_VAL_DSTATE;
extern uint16_t _TRACE_VMPORT_REGISTER_DSTATE;
extern uint16_t _TRACE_VMPORT_COMMAND_DSTATE;
extern uint16_t _TRACE_X86_GSI_INTERRUPT_DSTATE;
extern uint16_t _TRACE_X86_PIC_INTERRUPT_DSTATE;
extern uint16_t _TRACE_PORT92_READ_DSTATE;
extern uint16_t _TRACE_PORT92_WRITE_DSTATE;
#define TRACE_X86_IOMMU_IEC_NOTIFY_ENABLED 1
#define TRACE_VTD_INV_DESC_ENABLED 1
#define TRACE_VTD_INV_DESC_CC_DOMAIN_ENABLED 1
#define TRACE_VTD_INV_DESC_CC_GLOBAL_ENABLED 1
#define TRACE_VTD_INV_DESC_CC_DEVICE_ENABLED 1
#define TRACE_VTD_INV_DESC_CC_DEVICES_ENABLED 1
#define TRACE_VTD_INV_DESC_IOTLB_GLOBAL_ENABLED 1
#define TRACE_VTD_INV_DESC_IOTLB_DOMAIN_ENABLED 1
#define TRACE_VTD_INV_DESC_IOTLB_PAGES_ENABLED 1
#define TRACE_VTD_INV_DESC_WAIT_SW_ENABLED 1
#define TRACE_VTD_INV_DESC_WAIT_IRQ_ENABLED 1
#define TRACE_VTD_INV_DESC_WAIT_WRITE_FAIL_ENABLED 1
#define TRACE_VTD_INV_DESC_IEC_ENABLED 1
#define TRACE_VTD_INV_QI_ENABLE_ENABLED 1
#define TRACE_VTD_INV_QI_SETUP_ENABLED 1
#define TRACE_VTD_INV_QI_HEAD_ENABLED 1
#define TRACE_VTD_INV_QI_TAIL_ENABLED 1
#define TRACE_VTD_INV_QI_FETCH_ENABLED 1
#define TRACE_VTD_CONTEXT_CACHE_RESET_ENABLED 1
#define TRACE_VTD_RE_NOT_PRESENT_ENABLED 1
#define TRACE_VTD_CE_NOT_PRESENT_ENABLED 1
#define TRACE_VTD_IOTLB_PAGE_HIT_ENABLED 1
#define TRACE_VTD_IOTLB_PAGE_UPDATE_ENABLED 1
#define TRACE_VTD_IOTLB_CC_HIT_ENABLED 1
#define TRACE_VTD_IOTLB_CC_UPDATE_ENABLED 1
#define TRACE_VTD_IOTLB_RESET_ENABLED 1
#define TRACE_VTD_FAULT_DISABLED_ENABLED 1
#define TRACE_VTD_REPLAY_CE_VALID_ENABLED 1
#define TRACE_VTD_REPLAY_CE_INVALID_ENABLED 1
#define TRACE_VTD_PAGE_WALK_LEVEL_ENABLED 1
#define TRACE_VTD_PAGE_WALK_ONE_ENABLED 1
#define TRACE_VTD_PAGE_WALK_ONE_SKIP_MAP_ENABLED 1
#define TRACE_VTD_PAGE_WALK_ONE_SKIP_UNMAP_ENABLED 1
#define TRACE_VTD_PAGE_WALK_SKIP_READ_ENABLED 1
#define TRACE_VTD_PAGE_WALK_SKIP_RESERVE_ENABLED 1
#define TRACE_VTD_SWITCH_ADDRESS_SPACE_ENABLED 1
#define TRACE_VTD_AS_UNMAP_WHOLE_ENABLED 1
#define TRACE_VTD_TRANSLATE_PT_ENABLED 1
#define TRACE_VTD_PT_ENABLE_FAST_PATH_ENABLED 1
#define TRACE_VTD_IRQ_GENERATE_ENABLED 1
#define TRACE_VTD_REG_READ_ENABLED 1
#define TRACE_VTD_REG_WRITE_ENABLED 1
#define TRACE_VTD_REG_DMAR_ROOT_ENABLED 1
#define TRACE_VTD_REG_IR_ROOT_ENABLED 1
#define TRACE_VTD_REG_WRITE_GCMD_ENABLED 1
#define TRACE_VTD_REG_WRITE_FECTL_ENABLED 1
#define TRACE_VTD_REG_WRITE_IECTL_ENABLED 1
#define TRACE_VTD_REG_ICS_CLEAR_IP_ENABLED 1
#define TRACE_VTD_DMAR_TRANSLATE_ENABLED 1
#define TRACE_VTD_DMAR_ENABLE_ENABLED 1
#define TRACE_VTD_DMAR_FAULT_ENABLED 1
#define TRACE_VTD_IR_ENABLE_ENABLED 1
#define TRACE_VTD_IR_IRTE_GET_ENABLED 1
#define TRACE_VTD_IR_REMAP_ENABLED 1
#define TRACE_VTD_IR_REMAP_TYPE_ENABLED 1
#define TRACE_VTD_IR_REMAP_MSI_ENABLED 1
#define TRACE_VTD_IR_REMAP_MSI_REQ_ENABLED 1
#define TRACE_VTD_FSTS_PPF_ENABLED 1
#define TRACE_VTD_FSTS_CLEAR_IP_ENABLED 1
#define TRACE_VTD_FRR_NEW_ENABLED 1
#define TRACE_VTD_WARN_INVALID_QI_TAIL_ENABLED 1
#define TRACE_VTD_WARN_IR_VECTOR_ENABLED 1
#define TRACE_VTD_WARN_IR_TRIGGER_ENABLED 1
#define TRACE_AMDVI_EVNTLOG_FAIL_ENABLED 1
#define TRACE_AMDVI_CACHE_UPDATE_ENABLED 1
#define TRACE_AMDVI_COMPLETION_WAIT_FAIL_ENABLED 1
#define TRACE_AMDVI_MMIO_WRITE_ENABLED 1
#define TRACE_AMDVI_MMIO_READ_ENABLED 1
#define TRACE_AMDVI_MMIO_READ_INVALID_ENABLED 1
#define TRACE_AMDVI_COMMAND_ERROR_ENABLED 1
#define TRACE_AMDVI_COMMAND_READ_FAIL_ENABLED 1
#define TRACE_AMDVI_COMMAND_EXEC_ENABLED 1
#define TRACE_AMDVI_UNHANDLED_COMMAND_ENABLED 1
#define TRACE_AMDVI_INTR_INVAL_ENABLED 1
#define TRACE_AMDVI_IOTLB_INVAL_ENABLED 1
#define TRACE_AMDVI_PREFETCH_PAGES_ENABLED 1
#define TRACE_AMDVI_PAGES_INVAL_ENABLED 1
#define TRACE_AMDVI_ALL_INVAL_ENABLED 1
#define TRACE_AMDVI_PPR_EXEC_ENABLED 1
#define TRACE_AMDVI_DEVTAB_INVAL_ENABLED 1
#define TRACE_AMDVI_COMPLETION_WAIT_ENABLED 1
#define TRACE_AMDVI_CONTROL_STATUS_ENABLED 1
#define TRACE_AMDVI_IOTLB_RESET_ENABLED 1
#define TRACE_AMDVI_DTE_GET_FAIL_ENABLED 1
#define TRACE_AMDVI_INVALID_DTE_ENABLED 1
#define TRACE_AMDVI_GET_PTE_HWERROR_ENABLED 1
#define TRACE_AMDVI_MODE_INVALID_ENABLED 1
#define TRACE_AMDVI_PAGE_FAULT_ENABLED 1
#define TRACE_AMDVI_IOTLB_HIT_ENABLED 1
#define TRACE_AMDVI_TRANSLATION_RESULT_ENABLED 1
#define TRACE_AMDVI_MEM_IR_WRITE_REQ_ENABLED 1
#define TRACE_AMDVI_MEM_IR_WRITE_ENABLED 1
#define TRACE_AMDVI_IR_REMAP_MSI_REQ_ENABLED 1
#define TRACE_AMDVI_IR_REMAP_MSI_ENABLED 1
#define TRACE_AMDVI_ERR_ENABLED 1
#define TRACE_AMDVI_IR_IRTE_ENABLED 1
#define TRACE_AMDVI_IR_IRTE_VAL_ENABLED 1
#define TRACE_AMDVI_IR_ERR_ENABLED 1
#define TRACE_AMDVI_IR_INTCTL_ENABLED 1
#define TRACE_AMDVI_IR_TARGET_ABORT_ENABLED 1
#define TRACE_AMDVI_IR_DELIVERY_MODE_ENABLED 1
#define TRACE_AMDVI_IR_IRTE_GA_VAL_ENABLED 1
#define TRACE_VMPORT_REGISTER_ENABLED 1
#define TRACE_VMPORT_COMMAND_ENABLED 1
#define TRACE_X86_GSI_INTERRUPT_ENABLED 1
#define TRACE_X86_PIC_INTERRUPT_ENABLED 1
#define TRACE_PORT92_READ_ENABLED 1
#define TRACE_PORT92_WRITE_ENABLED 1
#include "qemu/log-for-trace.h"


#define TRACE_X86_IOMMU_IEC_NOTIFY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_X86_IOMMU_IEC_NOTIFY) || \
    false)

static inline void _nocheck__trace_x86_iommu_iec_notify(bool global, uint32_t index, uint32_t mask)
{
    if (trace_event_get_state(TRACE_X86_IOMMU_IEC_NOTIFY) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:x86_iommu_iec_notify " "Notify IEC invalidation: global=%d index=%" PRIu32 " mask=%" PRIu32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , global, index, mask);
    }
}

static inline void trace_x86_iommu_iec_notify(bool global, uint32_t index, uint32_t mask)
{
    if (true) {
        _nocheck__trace_x86_iommu_iec_notify(global, index, mask);
    }
}

#define TRACE_VTD_INV_DESC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc(const char * type, uint64_t hi, uint64_t lo)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_inv_desc " "invalidate desc type %s high 0x%"PRIx64" low 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , type, hi, lo);
    }
}

static inline void trace_vtd_inv_desc(const char * type, uint64_t hi, uint64_t lo)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc(type, hi, lo);
    }
}

#define TRACE_VTD_INV_DESC_CC_DOMAIN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_CC_DOMAIN) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_cc_domain(uint16_t domain)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_CC_DOMAIN) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_inv_desc_cc_domain " "context invalidate domain 0x%"PRIx16 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , domain);
    }
}

static inline void trace_vtd_inv_desc_cc_domain(uint16_t domain)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_cc_domain(domain);
    }
}

#define TRACE_VTD_INV_DESC_CC_GLOBAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_CC_GLOBAL) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_cc_global(void)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_CC_GLOBAL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_inv_desc_cc_global " "context invalidate globally" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_vtd_inv_desc_cc_global(void)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_cc_global();
    }
}

#define TRACE_VTD_INV_DESC_CC_DEVICE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_CC_DEVICE) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_cc_device(uint8_t bus, uint8_t dev, uint8_t fn)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_CC_DEVICE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_inv_desc_cc_device " "context invalidate device %02"PRIx8":%02"PRIx8".%02"PRIx8 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, dev, fn);
    }
}

static inline void trace_vtd_inv_desc_cc_device(uint8_t bus, uint8_t dev, uint8_t fn)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_cc_device(bus, dev, fn);
    }
}

#define TRACE_VTD_INV_DESC_CC_DEVICES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_CC_DEVICES) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_cc_devices(uint16_t sid, uint16_t fmask)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_CC_DEVICES) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_inv_desc_cc_devices " "context invalidate devices sid 0x%"PRIx16" fmask 0x%"PRIx16 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , sid, fmask);
    }
}

static inline void trace_vtd_inv_desc_cc_devices(uint16_t sid, uint16_t fmask)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_cc_devices(sid, fmask);
    }
}

#define TRACE_VTD_INV_DESC_IOTLB_GLOBAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_IOTLB_GLOBAL) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_iotlb_global(void)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_IOTLB_GLOBAL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_inv_desc_iotlb_global " "iotlb invalidate global" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_vtd_inv_desc_iotlb_global(void)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_iotlb_global();
    }
}

#define TRACE_VTD_INV_DESC_IOTLB_DOMAIN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_IOTLB_DOMAIN) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_iotlb_domain(uint16_t domain)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_IOTLB_DOMAIN) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_inv_desc_iotlb_domain " "iotlb invalidate whole domain 0x%"PRIx16 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , domain);
    }
}

static inline void trace_vtd_inv_desc_iotlb_domain(uint16_t domain)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_iotlb_domain(domain);
    }
}

#define TRACE_VTD_INV_DESC_IOTLB_PAGES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_IOTLB_PAGES) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_iotlb_pages(uint16_t domain, uint64_t addr, uint8_t mask)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_IOTLB_PAGES) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_inv_desc_iotlb_pages " "iotlb invalidate domain 0x%"PRIx16" addr 0x%"PRIx64" mask 0x%"PRIx8 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , domain, addr, mask);
    }
}

static inline void trace_vtd_inv_desc_iotlb_pages(uint16_t domain, uint64_t addr, uint8_t mask)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_iotlb_pages(domain, addr, mask);
    }
}

#define TRACE_VTD_INV_DESC_WAIT_SW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_WAIT_SW) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_wait_sw(uint64_t addr, uint32_t data)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_WAIT_SW) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_inv_desc_wait_sw " "wait invalidate status write addr 0x%"PRIx64" data 0x%"PRIx32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, data);
    }
}

static inline void trace_vtd_inv_desc_wait_sw(uint64_t addr, uint32_t data)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_wait_sw(addr, data);
    }
}

#define TRACE_VTD_INV_DESC_WAIT_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_WAIT_IRQ) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_wait_irq(const char * msg)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_WAIT_IRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_inv_desc_wait_irq " "%s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , msg);
    }
}

static inline void trace_vtd_inv_desc_wait_irq(const char * msg)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_wait_irq(msg);
    }
}

#define TRACE_VTD_INV_DESC_WAIT_WRITE_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_WAIT_WRITE_FAIL) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_wait_write_fail(uint64_t hi, uint64_t lo)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_WAIT_WRITE_FAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_inv_desc_wait_write_fail " "write fail for wait desc hi 0x%"PRIx64" lo 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , hi, lo);
    }
}

static inline void trace_vtd_inv_desc_wait_write_fail(uint64_t hi, uint64_t lo)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_wait_write_fail(hi, lo);
    }
}

#define TRACE_VTD_INV_DESC_IEC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_IEC) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_iec(uint32_t granularity, uint32_t index, uint32_t mask)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_IEC) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_inv_desc_iec " "granularity 0x%"PRIx32" index 0x%"PRIx32" mask 0x%"PRIx32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , granularity, index, mask);
    }
}

static inline void trace_vtd_inv_desc_iec(uint32_t granularity, uint32_t index, uint32_t mask)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_iec(granularity, index, mask);
    }
}

#define TRACE_VTD_INV_QI_ENABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_QI_ENABLE) || \
    false)

static inline void _nocheck__trace_vtd_inv_qi_enable(bool enable)
{
    if (trace_event_get_state(TRACE_VTD_INV_QI_ENABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_inv_qi_enable " "enabled %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , enable);
    }
}

static inline void trace_vtd_inv_qi_enable(bool enable)
{
    if (true) {
        _nocheck__trace_vtd_inv_qi_enable(enable);
    }
}

#define TRACE_VTD_INV_QI_SETUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_QI_SETUP) || \
    false)

static inline void _nocheck__trace_vtd_inv_qi_setup(uint64_t addr, int size)
{
    if (trace_event_get_state(TRACE_VTD_INV_QI_SETUP) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_inv_qi_setup " "addr 0x%"PRIx64" size %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, size);
    }
}

static inline void trace_vtd_inv_qi_setup(uint64_t addr, int size)
{
    if (true) {
        _nocheck__trace_vtd_inv_qi_setup(addr, size);
    }
}

#define TRACE_VTD_INV_QI_HEAD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_QI_HEAD) || \
    false)

static inline void _nocheck__trace_vtd_inv_qi_head(uint16_t head)
{
    if (trace_event_get_state(TRACE_VTD_INV_QI_HEAD) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_inv_qi_head " "read head %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , head);
    }
}

static inline void trace_vtd_inv_qi_head(uint16_t head)
{
    if (true) {
        _nocheck__trace_vtd_inv_qi_head(head);
    }
}

#define TRACE_VTD_INV_QI_TAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_QI_TAIL) || \
    false)

static inline void _nocheck__trace_vtd_inv_qi_tail(uint16_t head)
{
    if (trace_event_get_state(TRACE_VTD_INV_QI_TAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_inv_qi_tail " "write tail %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , head);
    }
}

static inline void trace_vtd_inv_qi_tail(uint16_t head)
{
    if (true) {
        _nocheck__trace_vtd_inv_qi_tail(head);
    }
}

#define TRACE_VTD_INV_QI_FETCH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_QI_FETCH) || \
    false)

static inline void _nocheck__trace_vtd_inv_qi_fetch(void)
{
    if (trace_event_get_state(TRACE_VTD_INV_QI_FETCH) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_inv_qi_fetch " "" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_vtd_inv_qi_fetch(void)
{
    if (true) {
        _nocheck__trace_vtd_inv_qi_fetch();
    }
}

#define TRACE_VTD_CONTEXT_CACHE_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_CONTEXT_CACHE_RESET) || \
    false)

static inline void _nocheck__trace_vtd_context_cache_reset(void)
{
    if (trace_event_get_state(TRACE_VTD_CONTEXT_CACHE_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_context_cache_reset " "" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_vtd_context_cache_reset(void)
{
    if (true) {
        _nocheck__trace_vtd_context_cache_reset();
    }
}

#define TRACE_VTD_RE_NOT_PRESENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_RE_NOT_PRESENT) || \
    false)

static inline void _nocheck__trace_vtd_re_not_present(uint8_t bus)
{
    if (trace_event_get_state(TRACE_VTD_RE_NOT_PRESENT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_re_not_present " "Root entry bus %"PRIu8" not present" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus);
    }
}

static inline void trace_vtd_re_not_present(uint8_t bus)
{
    if (true) {
        _nocheck__trace_vtd_re_not_present(bus);
    }
}

#define TRACE_VTD_CE_NOT_PRESENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_CE_NOT_PRESENT) || \
    false)

static inline void _nocheck__trace_vtd_ce_not_present(uint8_t bus, uint8_t devfn)
{
    if (trace_event_get_state(TRACE_VTD_CE_NOT_PRESENT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_ce_not_present " "Context entry bus %"PRIu8" devfn %"PRIu8" not present" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, devfn);
    }
}

static inline void trace_vtd_ce_not_present(uint8_t bus, uint8_t devfn)
{
    if (true) {
        _nocheck__trace_vtd_ce_not_present(bus, devfn);
    }
}

#define TRACE_VTD_IOTLB_PAGE_HIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IOTLB_PAGE_HIT) || \
    false)

static inline void _nocheck__trace_vtd_iotlb_page_hit(uint16_t sid, uint64_t addr, uint64_t slpte, uint16_t domain)
{
    if (trace_event_get_state(TRACE_VTD_IOTLB_PAGE_HIT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_iotlb_page_hit " "IOTLB page hit sid 0x%"PRIx16" iova 0x%"PRIx64" slpte 0x%"PRIx64" domain 0x%"PRIx16 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , sid, addr, slpte, domain);
    }
}

static inline void trace_vtd_iotlb_page_hit(uint16_t sid, uint64_t addr, uint64_t slpte, uint16_t domain)
{
    if (true) {
        _nocheck__trace_vtd_iotlb_page_hit(sid, addr, slpte, domain);
    }
}

#define TRACE_VTD_IOTLB_PAGE_UPDATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IOTLB_PAGE_UPDATE) || \
    false)

static inline void _nocheck__trace_vtd_iotlb_page_update(uint16_t sid, uint64_t addr, uint64_t slpte, uint16_t domain)
{
    if (trace_event_get_state(TRACE_VTD_IOTLB_PAGE_UPDATE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_iotlb_page_update " "IOTLB page update sid 0x%"PRIx16" iova 0x%"PRIx64" slpte 0x%"PRIx64" domain 0x%"PRIx16 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , sid, addr, slpte, domain);
    }
}

static inline void trace_vtd_iotlb_page_update(uint16_t sid, uint64_t addr, uint64_t slpte, uint16_t domain)
{
    if (true) {
        _nocheck__trace_vtd_iotlb_page_update(sid, addr, slpte, domain);
    }
}

#define TRACE_VTD_IOTLB_CC_HIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IOTLB_CC_HIT) || \
    false)

static inline void _nocheck__trace_vtd_iotlb_cc_hit(uint8_t bus, uint8_t devfn, uint64_t high, uint64_t low, uint32_t gen)
{
    if (trace_event_get_state(TRACE_VTD_IOTLB_CC_HIT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_iotlb_cc_hit " "IOTLB context hit bus 0x%"PRIx8" devfn 0x%"PRIx8" high 0x%"PRIx64" low 0x%"PRIx64" gen %"PRIu32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, devfn, high, low, gen);
    }
}

static inline void trace_vtd_iotlb_cc_hit(uint8_t bus, uint8_t devfn, uint64_t high, uint64_t low, uint32_t gen)
{
    if (true) {
        _nocheck__trace_vtd_iotlb_cc_hit(bus, devfn, high, low, gen);
    }
}

#define TRACE_VTD_IOTLB_CC_UPDATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IOTLB_CC_UPDATE) || \
    false)

static inline void _nocheck__trace_vtd_iotlb_cc_update(uint8_t bus, uint8_t devfn, uint64_t high, uint64_t low, uint32_t gen1, uint32_t gen2)
{
    if (trace_event_get_state(TRACE_VTD_IOTLB_CC_UPDATE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_iotlb_cc_update " "IOTLB context update bus 0x%"PRIx8" devfn 0x%"PRIx8" high 0x%"PRIx64" low 0x%"PRIx64" gen %"PRIu32" -> gen %"PRIu32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, devfn, high, low, gen1, gen2);
    }
}

static inline void trace_vtd_iotlb_cc_update(uint8_t bus, uint8_t devfn, uint64_t high, uint64_t low, uint32_t gen1, uint32_t gen2)
{
    if (true) {
        _nocheck__trace_vtd_iotlb_cc_update(bus, devfn, high, low, gen1, gen2);
    }
}

#define TRACE_VTD_IOTLB_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IOTLB_RESET) || \
    false)

static inline void _nocheck__trace_vtd_iotlb_reset(const char * reason)
{
    if (trace_event_get_state(TRACE_VTD_IOTLB_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_iotlb_reset " "IOTLB reset (reason: %s)" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , reason);
    }
}

static inline void trace_vtd_iotlb_reset(const char * reason)
{
    if (true) {
        _nocheck__trace_vtd_iotlb_reset(reason);
    }
}

#define TRACE_VTD_FAULT_DISABLED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_FAULT_DISABLED) || \
    false)

static inline void _nocheck__trace_vtd_fault_disabled(void)
{
    if (trace_event_get_state(TRACE_VTD_FAULT_DISABLED) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_fault_disabled " "Fault processing disabled for context entry" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_vtd_fault_disabled(void)
{
    if (true) {
        _nocheck__trace_vtd_fault_disabled();
    }
}

#define TRACE_VTD_REPLAY_CE_VALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REPLAY_CE_VALID) || \
    false)

static inline void _nocheck__trace_vtd_replay_ce_valid(const char * mode, uint8_t bus, uint8_t dev, uint8_t fn, uint16_t domain, uint64_t hi, uint64_t lo)
{
    if (trace_event_get_state(TRACE_VTD_REPLAY_CE_VALID) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_replay_ce_valid " "%s: replay valid context device %02"PRIx8":%02"PRIx8".%02"PRIx8" domain 0x%"PRIx16" hi 0x%"PRIx64" lo 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , mode, bus, dev, fn, domain, hi, lo);
    }
}

static inline void trace_vtd_replay_ce_valid(const char * mode, uint8_t bus, uint8_t dev, uint8_t fn, uint16_t domain, uint64_t hi, uint64_t lo)
{
    if (true) {
        _nocheck__trace_vtd_replay_ce_valid(mode, bus, dev, fn, domain, hi, lo);
    }
}

#define TRACE_VTD_REPLAY_CE_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REPLAY_CE_INVALID) || \
    false)

static inline void _nocheck__trace_vtd_replay_ce_invalid(uint8_t bus, uint8_t dev, uint8_t fn)
{
    if (trace_event_get_state(TRACE_VTD_REPLAY_CE_INVALID) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_replay_ce_invalid " "replay invalid context device %02"PRIx8":%02"PRIx8".%02"PRIx8 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, dev, fn);
    }
}

static inline void trace_vtd_replay_ce_invalid(uint8_t bus, uint8_t dev, uint8_t fn)
{
    if (true) {
        _nocheck__trace_vtd_replay_ce_invalid(bus, dev, fn);
    }
}

#define TRACE_VTD_PAGE_WALK_LEVEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_PAGE_WALK_LEVEL) || \
    false)

static inline void _nocheck__trace_vtd_page_walk_level(uint64_t addr, uint32_t level, uint64_t start, uint64_t end)
{
    if (trace_event_get_state(TRACE_VTD_PAGE_WALK_LEVEL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_page_walk_level " "walk (base=0x%"PRIx64", level=%"PRIu32") iova range 0x%"PRIx64" - 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, level, start, end);
    }
}

static inline void trace_vtd_page_walk_level(uint64_t addr, uint32_t level, uint64_t start, uint64_t end)
{
    if (true) {
        _nocheck__trace_vtd_page_walk_level(addr, level, start, end);
    }
}

#define TRACE_VTD_PAGE_WALK_ONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_PAGE_WALK_ONE) || \
    false)

static inline void _nocheck__trace_vtd_page_walk_one(uint16_t domain, uint64_t iova, uint64_t gpa, uint64_t mask, int perm)
{
    if (trace_event_get_state(TRACE_VTD_PAGE_WALK_ONE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_page_walk_one " "domain 0x%"PRIu16" iova 0x%"PRIx64" -> gpa 0x%"PRIx64" mask 0x%"PRIx64" perm %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , domain, iova, gpa, mask, perm);
    }
}

static inline void trace_vtd_page_walk_one(uint16_t domain, uint64_t iova, uint64_t gpa, uint64_t mask, int perm)
{
    if (true) {
        _nocheck__trace_vtd_page_walk_one(domain, iova, gpa, mask, perm);
    }
}

#define TRACE_VTD_PAGE_WALK_ONE_SKIP_MAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_PAGE_WALK_ONE_SKIP_MAP) || \
    false)

static inline void _nocheck__trace_vtd_page_walk_one_skip_map(uint64_t iova, uint64_t mask, uint64_t translated)
{
    if (trace_event_get_state(TRACE_VTD_PAGE_WALK_ONE_SKIP_MAP) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_page_walk_one_skip_map " "iova 0x%"PRIx64" mask 0x%"PRIx64" translated 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , iova, mask, translated);
    }
}

static inline void trace_vtd_page_walk_one_skip_map(uint64_t iova, uint64_t mask, uint64_t translated)
{
    if (true) {
        _nocheck__trace_vtd_page_walk_one_skip_map(iova, mask, translated);
    }
}

#define TRACE_VTD_PAGE_WALK_ONE_SKIP_UNMAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_PAGE_WALK_ONE_SKIP_UNMAP) || \
    false)

static inline void _nocheck__trace_vtd_page_walk_one_skip_unmap(uint64_t iova, uint64_t mask)
{
    if (trace_event_get_state(TRACE_VTD_PAGE_WALK_ONE_SKIP_UNMAP) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_page_walk_one_skip_unmap " "iova 0x%"PRIx64" mask 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , iova, mask);
    }
}

static inline void trace_vtd_page_walk_one_skip_unmap(uint64_t iova, uint64_t mask)
{
    if (true) {
        _nocheck__trace_vtd_page_walk_one_skip_unmap(iova, mask);
    }
}

#define TRACE_VTD_PAGE_WALK_SKIP_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_PAGE_WALK_SKIP_READ) || \
    false)

static inline void _nocheck__trace_vtd_page_walk_skip_read(uint64_t iova, uint64_t next)
{
    if (trace_event_get_state(TRACE_VTD_PAGE_WALK_SKIP_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_page_walk_skip_read " "Page walk skip iova 0x%"PRIx64" - 0x%"PRIx64" due to unable to read" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , iova, next);
    }
}

static inline void trace_vtd_page_walk_skip_read(uint64_t iova, uint64_t next)
{
    if (true) {
        _nocheck__trace_vtd_page_walk_skip_read(iova, next);
    }
}

#define TRACE_VTD_PAGE_WALK_SKIP_RESERVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_PAGE_WALK_SKIP_RESERVE) || \
    false)

static inline void _nocheck__trace_vtd_page_walk_skip_reserve(uint64_t iova, uint64_t next)
{
    if (trace_event_get_state(TRACE_VTD_PAGE_WALK_SKIP_RESERVE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_page_walk_skip_reserve " "Page walk skip iova 0x%"PRIx64" - 0x%"PRIx64" due to rsrv set" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , iova, next);
    }
}

static inline void trace_vtd_page_walk_skip_reserve(uint64_t iova, uint64_t next)
{
    if (true) {
        _nocheck__trace_vtd_page_walk_skip_reserve(iova, next);
    }
}

#define TRACE_VTD_SWITCH_ADDRESS_SPACE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_SWITCH_ADDRESS_SPACE) || \
    false)

static inline void _nocheck__trace_vtd_switch_address_space(uint8_t bus, uint8_t slot, uint8_t fn, bool on)
{
    if (trace_event_get_state(TRACE_VTD_SWITCH_ADDRESS_SPACE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_switch_address_space " "Device %02x:%02x.%x switching address space (iommu enabled=%d)" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, slot, fn, on);
    }
}

static inline void trace_vtd_switch_address_space(uint8_t bus, uint8_t slot, uint8_t fn, bool on)
{
    if (true) {
        _nocheck__trace_vtd_switch_address_space(bus, slot, fn, on);
    }
}

#define TRACE_VTD_AS_UNMAP_WHOLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_AS_UNMAP_WHOLE) || \
    false)

static inline void _nocheck__trace_vtd_as_unmap_whole(uint8_t bus, uint8_t slot, uint8_t fn, uint64_t iova, uint64_t size)
{
    if (trace_event_get_state(TRACE_VTD_AS_UNMAP_WHOLE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_as_unmap_whole " "Device %02x:%02x.%x start 0x%"PRIx64" size 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, slot, fn, iova, size);
    }
}

static inline void trace_vtd_as_unmap_whole(uint8_t bus, uint8_t slot, uint8_t fn, uint64_t iova, uint64_t size)
{
    if (true) {
        _nocheck__trace_vtd_as_unmap_whole(bus, slot, fn, iova, size);
    }
}

#define TRACE_VTD_TRANSLATE_PT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_TRANSLATE_PT) || \
    false)

static inline void _nocheck__trace_vtd_translate_pt(uint16_t sid, uint64_t addr)
{
    if (trace_event_get_state(TRACE_VTD_TRANSLATE_PT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_translate_pt " "source id 0x%"PRIu16", iova 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , sid, addr);
    }
}

static inline void trace_vtd_translate_pt(uint16_t sid, uint64_t addr)
{
    if (true) {
        _nocheck__trace_vtd_translate_pt(sid, addr);
    }
}

#define TRACE_VTD_PT_ENABLE_FAST_PATH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_PT_ENABLE_FAST_PATH) || \
    false)

static inline void _nocheck__trace_vtd_pt_enable_fast_path(uint16_t sid, bool success)
{
    if (trace_event_get_state(TRACE_VTD_PT_ENABLE_FAST_PATH) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_pt_enable_fast_path " "sid 0x%"PRIu16" %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , sid, success);
    }
}

static inline void trace_vtd_pt_enable_fast_path(uint16_t sid, bool success)
{
    if (true) {
        _nocheck__trace_vtd_pt_enable_fast_path(sid, success);
    }
}

#define TRACE_VTD_IRQ_GENERATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IRQ_GENERATE) || \
    false)

static inline void _nocheck__trace_vtd_irq_generate(uint64_t addr, uint64_t data)
{
    if (trace_event_get_state(TRACE_VTD_IRQ_GENERATE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_irq_generate " "addr 0x%"PRIx64" data 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, data);
    }
}

static inline void trace_vtd_irq_generate(uint64_t addr, uint64_t data)
{
    if (true) {
        _nocheck__trace_vtd_irq_generate(addr, data);
    }
}

#define TRACE_VTD_REG_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REG_READ) || \
    false)

static inline void _nocheck__trace_vtd_reg_read(uint64_t addr, uint64_t size)
{
    if (trace_event_get_state(TRACE_VTD_REG_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_reg_read " "addr 0x%"PRIx64" size 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, size);
    }
}

static inline void trace_vtd_reg_read(uint64_t addr, uint64_t size)
{
    if (true) {
        _nocheck__trace_vtd_reg_read(addr, size);
    }
}

#define TRACE_VTD_REG_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REG_WRITE) || \
    false)

static inline void _nocheck__trace_vtd_reg_write(uint64_t addr, uint64_t size, uint64_t val)
{
    if (trace_event_get_state(TRACE_VTD_REG_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_reg_write " "addr 0x%"PRIx64" size 0x%"PRIx64" value 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, size, val);
    }
}

static inline void trace_vtd_reg_write(uint64_t addr, uint64_t size, uint64_t val)
{
    if (true) {
        _nocheck__trace_vtd_reg_write(addr, size, val);
    }
}

#define TRACE_VTD_REG_DMAR_ROOT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REG_DMAR_ROOT) || \
    false)

static inline void _nocheck__trace_vtd_reg_dmar_root(uint64_t addr, bool scalable)
{
    if (trace_event_get_state(TRACE_VTD_REG_DMAR_ROOT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_reg_dmar_root " "addr 0x%"PRIx64" scalable %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, scalable);
    }
}

static inline void trace_vtd_reg_dmar_root(uint64_t addr, bool scalable)
{
    if (true) {
        _nocheck__trace_vtd_reg_dmar_root(addr, scalable);
    }
}

#define TRACE_VTD_REG_IR_ROOT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REG_IR_ROOT) || \
    false)

static inline void _nocheck__trace_vtd_reg_ir_root(uint64_t addr, uint32_t size)
{
    if (trace_event_get_state(TRACE_VTD_REG_IR_ROOT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_reg_ir_root " "addr 0x%"PRIx64" size 0x%"PRIx32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, size);
    }
}

static inline void trace_vtd_reg_ir_root(uint64_t addr, uint32_t size)
{
    if (true) {
        _nocheck__trace_vtd_reg_ir_root(addr, size);
    }
}

#define TRACE_VTD_REG_WRITE_GCMD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REG_WRITE_GCMD) || \
    false)

static inline void _nocheck__trace_vtd_reg_write_gcmd(uint32_t status, uint32_t val)
{
    if (trace_event_get_state(TRACE_VTD_REG_WRITE_GCMD) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_reg_write_gcmd " "status 0x%"PRIx32" value 0x%"PRIx32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , status, val);
    }
}

static inline void trace_vtd_reg_write_gcmd(uint32_t status, uint32_t val)
{
    if (true) {
        _nocheck__trace_vtd_reg_write_gcmd(status, val);
    }
}

#define TRACE_VTD_REG_WRITE_FECTL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REG_WRITE_FECTL) || \
    false)

static inline void _nocheck__trace_vtd_reg_write_fectl(uint32_t value)
{
    if (trace_event_get_state(TRACE_VTD_REG_WRITE_FECTL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_reg_write_fectl " "value 0x%"PRIx32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , value);
    }
}

static inline void trace_vtd_reg_write_fectl(uint32_t value)
{
    if (true) {
        _nocheck__trace_vtd_reg_write_fectl(value);
    }
}

#define TRACE_VTD_REG_WRITE_IECTL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REG_WRITE_IECTL) || \
    false)

static inline void _nocheck__trace_vtd_reg_write_iectl(uint32_t value)
{
    if (trace_event_get_state(TRACE_VTD_REG_WRITE_IECTL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_reg_write_iectl " "value 0x%"PRIx32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , value);
    }
}

static inline void trace_vtd_reg_write_iectl(uint32_t value)
{
    if (true) {
        _nocheck__trace_vtd_reg_write_iectl(value);
    }
}

#define TRACE_VTD_REG_ICS_CLEAR_IP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REG_ICS_CLEAR_IP) || \
    false)

static inline void _nocheck__trace_vtd_reg_ics_clear_ip(void)
{
    if (trace_event_get_state(TRACE_VTD_REG_ICS_CLEAR_IP) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_reg_ics_clear_ip " "" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_vtd_reg_ics_clear_ip(void)
{
    if (true) {
        _nocheck__trace_vtd_reg_ics_clear_ip();
    }
}

#define TRACE_VTD_DMAR_TRANSLATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_DMAR_TRANSLATE) || \
    false)

static inline void _nocheck__trace_vtd_dmar_translate(uint8_t bus, uint8_t slot, uint8_t func, uint64_t iova, uint64_t gpa, uint64_t mask)
{
    if (trace_event_get_state(TRACE_VTD_DMAR_TRANSLATE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_dmar_translate " "dev %02x:%02x.%02x iova 0x%"PRIx64" -> gpa 0x%"PRIx64" mask 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, slot, func, iova, gpa, mask);
    }
}

static inline void trace_vtd_dmar_translate(uint8_t bus, uint8_t slot, uint8_t func, uint64_t iova, uint64_t gpa, uint64_t mask)
{
    if (true) {
        _nocheck__trace_vtd_dmar_translate(bus, slot, func, iova, gpa, mask);
    }
}

#define TRACE_VTD_DMAR_ENABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_DMAR_ENABLE) || \
    false)

static inline void _nocheck__trace_vtd_dmar_enable(bool en)
{
    if (trace_event_get_state(TRACE_VTD_DMAR_ENABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_dmar_enable " "enable %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , en);
    }
}

static inline void trace_vtd_dmar_enable(bool en)
{
    if (true) {
        _nocheck__trace_vtd_dmar_enable(en);
    }
}

#define TRACE_VTD_DMAR_FAULT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_DMAR_FAULT) || \
    false)

static inline void _nocheck__trace_vtd_dmar_fault(uint16_t sid, int fault, uint64_t addr, bool is_write)
{
    if (trace_event_get_state(TRACE_VTD_DMAR_FAULT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_dmar_fault " "sid 0x%"PRIx16" fault %d addr 0x%"PRIx64" write %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , sid, fault, addr, is_write);
    }
}

static inline void trace_vtd_dmar_fault(uint16_t sid, int fault, uint64_t addr, bool is_write)
{
    if (true) {
        _nocheck__trace_vtd_dmar_fault(sid, fault, addr, is_write);
    }
}

#define TRACE_VTD_IR_ENABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IR_ENABLE) || \
    false)

static inline void _nocheck__trace_vtd_ir_enable(bool en)
{
    if (trace_event_get_state(TRACE_VTD_IR_ENABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_ir_enable " "enable %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , en);
    }
}

static inline void trace_vtd_ir_enable(bool en)
{
    if (true) {
        _nocheck__trace_vtd_ir_enable(en);
    }
}

#define TRACE_VTD_IR_IRTE_GET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IR_IRTE_GET) || \
    false)

static inline void _nocheck__trace_vtd_ir_irte_get(int index, uint64_t lo, uint64_t hi)
{
    if (trace_event_get_state(TRACE_VTD_IR_IRTE_GET) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_ir_irte_get " "index %d low 0x%"PRIx64" high 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , index, lo, hi);
    }
}

static inline void trace_vtd_ir_irte_get(int index, uint64_t lo, uint64_t hi)
{
    if (true) {
        _nocheck__trace_vtd_ir_irte_get(index, lo, hi);
    }
}

#define TRACE_VTD_IR_REMAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IR_REMAP) || \
    false)

static inline void _nocheck__trace_vtd_ir_remap(int index, int tri, int vec, int deliver, uint32_t dest, int dest_mode)
{
    if (trace_event_get_state(TRACE_VTD_IR_REMAP) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_ir_remap " "index %d trigger %d vector %d deliver %d dest 0x%"PRIx32" mode %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , index, tri, vec, deliver, dest, dest_mode);
    }
}

static inline void trace_vtd_ir_remap(int index, int tri, int vec, int deliver, uint32_t dest, int dest_mode)
{
    if (true) {
        _nocheck__trace_vtd_ir_remap(index, tri, vec, deliver, dest, dest_mode);
    }
}

#define TRACE_VTD_IR_REMAP_TYPE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IR_REMAP_TYPE) || \
    false)

static inline void _nocheck__trace_vtd_ir_remap_type(const char * type)
{
    if (trace_event_get_state(TRACE_VTD_IR_REMAP_TYPE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_ir_remap_type " "%s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , type);
    }
}

static inline void trace_vtd_ir_remap_type(const char * type)
{
    if (true) {
        _nocheck__trace_vtd_ir_remap_type(type);
    }
}

#define TRACE_VTD_IR_REMAP_MSI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IR_REMAP_MSI) || \
    false)

static inline void _nocheck__trace_vtd_ir_remap_msi(uint64_t addr, uint64_t data, uint64_t addr2, uint64_t data2)
{
    if (trace_event_get_state(TRACE_VTD_IR_REMAP_MSI) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_ir_remap_msi " "(addr 0x%"PRIx64", data 0x%"PRIx64") -> (addr 0x%"PRIx64", data 0x%"PRIx64")" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, data, addr2, data2);
    }
}

static inline void trace_vtd_ir_remap_msi(uint64_t addr, uint64_t data, uint64_t addr2, uint64_t data2)
{
    if (true) {
        _nocheck__trace_vtd_ir_remap_msi(addr, data, addr2, data2);
    }
}

#define TRACE_VTD_IR_REMAP_MSI_REQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IR_REMAP_MSI_REQ) || \
    false)

static inline void _nocheck__trace_vtd_ir_remap_msi_req(uint64_t addr, uint64_t data)
{
    if (trace_event_get_state(TRACE_VTD_IR_REMAP_MSI_REQ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_ir_remap_msi_req " "addr 0x%"PRIx64" data 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, data);
    }
}

static inline void trace_vtd_ir_remap_msi_req(uint64_t addr, uint64_t data)
{
    if (true) {
        _nocheck__trace_vtd_ir_remap_msi_req(addr, data);
    }
}

#define TRACE_VTD_FSTS_PPF_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_FSTS_PPF) || \
    false)

static inline void _nocheck__trace_vtd_fsts_ppf(bool set)
{
    if (trace_event_get_state(TRACE_VTD_FSTS_PPF) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_fsts_ppf " "FSTS PPF bit set to %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , set);
    }
}

static inline void trace_vtd_fsts_ppf(bool set)
{
    if (true) {
        _nocheck__trace_vtd_fsts_ppf(set);
    }
}

#define TRACE_VTD_FSTS_CLEAR_IP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_FSTS_CLEAR_IP) || \
    false)

static inline void _nocheck__trace_vtd_fsts_clear_ip(void)
{
    if (trace_event_get_state(TRACE_VTD_FSTS_CLEAR_IP) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_fsts_clear_ip " "" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_vtd_fsts_clear_ip(void)
{
    if (true) {
        _nocheck__trace_vtd_fsts_clear_ip();
    }
}

#define TRACE_VTD_FRR_NEW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_FRR_NEW) || \
    false)

static inline void _nocheck__trace_vtd_frr_new(int index, uint64_t hi, uint64_t lo)
{
    if (trace_event_get_state(TRACE_VTD_FRR_NEW) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_frr_new " "index %d high 0x%"PRIx64" low 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , index, hi, lo);
    }
}

static inline void trace_vtd_frr_new(int index, uint64_t hi, uint64_t lo)
{
    if (true) {
        _nocheck__trace_vtd_frr_new(index, hi, lo);
    }
}

#define TRACE_VTD_WARN_INVALID_QI_TAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_WARN_INVALID_QI_TAIL) || \
    false)

static inline void _nocheck__trace_vtd_warn_invalid_qi_tail(uint16_t tail)
{
    if (trace_event_get_state(TRACE_VTD_WARN_INVALID_QI_TAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_warn_invalid_qi_tail " "tail 0x%"PRIx16 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , tail);
    }
}

static inline void trace_vtd_warn_invalid_qi_tail(uint16_t tail)
{
    if (true) {
        _nocheck__trace_vtd_warn_invalid_qi_tail(tail);
    }
}

#define TRACE_VTD_WARN_IR_VECTOR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_WARN_IR_VECTOR) || \
    false)

static inline void _nocheck__trace_vtd_warn_ir_vector(uint16_t sid, int index, int vec, int target)
{
    if (trace_event_get_state(TRACE_VTD_WARN_IR_VECTOR) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_warn_ir_vector " "sid 0x%"PRIx16" index %d vec %d (should be: %d)" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , sid, index, vec, target);
    }
}

static inline void trace_vtd_warn_ir_vector(uint16_t sid, int index, int vec, int target)
{
    if (true) {
        _nocheck__trace_vtd_warn_ir_vector(sid, index, vec, target);
    }
}

#define TRACE_VTD_WARN_IR_TRIGGER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_WARN_IR_TRIGGER) || \
    false)

static inline void _nocheck__trace_vtd_warn_ir_trigger(uint16_t sid, int index, int trig, int target)
{
    if (trace_event_get_state(TRACE_VTD_WARN_IR_TRIGGER) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vtd_warn_ir_trigger " "sid 0x%"PRIx16" index %d trigger %d (should be: %d)" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , sid, index, trig, target);
    }
}

static inline void trace_vtd_warn_ir_trigger(uint16_t sid, int index, int trig, int target)
{
    if (true) {
        _nocheck__trace_vtd_warn_ir_trigger(sid, index, trig, target);
    }
}

#define TRACE_AMDVI_EVNTLOG_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_EVNTLOG_FAIL) || \
    false)

static inline void _nocheck__trace_amdvi_evntlog_fail(uint64_t addr, uint32_t head)
{
    if (trace_event_get_state(TRACE_AMDVI_EVNTLOG_FAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_evntlog_fail " "error: fail to write at addr 0x%"PRIx64" +  offset 0x%"PRIx32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, head);
    }
}

static inline void trace_amdvi_evntlog_fail(uint64_t addr, uint32_t head)
{
    if (true) {
        _nocheck__trace_amdvi_evntlog_fail(addr, head);
    }
}

#define TRACE_AMDVI_CACHE_UPDATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_CACHE_UPDATE) || \
    false)

static inline void _nocheck__trace_amdvi_cache_update(uint16_t domid, uint8_t bus, uint8_t slot, uint8_t func, uint64_t gpa, uint64_t txaddr)
{
    if (trace_event_get_state(TRACE_AMDVI_CACHE_UPDATE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_cache_update " " update iotlb domid 0x%"PRIx16" devid: %02x:%02x.%x gpa 0x%"PRIx64" hpa 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , domid, bus, slot, func, gpa, txaddr);
    }
}

static inline void trace_amdvi_cache_update(uint16_t domid, uint8_t bus, uint8_t slot, uint8_t func, uint64_t gpa, uint64_t txaddr)
{
    if (true) {
        _nocheck__trace_amdvi_cache_update(domid, bus, slot, func, gpa, txaddr);
    }
}

#define TRACE_AMDVI_COMPLETION_WAIT_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_COMPLETION_WAIT_FAIL) || \
    false)

static inline void _nocheck__trace_amdvi_completion_wait_fail(uint64_t addr)
{
    if (trace_event_get_state(TRACE_AMDVI_COMPLETION_WAIT_FAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_completion_wait_fail " "error: fail to write at address 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr);
    }
}

static inline void trace_amdvi_completion_wait_fail(uint64_t addr)
{
    if (true) {
        _nocheck__trace_amdvi_completion_wait_fail(addr);
    }
}

#define TRACE_AMDVI_MMIO_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_MMIO_WRITE) || \
    false)

static inline void _nocheck__trace_amdvi_mmio_write(const char * reg, uint64_t addr, unsigned size, uint64_t val, uint64_t offset)
{
    if (trace_event_get_state(TRACE_AMDVI_MMIO_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_mmio_write " "%s write addr 0x%"PRIx64", size %u, val 0x%"PRIx64", offset 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , reg, addr, size, val, offset);
    }
}

static inline void trace_amdvi_mmio_write(const char * reg, uint64_t addr, unsigned size, uint64_t val, uint64_t offset)
{
    if (true) {
        _nocheck__trace_amdvi_mmio_write(reg, addr, size, val, offset);
    }
}

#define TRACE_AMDVI_MMIO_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_MMIO_READ) || \
    false)

static inline void _nocheck__trace_amdvi_mmio_read(const char * reg, uint64_t addr, unsigned size, uint64_t offset)
{
    if (trace_event_get_state(TRACE_AMDVI_MMIO_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_mmio_read " "%s read addr 0x%"PRIx64", size %u offset 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , reg, addr, size, offset);
    }
}

static inline void trace_amdvi_mmio_read(const char * reg, uint64_t addr, unsigned size, uint64_t offset)
{
    if (true) {
        _nocheck__trace_amdvi_mmio_read(reg, addr, size, offset);
    }
}

#define TRACE_AMDVI_MMIO_READ_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_MMIO_READ_INVALID) || \
    false)

static inline void _nocheck__trace_amdvi_mmio_read_invalid(int max, uint64_t addr, unsigned size)
{
    if (trace_event_get_state(TRACE_AMDVI_MMIO_READ_INVALID) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_mmio_read_invalid " "error: addr outside region (max 0x%x): read addr 0x%" PRIx64 ", size %u" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , max, addr, size);
    }
}

static inline void trace_amdvi_mmio_read_invalid(int max, uint64_t addr, unsigned size)
{
    if (true) {
        _nocheck__trace_amdvi_mmio_read_invalid(max, addr, size);
    }
}

#define TRACE_AMDVI_COMMAND_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_COMMAND_ERROR) || \
    false)

static inline void _nocheck__trace_amdvi_command_error(uint64_t status)
{
    if (trace_event_get_state(TRACE_AMDVI_COMMAND_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_command_error " "error: Executing commands with command buffer disabled 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , status);
    }
}

static inline void trace_amdvi_command_error(uint64_t status)
{
    if (true) {
        _nocheck__trace_amdvi_command_error(status);
    }
}

#define TRACE_AMDVI_COMMAND_READ_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_COMMAND_READ_FAIL) || \
    false)

static inline void _nocheck__trace_amdvi_command_read_fail(uint64_t addr, uint32_t head)
{
    if (trace_event_get_state(TRACE_AMDVI_COMMAND_READ_FAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_command_read_fail " "error: fail to access memory at 0x%"PRIx64" + 0x%"PRIx32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, head);
    }
}

static inline void trace_amdvi_command_read_fail(uint64_t addr, uint32_t head)
{
    if (true) {
        _nocheck__trace_amdvi_command_read_fail(addr, head);
    }
}

#define TRACE_AMDVI_COMMAND_EXEC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_COMMAND_EXEC) || \
    false)

static inline void _nocheck__trace_amdvi_command_exec(uint32_t head, uint32_t tail, uint64_t buf)
{
    if (trace_event_get_state(TRACE_AMDVI_COMMAND_EXEC) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_command_exec " "command buffer head at 0x%"PRIx32" command buffer tail at 0x%"PRIx32" command buffer base at 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , head, tail, buf);
    }
}

static inline void trace_amdvi_command_exec(uint32_t head, uint32_t tail, uint64_t buf)
{
    if (true) {
        _nocheck__trace_amdvi_command_exec(head, tail, buf);
    }
}

#define TRACE_AMDVI_UNHANDLED_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_UNHANDLED_COMMAND) || \
    false)

static inline void _nocheck__trace_amdvi_unhandled_command(uint8_t type)
{
    if (trace_event_get_state(TRACE_AMDVI_UNHANDLED_COMMAND) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_unhandled_command " "unhandled command 0x%"PRIx8 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , type);
    }
}

static inline void trace_amdvi_unhandled_command(uint8_t type)
{
    if (true) {
        _nocheck__trace_amdvi_unhandled_command(type);
    }
}

#define TRACE_AMDVI_INTR_INVAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_INTR_INVAL) || \
    false)

static inline void _nocheck__trace_amdvi_intr_inval(void)
{
    if (trace_event_get_state(TRACE_AMDVI_INTR_INVAL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_intr_inval " "Interrupt table invalidated" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_amdvi_intr_inval(void)
{
    if (true) {
        _nocheck__trace_amdvi_intr_inval();
    }
}

#define TRACE_AMDVI_IOTLB_INVAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IOTLB_INVAL) || \
    false)

static inline void _nocheck__trace_amdvi_iotlb_inval(void)
{
    if (trace_event_get_state(TRACE_AMDVI_IOTLB_INVAL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_iotlb_inval " "IOTLB pages invalidated" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_amdvi_iotlb_inval(void)
{
    if (true) {
        _nocheck__trace_amdvi_iotlb_inval();
    }
}

#define TRACE_AMDVI_PREFETCH_PAGES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_PREFETCH_PAGES) || \
    false)

static inline void _nocheck__trace_amdvi_prefetch_pages(void)
{
    if (trace_event_get_state(TRACE_AMDVI_PREFETCH_PAGES) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_prefetch_pages " "Pre-fetch of AMD-Vi pages requested" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_amdvi_prefetch_pages(void)
{
    if (true) {
        _nocheck__trace_amdvi_prefetch_pages();
    }
}

#define TRACE_AMDVI_PAGES_INVAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_PAGES_INVAL) || \
    false)

static inline void _nocheck__trace_amdvi_pages_inval(uint16_t domid)
{
    if (trace_event_get_state(TRACE_AMDVI_PAGES_INVAL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_pages_inval " "AMD-Vi pages for domain 0x%"PRIx16 " invalidated" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , domid);
    }
}

static inline void trace_amdvi_pages_inval(uint16_t domid)
{
    if (true) {
        _nocheck__trace_amdvi_pages_inval(domid);
    }
}

#define TRACE_AMDVI_ALL_INVAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_ALL_INVAL) || \
    false)

static inline void _nocheck__trace_amdvi_all_inval(void)
{
    if (trace_event_get_state(TRACE_AMDVI_ALL_INVAL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_all_inval " "Invalidation of all AMD-Vi cache requested " "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_amdvi_all_inval(void)
{
    if (true) {
        _nocheck__trace_amdvi_all_inval();
    }
}

#define TRACE_AMDVI_PPR_EXEC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_PPR_EXEC) || \
    false)

static inline void _nocheck__trace_amdvi_ppr_exec(void)
{
    if (trace_event_get_state(TRACE_AMDVI_PPR_EXEC) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_ppr_exec " "Execution of PPR queue requested " "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_amdvi_ppr_exec(void)
{
    if (true) {
        _nocheck__trace_amdvi_ppr_exec();
    }
}

#define TRACE_AMDVI_DEVTAB_INVAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_DEVTAB_INVAL) || \
    false)

static inline void _nocheck__trace_amdvi_devtab_inval(uint8_t bus, uint8_t slot, uint8_t func)
{
    if (trace_event_get_state(TRACE_AMDVI_DEVTAB_INVAL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_devtab_inval " "device table entry for devid: %02x:%02x.%x invalidated" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, slot, func);
    }
}

static inline void trace_amdvi_devtab_inval(uint8_t bus, uint8_t slot, uint8_t func)
{
    if (true) {
        _nocheck__trace_amdvi_devtab_inval(bus, slot, func);
    }
}

#define TRACE_AMDVI_COMPLETION_WAIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_COMPLETION_WAIT) || \
    false)

static inline void _nocheck__trace_amdvi_completion_wait(uint64_t addr, uint64_t data)
{
    if (trace_event_get_state(TRACE_AMDVI_COMPLETION_WAIT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_completion_wait " "completion wait requested with store address 0x%"PRIx64" and store data 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, data);
    }
}

static inline void trace_amdvi_completion_wait(uint64_t addr, uint64_t data)
{
    if (true) {
        _nocheck__trace_amdvi_completion_wait(addr, data);
    }
}

#define TRACE_AMDVI_CONTROL_STATUS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_CONTROL_STATUS) || \
    false)

static inline void _nocheck__trace_amdvi_control_status(uint64_t val)
{
    if (trace_event_get_state(TRACE_AMDVI_CONTROL_STATUS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_control_status " "MMIO_STATUS state 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , val);
    }
}

static inline void trace_amdvi_control_status(uint64_t val)
{
    if (true) {
        _nocheck__trace_amdvi_control_status(val);
    }
}

#define TRACE_AMDVI_IOTLB_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IOTLB_RESET) || \
    false)

static inline void _nocheck__trace_amdvi_iotlb_reset(void)
{
    if (trace_event_get_state(TRACE_AMDVI_IOTLB_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_iotlb_reset " "IOTLB exceed size limit - reset " "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_amdvi_iotlb_reset(void)
{
    if (true) {
        _nocheck__trace_amdvi_iotlb_reset();
    }
}

#define TRACE_AMDVI_DTE_GET_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_DTE_GET_FAIL) || \
    false)

static inline void _nocheck__trace_amdvi_dte_get_fail(uint64_t addr, uint32_t offset)
{
    if (trace_event_get_state(TRACE_AMDVI_DTE_GET_FAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_dte_get_fail " "error: failed to access Device Entry devtab 0x%"PRIx64" offset 0x%"PRIx32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, offset);
    }
}

static inline void trace_amdvi_dte_get_fail(uint64_t addr, uint32_t offset)
{
    if (true) {
        _nocheck__trace_amdvi_dte_get_fail(addr, offset);
    }
}

#define TRACE_AMDVI_INVALID_DTE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_INVALID_DTE) || \
    false)

static inline void _nocheck__trace_amdvi_invalid_dte(uint64_t addr)
{
    if (trace_event_get_state(TRACE_AMDVI_INVALID_DTE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_invalid_dte " "PTE entry at 0x%"PRIx64" is invalid " "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr);
    }
}

static inline void trace_amdvi_invalid_dte(uint64_t addr)
{
    if (true) {
        _nocheck__trace_amdvi_invalid_dte(addr);
    }
}

#define TRACE_AMDVI_GET_PTE_HWERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_GET_PTE_HWERROR) || \
    false)

static inline void _nocheck__trace_amdvi_get_pte_hwerror(uint64_t addr)
{
    if (trace_event_get_state(TRACE_AMDVI_GET_PTE_HWERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_get_pte_hwerror " "hardware error eccessing PTE at addr 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr);
    }
}

static inline void trace_amdvi_get_pte_hwerror(uint64_t addr)
{
    if (true) {
        _nocheck__trace_amdvi_get_pte_hwerror(addr);
    }
}

#define TRACE_AMDVI_MODE_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_MODE_INVALID) || \
    false)

static inline void _nocheck__trace_amdvi_mode_invalid(uint8_t level, uint64_t addr)
{
    if (trace_event_get_state(TRACE_AMDVI_MODE_INVALID) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_mode_invalid " "error: translation level 0x%"PRIx8" translating addr 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , level, addr);
    }
}

static inline void trace_amdvi_mode_invalid(uint8_t level, uint64_t addr)
{
    if (true) {
        _nocheck__trace_amdvi_mode_invalid(level, addr);
    }
}

#define TRACE_AMDVI_PAGE_FAULT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_PAGE_FAULT) || \
    false)

static inline void _nocheck__trace_amdvi_page_fault(uint64_t addr)
{
    if (trace_event_get_state(TRACE_AMDVI_PAGE_FAULT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_page_fault " "error: page fault accessing guest physical address 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr);
    }
}

static inline void trace_amdvi_page_fault(uint64_t addr)
{
    if (true) {
        _nocheck__trace_amdvi_page_fault(addr);
    }
}

#define TRACE_AMDVI_IOTLB_HIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IOTLB_HIT) || \
    false)

static inline void _nocheck__trace_amdvi_iotlb_hit(uint8_t bus, uint8_t slot, uint8_t func, uint64_t addr, uint64_t txaddr)
{
    if (trace_event_get_state(TRACE_AMDVI_IOTLB_HIT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_iotlb_hit " "hit iotlb devid %02x:%02x.%x gpa 0x%"PRIx64" hpa 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, slot, func, addr, txaddr);
    }
}

static inline void trace_amdvi_iotlb_hit(uint8_t bus, uint8_t slot, uint8_t func, uint64_t addr, uint64_t txaddr)
{
    if (true) {
        _nocheck__trace_amdvi_iotlb_hit(bus, slot, func, addr, txaddr);
    }
}

#define TRACE_AMDVI_TRANSLATION_RESULT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_TRANSLATION_RESULT) || \
    false)

static inline void _nocheck__trace_amdvi_translation_result(uint8_t bus, uint8_t slot, uint8_t func, uint64_t addr, uint64_t txaddr)
{
    if (trace_event_get_state(TRACE_AMDVI_TRANSLATION_RESULT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_translation_result " "devid: %02x:%02x.%x gpa 0x%"PRIx64" hpa 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , bus, slot, func, addr, txaddr);
    }
}

static inline void trace_amdvi_translation_result(uint8_t bus, uint8_t slot, uint8_t func, uint64_t addr, uint64_t txaddr)
{
    if (true) {
        _nocheck__trace_amdvi_translation_result(bus, slot, func, addr, txaddr);
    }
}

#define TRACE_AMDVI_MEM_IR_WRITE_REQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_MEM_IR_WRITE_REQ) || \
    false)

static inline void _nocheck__trace_amdvi_mem_ir_write_req(uint64_t addr, uint64_t val, uint32_t size)
{
    if (trace_event_get_state(TRACE_AMDVI_MEM_IR_WRITE_REQ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_mem_ir_write_req " "addr 0x%"PRIx64" data 0x%"PRIx64" size 0x%"PRIx32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, val, size);
    }
}

static inline void trace_amdvi_mem_ir_write_req(uint64_t addr, uint64_t val, uint32_t size)
{
    if (true) {
        _nocheck__trace_amdvi_mem_ir_write_req(addr, val, size);
    }
}

#define TRACE_AMDVI_MEM_IR_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_MEM_IR_WRITE) || \
    false)

static inline void _nocheck__trace_amdvi_mem_ir_write(uint64_t addr, uint64_t val)
{
    if (trace_event_get_state(TRACE_AMDVI_MEM_IR_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_mem_ir_write " "addr 0x%"PRIx64" data 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, val);
    }
}

static inline void trace_amdvi_mem_ir_write(uint64_t addr, uint64_t val)
{
    if (true) {
        _nocheck__trace_amdvi_mem_ir_write(addr, val);
    }
}

#define TRACE_AMDVI_IR_REMAP_MSI_REQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IR_REMAP_MSI_REQ) || \
    false)

static inline void _nocheck__trace_amdvi_ir_remap_msi_req(uint64_t addr, uint64_t data, uint8_t devid)
{
    if (trace_event_get_state(TRACE_AMDVI_IR_REMAP_MSI_REQ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_ir_remap_msi_req " "addr 0x%"PRIx64" data 0x%"PRIx64" devid 0x%"PRIx8 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, data, devid);
    }
}

static inline void trace_amdvi_ir_remap_msi_req(uint64_t addr, uint64_t data, uint8_t devid)
{
    if (true) {
        _nocheck__trace_amdvi_ir_remap_msi_req(addr, data, devid);
    }
}

#define TRACE_AMDVI_IR_REMAP_MSI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IR_REMAP_MSI) || \
    false)

static inline void _nocheck__trace_amdvi_ir_remap_msi(uint64_t addr, uint64_t data, uint64_t addr2, uint64_t data2)
{
    if (trace_event_get_state(TRACE_AMDVI_IR_REMAP_MSI) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_ir_remap_msi " "(addr 0x%"PRIx64", data 0x%"PRIx64") -> (addr 0x%"PRIx64", data 0x%"PRIx64")" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, data, addr2, data2);
    }
}

static inline void trace_amdvi_ir_remap_msi(uint64_t addr, uint64_t data, uint64_t addr2, uint64_t data2)
{
    if (true) {
        _nocheck__trace_amdvi_ir_remap_msi(addr, data, addr2, data2);
    }
}

#define TRACE_AMDVI_ERR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_ERR) || \
    false)

static inline void _nocheck__trace_amdvi_err(const char * str)
{
    if (trace_event_get_state(TRACE_AMDVI_ERR) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_err " "%s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , str);
    }
}

static inline void trace_amdvi_err(const char * str)
{
    if (true) {
        _nocheck__trace_amdvi_err(str);
    }
}

#define TRACE_AMDVI_IR_IRTE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IR_IRTE) || \
    false)

static inline void _nocheck__trace_amdvi_ir_irte(uint64_t addr, uint64_t data)
{
    if (trace_event_get_state(TRACE_AMDVI_IR_IRTE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_ir_irte " "addr 0x%"PRIx64" offset 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, data);
    }
}

static inline void trace_amdvi_ir_irte(uint64_t addr, uint64_t data)
{
    if (true) {
        _nocheck__trace_amdvi_ir_irte(addr, data);
    }
}

#define TRACE_AMDVI_IR_IRTE_VAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IR_IRTE_VAL) || \
    false)

static inline void _nocheck__trace_amdvi_ir_irte_val(uint32_t data)
{
    if (trace_event_get_state(TRACE_AMDVI_IR_IRTE_VAL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_ir_irte_val " "data 0x%"PRIx32 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , data);
    }
}

static inline void trace_amdvi_ir_irte_val(uint32_t data)
{
    if (true) {
        _nocheck__trace_amdvi_ir_irte_val(data);
    }
}

#define TRACE_AMDVI_IR_ERR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IR_ERR) || \
    false)

static inline void _nocheck__trace_amdvi_ir_err(const char * str)
{
    if (trace_event_get_state(TRACE_AMDVI_IR_ERR) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_ir_err " "%s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , str);
    }
}

static inline void trace_amdvi_ir_err(const char * str)
{
    if (true) {
        _nocheck__trace_amdvi_ir_err(str);
    }
}

#define TRACE_AMDVI_IR_INTCTL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IR_INTCTL) || \
    false)

static inline void _nocheck__trace_amdvi_ir_intctl(uint8_t val)
{
    if (trace_event_get_state(TRACE_AMDVI_IR_INTCTL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_ir_intctl " "int_ctl 0x%"PRIx8 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , val);
    }
}

static inline void trace_amdvi_ir_intctl(uint8_t val)
{
    if (true) {
        _nocheck__trace_amdvi_ir_intctl(val);
    }
}

#define TRACE_AMDVI_IR_TARGET_ABORT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IR_TARGET_ABORT) || \
    false)

static inline void _nocheck__trace_amdvi_ir_target_abort(const char * str)
{
    if (trace_event_get_state(TRACE_AMDVI_IR_TARGET_ABORT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_ir_target_abort " "%s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , str);
    }
}

static inline void trace_amdvi_ir_target_abort(const char * str)
{
    if (true) {
        _nocheck__trace_amdvi_ir_target_abort(str);
    }
}

#define TRACE_AMDVI_IR_DELIVERY_MODE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IR_DELIVERY_MODE) || \
    false)

static inline void _nocheck__trace_amdvi_ir_delivery_mode(const char * str)
{
    if (trace_event_get_state(TRACE_AMDVI_IR_DELIVERY_MODE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_ir_delivery_mode " "%s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , str);
    }
}

static inline void trace_amdvi_ir_delivery_mode(const char * str)
{
    if (true) {
        _nocheck__trace_amdvi_ir_delivery_mode(str);
    }
}

#define TRACE_AMDVI_IR_IRTE_GA_VAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IR_IRTE_GA_VAL) || \
    false)

static inline void _nocheck__trace_amdvi_ir_irte_ga_val(uint64_t hi, uint64_t lo)
{
    if (trace_event_get_state(TRACE_AMDVI_IR_IRTE_GA_VAL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:amdvi_ir_irte_ga_val " "hi 0x%"PRIx64" lo 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , hi, lo);
    }
}

static inline void trace_amdvi_ir_irte_ga_val(uint64_t hi, uint64_t lo)
{
    if (true) {
        _nocheck__trace_amdvi_ir_irte_ga_val(hi, lo);
    }
}

#define TRACE_VMPORT_REGISTER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMPORT_REGISTER) || \
    false)

static inline void _nocheck__trace_vmport_register(unsigned char command, void * func, void * opaque)
{
    if (trace_event_get_state(TRACE_VMPORT_REGISTER) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vmport_register " "command: 0x%02x func: %p opaque: %p" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , command, func, opaque);
    }
}

static inline void trace_vmport_register(unsigned char command, void * func, void * opaque)
{
    if (true) {
        _nocheck__trace_vmport_register(command, func, opaque);
    }
}

#define TRACE_VMPORT_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMPORT_COMMAND) || \
    false)

static inline void _nocheck__trace_vmport_command(unsigned char command)
{
    if (trace_event_get_state(TRACE_VMPORT_COMMAND) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vmport_command " "command: 0x%02x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , command);
    }
}

static inline void trace_vmport_command(unsigned char command)
{
    if (true) {
        _nocheck__trace_vmport_command(command);
    }
}

#define TRACE_X86_GSI_INTERRUPT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_X86_GSI_INTERRUPT) || \
    false)

static inline void _nocheck__trace_x86_gsi_interrupt(int irqn, int level)
{
    if (trace_event_get_state(TRACE_X86_GSI_INTERRUPT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:x86_gsi_interrupt " "GSI interrupt #%d level:%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , irqn, level);
    }
}

static inline void trace_x86_gsi_interrupt(int irqn, int level)
{
    if (true) {
        _nocheck__trace_x86_gsi_interrupt(irqn, level);
    }
}

#define TRACE_X86_PIC_INTERRUPT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_X86_PIC_INTERRUPT) || \
    false)

static inline void _nocheck__trace_x86_pic_interrupt(int irqn, int level)
{
    if (trace_event_get_state(TRACE_X86_PIC_INTERRUPT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:x86_pic_interrupt " "PIC interrupt #%d level:%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , irqn, level);
    }
}

static inline void trace_x86_pic_interrupt(int irqn, int level)
{
    if (true) {
        _nocheck__trace_x86_pic_interrupt(irqn, level);
    }
}

#define TRACE_PORT92_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PORT92_READ) || \
    false)

static inline void _nocheck__trace_port92_read(uint8_t val)
{
    if (trace_event_get_state(TRACE_PORT92_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:port92_read " "port92: read 0x%02x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , val);
    }
}

static inline void trace_port92_read(uint8_t val)
{
    if (true) {
        _nocheck__trace_port92_read(val);
    }
}

#define TRACE_PORT92_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PORT92_WRITE) || \
    false)

static inline void _nocheck__trace_port92_write(uint8_t val)
{
    if (trace_event_get_state(TRACE_PORT92_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:port92_write " "port92: write 0x%02x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , val);
    }
}

static inline void trace_port92_write(uint8_t val)
{
    if (true) {
        _nocheck__trace_port92_write(val);
    }
}
#endif /* TRACE_HW_I386_GENERATED_TRACERS_H */
