/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_BLOCK_GENERATED_TRACERS_H
#define TRACE_HW_BLOCK_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_FDC_IOPORT_READ_EVENT;
extern TraceEvent _TRACE_FDC_IOPORT_WRITE_EVENT;
extern TraceEvent _TRACE_FDCTRL_TC_PULSE_EVENT;
extern TraceEvent _TRACE_PFLASH_CHIP_ERASE_INVALID_EVENT;
extern TraceEvent _TRACE_PFLASH_CHIP_ERASE_START_EVENT;
extern TraceEvent _TRACE_PFLASH_DATA_READ_EVENT;
extern TraceEvent _TRACE_PFLASH_DATA_WRITE_EVENT;
extern TraceEvent _TRACE_PFLASH_DEVICE_ID_EVENT;
extern TraceEvent _TRACE_PFLASH_DEVICE_INFO_EVENT;
extern TraceEvent _TRACE_PFLASH_ERASE_COMPLETE_EVENT;
extern TraceEvent _TRACE_PFLASH_ERASE_TIMEOUT_EVENT;
extern TraceEvent _TRACE_PFLASH_IO_READ_EVENT;
extern TraceEvent _TRACE_PFLASH_IO_WRITE_EVENT;
extern TraceEvent _TRACE_PFLASH_MANUFACTURER_ID_EVENT;
extern TraceEvent _TRACE_PFLASH_MODE_READ_ARRAY_EVENT;
extern TraceEvent _TRACE_PFLASH_POSTLOAD_CB_EVENT;
extern TraceEvent _TRACE_PFLASH_READ_DONE_EVENT;
extern TraceEvent _TRACE_PFLASH_READ_STATUS_EVENT;
extern TraceEvent _TRACE_PFLASH_READ_UNKNOWN_STATE_EVENT;
extern TraceEvent _TRACE_PFLASH_RESET_EVENT;
extern TraceEvent _TRACE_PFLASH_SECTOR_ERASE_START_EVENT;
extern TraceEvent _TRACE_PFLASH_TIMER_EXPIRED_EVENT;
extern TraceEvent _TRACE_PFLASH_UNLOCK0_FAILED_EVENT;
extern TraceEvent _TRACE_PFLASH_UNLOCK1_FAILED_EVENT;
extern TraceEvent _TRACE_PFLASH_UNSUPPORTED_DEVICE_CONFIGURATION_EVENT;
extern TraceEvent _TRACE_PFLASH_WRITE_EVENT;
extern TraceEvent _TRACE_PFLASH_WRITE_BLOCK_EVENT;
extern TraceEvent _TRACE_PFLASH_WRITE_BLOCK_ERASE_EVENT;
extern TraceEvent _TRACE_PFLASH_WRITE_FAILED_EVENT;
extern TraceEvent _TRACE_PFLASH_WRITE_INVALID_EVENT;
extern TraceEvent _TRACE_PFLASH_WRITE_INVALID_COMMAND_EVENT;
extern TraceEvent _TRACE_PFLASH_WRITE_INVALID_STATE_EVENT;
extern TraceEvent _TRACE_PFLASH_WRITE_START_EVENT;
extern TraceEvent _TRACE_PFLASH_WRITE_UNKNOWN_EVENT;
extern TraceEvent _TRACE_VIRTIO_BLK_REQ_COMPLETE_EVENT;
extern TraceEvent _TRACE_VIRTIO_BLK_RW_COMPLETE_EVENT;
extern TraceEvent _TRACE_VIRTIO_BLK_HANDLE_WRITE_EVENT;
extern TraceEvent _TRACE_VIRTIO_BLK_HANDLE_READ_EVENT;
extern TraceEvent _TRACE_VIRTIO_BLK_SUBMIT_MULTIREQ_EVENT;
extern TraceEvent _TRACE_HD_GEOMETRY_LCHS_GUESS_EVENT;
extern TraceEvent _TRACE_HD_GEOMETRY_GUESS_EVENT;
extern TraceEvent _TRACE_XEN_BLOCK_REALIZE_EVENT;
extern TraceEvent _TRACE_XEN_BLOCK_CONNECT_EVENT;
extern TraceEvent _TRACE_XEN_BLOCK_DISCONNECT_EVENT;
extern TraceEvent _TRACE_XEN_BLOCK_UNREALIZE_EVENT;
extern TraceEvent _TRACE_XEN_BLOCK_SIZE_EVENT;
extern TraceEvent _TRACE_XEN_DISK_REALIZE_EVENT;
extern TraceEvent _TRACE_XEN_DISK_UNREALIZE_EVENT;
extern TraceEvent _TRACE_XEN_CDROM_REALIZE_EVENT;
extern TraceEvent _TRACE_XEN_CDROM_UNREALIZE_EVENT;
extern TraceEvent _TRACE_XEN_BLOCK_BLOCKDEV_ADD_EVENT;
extern TraceEvent _TRACE_XEN_BLOCK_BLOCKDEV_DEL_EVENT;
extern TraceEvent _TRACE_XEN_BLOCK_DEVICE_CREATE_EVENT;
extern TraceEvent _TRACE_XEN_BLOCK_DEVICE_DESTROY_EVENT;
extern TraceEvent _TRACE_M25P80_FLASH_ERASE_EVENT;
extern TraceEvent _TRACE_M25P80_PROGRAMMING_ZERO_TO_ONE_EVENT;
extern TraceEvent _TRACE_M25P80_RESET_DONE_EVENT;
extern TraceEvent _TRACE_M25P80_COMMAND_DECODED_EVENT;
extern TraceEvent _TRACE_M25P80_COMPLETE_COLLECTING_EVENT;
extern TraceEvent _TRACE_M25P80_POPULATED_JEDEC_EVENT;
extern TraceEvent _TRACE_M25P80_CHIP_ERASE_EVENT;
extern TraceEvent _TRACE_M25P80_SELECT_EVENT;
extern TraceEvent _TRACE_M25P80_PAGE_PROGRAM_EVENT;
extern TraceEvent _TRACE_M25P80_TRANSFER_EVENT;
extern TraceEvent _TRACE_M25P80_READ_BYTE_EVENT;
extern TraceEvent _TRACE_M25P80_READ_DATA_EVENT;
extern TraceEvent _TRACE_M25P80_BINDING_EVENT;
extern TraceEvent _TRACE_M25P80_BINDING_NO_BDRV_EVENT;
extern uint16_t _TRACE_FDC_IOPORT_READ_DSTATE;
extern uint16_t _TRACE_FDC_IOPORT_WRITE_DSTATE;
extern uint16_t _TRACE_FDCTRL_TC_PULSE_DSTATE;
extern uint16_t _TRACE_PFLASH_CHIP_ERASE_INVALID_DSTATE;
extern uint16_t _TRACE_PFLASH_CHIP_ERASE_START_DSTATE;
extern uint16_t _TRACE_PFLASH_DATA_READ_DSTATE;
extern uint16_t _TRACE_PFLASH_DATA_WRITE_DSTATE;
extern uint16_t _TRACE_PFLASH_DEVICE_ID_DSTATE;
extern uint16_t _TRACE_PFLASH_DEVICE_INFO_DSTATE;
extern uint16_t _TRACE_PFLASH_ERASE_COMPLETE_DSTATE;
extern uint16_t _TRACE_PFLASH_ERASE_TIMEOUT_DSTATE;
extern uint16_t _TRACE_PFLASH_IO_READ_DSTATE;
extern uint16_t _TRACE_PFLASH_IO_WRITE_DSTATE;
extern uint16_t _TRACE_PFLASH_MANUFACTURER_ID_DSTATE;
extern uint16_t _TRACE_PFLASH_MODE_READ_ARRAY_DSTATE;
extern uint16_t _TRACE_PFLASH_POSTLOAD_CB_DSTATE;
extern uint16_t _TRACE_PFLASH_READ_DONE_DSTATE;
extern uint16_t _TRACE_PFLASH_READ_STATUS_DSTATE;
extern uint16_t _TRACE_PFLASH_READ_UNKNOWN_STATE_DSTATE;
extern uint16_t _TRACE_PFLASH_RESET_DSTATE;
extern uint16_t _TRACE_PFLASH_SECTOR_ERASE_START_DSTATE;
extern uint16_t _TRACE_PFLASH_TIMER_EXPIRED_DSTATE;
extern uint16_t _TRACE_PFLASH_UNLOCK0_FAILED_DSTATE;
extern uint16_t _TRACE_PFLASH_UNLOCK1_FAILED_DSTATE;
extern uint16_t _TRACE_PFLASH_UNSUPPORTED_DEVICE_CONFIGURATION_DSTATE;
extern uint16_t _TRACE_PFLASH_WRITE_DSTATE;
extern uint16_t _TRACE_PFLASH_WRITE_BLOCK_DSTATE;
extern uint16_t _TRACE_PFLASH_WRITE_BLOCK_ERASE_DSTATE;
extern uint16_t _TRACE_PFLASH_WRITE_FAILED_DSTATE;
extern uint16_t _TRACE_PFLASH_WRITE_INVALID_DSTATE;
extern uint16_t _TRACE_PFLASH_WRITE_INVALID_COMMAND_DSTATE;
extern uint16_t _TRACE_PFLASH_WRITE_INVALID_STATE_DSTATE;
extern uint16_t _TRACE_PFLASH_WRITE_START_DSTATE;
extern uint16_t _TRACE_PFLASH_WRITE_UNKNOWN_DSTATE;
extern uint16_t _TRACE_VIRTIO_BLK_REQ_COMPLETE_DSTATE;
extern uint16_t _TRACE_VIRTIO_BLK_RW_COMPLETE_DSTATE;
extern uint16_t _TRACE_VIRTIO_BLK_HANDLE_WRITE_DSTATE;
extern uint16_t _TRACE_VIRTIO_BLK_HANDLE_READ_DSTATE;
extern uint16_t _TRACE_VIRTIO_BLK_SUBMIT_MULTIREQ_DSTATE;
extern uint16_t _TRACE_HD_GEOMETRY_LCHS_GUESS_DSTATE;
extern uint16_t _TRACE_HD_GEOMETRY_GUESS_DSTATE;
extern uint16_t _TRACE_XEN_BLOCK_REALIZE_DSTATE;
extern uint16_t _TRACE_XEN_BLOCK_CONNECT_DSTATE;
extern uint16_t _TRACE_XEN_BLOCK_DISCONNECT_DSTATE;
extern uint16_t _TRACE_XEN_BLOCK_UNREALIZE_DSTATE;
extern uint16_t _TRACE_XEN_BLOCK_SIZE_DSTATE;
extern uint16_t _TRACE_XEN_DISK_REALIZE_DSTATE;
extern uint16_t _TRACE_XEN_DISK_UNREALIZE_DSTATE;
extern uint16_t _TRACE_XEN_CDROM_REALIZE_DSTATE;
extern uint16_t _TRACE_XEN_CDROM_UNREALIZE_DSTATE;
extern uint16_t _TRACE_XEN_BLOCK_BLOCKDEV_ADD_DSTATE;
extern uint16_t _TRACE_XEN_BLOCK_BLOCKDEV_DEL_DSTATE;
extern uint16_t _TRACE_XEN_BLOCK_DEVICE_CREATE_DSTATE;
extern uint16_t _TRACE_XEN_BLOCK_DEVICE_DESTROY_DSTATE;
extern uint16_t _TRACE_M25P80_FLASH_ERASE_DSTATE;
extern uint16_t _TRACE_M25P80_PROGRAMMING_ZERO_TO_ONE_DSTATE;
extern uint16_t _TRACE_M25P80_RESET_DONE_DSTATE;
extern uint16_t _TRACE_M25P80_COMMAND_DECODED_DSTATE;
extern uint16_t _TRACE_M25P80_COMPLETE_COLLECTING_DSTATE;
extern uint16_t _TRACE_M25P80_POPULATED_JEDEC_DSTATE;
extern uint16_t _TRACE_M25P80_CHIP_ERASE_DSTATE;
extern uint16_t _TRACE_M25P80_SELECT_DSTATE;
extern uint16_t _TRACE_M25P80_PAGE_PROGRAM_DSTATE;
extern uint16_t _TRACE_M25P80_TRANSFER_DSTATE;
extern uint16_t _TRACE_M25P80_READ_BYTE_DSTATE;
extern uint16_t _TRACE_M25P80_READ_DATA_DSTATE;
extern uint16_t _TRACE_M25P80_BINDING_DSTATE;
extern uint16_t _TRACE_M25P80_BINDING_NO_BDRV_DSTATE;
#define TRACE_FDC_IOPORT_READ_ENABLED 1
#define TRACE_FDC_IOPORT_WRITE_ENABLED 1
#define TRACE_FDCTRL_TC_PULSE_ENABLED 1
#define TRACE_PFLASH_CHIP_ERASE_INVALID_ENABLED 1
#define TRACE_PFLASH_CHIP_ERASE_START_ENABLED 1
#define TRACE_PFLASH_DATA_READ_ENABLED 1
#define TRACE_PFLASH_DATA_WRITE_ENABLED 1
#define TRACE_PFLASH_DEVICE_ID_ENABLED 1
#define TRACE_PFLASH_DEVICE_INFO_ENABLED 1
#define TRACE_PFLASH_ERASE_COMPLETE_ENABLED 1
#define TRACE_PFLASH_ERASE_TIMEOUT_ENABLED 1
#define TRACE_PFLASH_IO_READ_ENABLED 1
#define TRACE_PFLASH_IO_WRITE_ENABLED 1
#define TRACE_PFLASH_MANUFACTURER_ID_ENABLED 1
#define TRACE_PFLASH_MODE_READ_ARRAY_ENABLED 1
#define TRACE_PFLASH_POSTLOAD_CB_ENABLED 1
#define TRACE_PFLASH_READ_DONE_ENABLED 1
#define TRACE_PFLASH_READ_STATUS_ENABLED 1
#define TRACE_PFLASH_READ_UNKNOWN_STATE_ENABLED 1
#define TRACE_PFLASH_RESET_ENABLED 1
#define TRACE_PFLASH_SECTOR_ERASE_START_ENABLED 1
#define TRACE_PFLASH_TIMER_EXPIRED_ENABLED 1
#define TRACE_PFLASH_UNLOCK0_FAILED_ENABLED 1
#define TRACE_PFLASH_UNLOCK1_FAILED_ENABLED 1
#define TRACE_PFLASH_UNSUPPORTED_DEVICE_CONFIGURATION_ENABLED 1
#define TRACE_PFLASH_WRITE_ENABLED 1
#define TRACE_PFLASH_WRITE_BLOCK_ENABLED 1
#define TRACE_PFLASH_WRITE_BLOCK_ERASE_ENABLED 1
#define TRACE_PFLASH_WRITE_FAILED_ENABLED 1
#define TRACE_PFLASH_WRITE_INVALID_ENABLED 1
#define TRACE_PFLASH_WRITE_INVALID_COMMAND_ENABLED 1
#define TRACE_PFLASH_WRITE_INVALID_STATE_ENABLED 1
#define TRACE_PFLASH_WRITE_START_ENABLED 1
#define TRACE_PFLASH_WRITE_UNKNOWN_ENABLED 1
#define TRACE_VIRTIO_BLK_REQ_COMPLETE_ENABLED 1
#define TRACE_VIRTIO_BLK_RW_COMPLETE_ENABLED 1
#define TRACE_VIRTIO_BLK_HANDLE_WRITE_ENABLED 1
#define TRACE_VIRTIO_BLK_HANDLE_READ_ENABLED 1
#define TRACE_VIRTIO_BLK_SUBMIT_MULTIREQ_ENABLED 1
#define TRACE_HD_GEOMETRY_LCHS_GUESS_ENABLED 1
#define TRACE_HD_GEOMETRY_GUESS_ENABLED 1
#define TRACE_XEN_BLOCK_REALIZE_ENABLED 1
#define TRACE_XEN_BLOCK_CONNECT_ENABLED 1
#define TRACE_XEN_BLOCK_DISCONNECT_ENABLED 1
#define TRACE_XEN_BLOCK_UNREALIZE_ENABLED 1
#define TRACE_XEN_BLOCK_SIZE_ENABLED 1
#define TRACE_XEN_DISK_REALIZE_ENABLED 1
#define TRACE_XEN_DISK_UNREALIZE_ENABLED 1
#define TRACE_XEN_CDROM_REALIZE_ENABLED 1
#define TRACE_XEN_CDROM_UNREALIZE_ENABLED 1
#define TRACE_XEN_BLOCK_BLOCKDEV_ADD_ENABLED 1
#define TRACE_XEN_BLOCK_BLOCKDEV_DEL_ENABLED 1
#define TRACE_XEN_BLOCK_DEVICE_CREATE_ENABLED 1
#define TRACE_XEN_BLOCK_DEVICE_DESTROY_ENABLED 1
#define TRACE_M25P80_FLASH_ERASE_ENABLED 1
#define TRACE_M25P80_PROGRAMMING_ZERO_TO_ONE_ENABLED 1
#define TRACE_M25P80_RESET_DONE_ENABLED 1
#define TRACE_M25P80_COMMAND_DECODED_ENABLED 1
#define TRACE_M25P80_COMPLETE_COLLECTING_ENABLED 1
#define TRACE_M25P80_POPULATED_JEDEC_ENABLED 1
#define TRACE_M25P80_CHIP_ERASE_ENABLED 1
#define TRACE_M25P80_SELECT_ENABLED 1
#define TRACE_M25P80_PAGE_PROGRAM_ENABLED 1
#define TRACE_M25P80_TRANSFER_ENABLED 1
#define TRACE_M25P80_READ_BYTE_ENABLED 1
#define TRACE_M25P80_READ_DATA_ENABLED 1
#define TRACE_M25P80_BINDING_ENABLED 1
#define TRACE_M25P80_BINDING_NO_BDRV_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_FDC_IOPORT_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_FDC_IOPORT_READ) || \
    false)

static inline void _nocheck__trace_fdc_ioport_read(uint8_t reg, uint8_t value)
{
    if (trace_event_get_state(TRACE_FDC_IOPORT_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 4 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:fdc_ioport_read " "read reg 0x%02x val 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reg, value);
#line 232 "trace/trace-hw_block.h"
        } else {
#line 4 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("fdc_ioport_read " "read reg 0x%02x val 0x%02x" "\n", reg, value);
#line 236 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_fdc_ioport_read(uint8_t reg, uint8_t value)
{
    if (true) {
        _nocheck__trace_fdc_ioport_read(reg, value);
    }
}

#define TRACE_FDC_IOPORT_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_FDC_IOPORT_WRITE) || \
    false)

static inline void _nocheck__trace_fdc_ioport_write(uint8_t reg, uint8_t value)
{
    if (trace_event_get_state(TRACE_FDC_IOPORT_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 5 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:fdc_ioport_write " "write reg 0x%02x val 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reg, value);
#line 263 "trace/trace-hw_block.h"
        } else {
#line 5 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("fdc_ioport_write " "write reg 0x%02x val 0x%02x" "\n", reg, value);
#line 267 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_fdc_ioport_write(uint8_t reg, uint8_t value)
{
    if (true) {
        _nocheck__trace_fdc_ioport_write(reg, value);
    }
}

#define TRACE_FDCTRL_TC_PULSE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_FDCTRL_TC_PULSE) || \
    false)

static inline void _nocheck__trace_fdctrl_tc_pulse(int level)
{
    if (trace_event_get_state(TRACE_FDCTRL_TC_PULSE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 8 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:fdctrl_tc_pulse " "TC pulse: %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , level);
#line 294 "trace/trace-hw_block.h"
        } else {
#line 8 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("fdctrl_tc_pulse " "TC pulse: %u" "\n", level);
#line 298 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_fdctrl_tc_pulse(int level)
{
    if (true) {
        _nocheck__trace_fdctrl_tc_pulse(level);
    }
}

#define TRACE_PFLASH_CHIP_ERASE_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_CHIP_ERASE_INVALID) || \
    false)

static inline void _nocheck__trace_pflash_chip_erase_invalid(const char * name, uint64_t offset)
{
    if (trace_event_get_state(TRACE_PFLASH_CHIP_ERASE_INVALID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 12 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_chip_erase_invalid " "%s: chip erase: invalid address 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset);
#line 325 "trace/trace-hw_block.h"
        } else {
#line 12 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("pflash_chip_erase_invalid " "%s: chip erase: invalid address 0x%" PRIx64 "\n", name, offset);
#line 329 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_chip_erase_invalid(const char * name, uint64_t offset)
{
    if (true) {
        _nocheck__trace_pflash_chip_erase_invalid(name, offset);
    }
}

#define TRACE_PFLASH_CHIP_ERASE_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_CHIP_ERASE_START) || \
    false)

static inline void _nocheck__trace_pflash_chip_erase_start(const char * name)
{
    if (trace_event_get_state(TRACE_PFLASH_CHIP_ERASE_START) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 13 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_chip_erase_start " "%s: start chip erase" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 356 "trace/trace-hw_block.h"
        } else {
#line 13 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("pflash_chip_erase_start " "%s: start chip erase" "\n", name);
#line 360 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_chip_erase_start(const char * name)
{
    if (true) {
        _nocheck__trace_pflash_chip_erase_start(name);
    }
}

#define TRACE_PFLASH_DATA_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_DATA_READ) || \
    false)

static inline void _nocheck__trace_pflash_data_read(const char * name, uint64_t offset, unsigned size, uint32_t value)
{
    if (trace_event_get_state(TRACE_PFLASH_DATA_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 14 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_data_read " "%s: data offset:0x%04"PRIx64" size:%u value:0x%04x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset, size, value);
#line 387 "trace/trace-hw_block.h"
        } else {
#line 14 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("pflash_data_read " "%s: data offset:0x%04"PRIx64" size:%u value:0x%04x" "\n", name, offset, size, value);
#line 391 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_data_read(const char * name, uint64_t offset, unsigned size, uint32_t value)
{
    if (true) {
        _nocheck__trace_pflash_data_read(name, offset, size, value);
    }
}

#define TRACE_PFLASH_DATA_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_DATA_WRITE) || \
    false)

static inline void _nocheck__trace_pflash_data_write(const char * name, uint64_t offset, unsigned size, uint32_t value, uint64_t counter)
{
    if (trace_event_get_state(TRACE_PFLASH_DATA_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 15 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_data_write " "%s: data offset:0x%04"PRIx64" size:%u value:0x%04x counter:0x%016"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset, size, value, counter);
#line 418 "trace/trace-hw_block.h"
        } else {
#line 15 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("pflash_data_write " "%s: data offset:0x%04"PRIx64" size:%u value:0x%04x counter:0x%016"PRIx64 "\n", name, offset, size, value, counter);
#line 422 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_data_write(const char * name, uint64_t offset, unsigned size, uint32_t value, uint64_t counter)
{
    if (true) {
        _nocheck__trace_pflash_data_write(name, offset, size, value, counter);
    }
}

#define TRACE_PFLASH_DEVICE_ID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_DEVICE_ID) || \
    false)

static inline void _nocheck__trace_pflash_device_id(const char * name, uint16_t id)
{
    if (trace_event_get_state(TRACE_PFLASH_DEVICE_ID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 16 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_device_id " "%s: read device ID: 0x%04x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, id);
#line 449 "trace/trace-hw_block.h"
        } else {
#line 16 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("pflash_device_id " "%s: read device ID: 0x%04x" "\n", name, id);
#line 453 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_device_id(const char * name, uint16_t id)
{
    if (true) {
        _nocheck__trace_pflash_device_id(name, id);
    }
}

#define TRACE_PFLASH_DEVICE_INFO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_DEVICE_INFO) || \
    false)

static inline void _nocheck__trace_pflash_device_info(const char * name, uint64_t offset)
{
    if (trace_event_get_state(TRACE_PFLASH_DEVICE_INFO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 17 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_device_info " "%s: read device information offset:0x%04" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset);
#line 480 "trace/trace-hw_block.h"
        } else {
#line 17 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("pflash_device_info " "%s: read device information offset:0x%04" PRIx64 "\n", name, offset);
#line 484 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_device_info(const char * name, uint64_t offset)
{
    if (true) {
        _nocheck__trace_pflash_device_info(name, offset);
    }
}

#define TRACE_PFLASH_ERASE_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_ERASE_COMPLETE) || \
    false)

static inline void _nocheck__trace_pflash_erase_complete(const char * name)
{
    if (trace_event_get_state(TRACE_PFLASH_ERASE_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 18 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_erase_complete " "%s: sector erase complete" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 511 "trace/trace-hw_block.h"
        } else {
#line 18 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("pflash_erase_complete " "%s: sector erase complete" "\n", name);
#line 515 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_erase_complete(const char * name)
{
    if (true) {
        _nocheck__trace_pflash_erase_complete(name);
    }
}

#define TRACE_PFLASH_ERASE_TIMEOUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_ERASE_TIMEOUT) || \
    false)

static inline void _nocheck__trace_pflash_erase_timeout(const char * name, int count)
{
    if (trace_event_get_state(TRACE_PFLASH_ERASE_TIMEOUT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 19 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_erase_timeout " "%s: erase timeout fired; erasing %d sectors" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, count);
#line 542 "trace/trace-hw_block.h"
        } else {
#line 19 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("pflash_erase_timeout " "%s: erase timeout fired; erasing %d sectors" "\n", name, count);
#line 546 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_erase_timeout(const char * name, int count)
{
    if (true) {
        _nocheck__trace_pflash_erase_timeout(name, count);
    }
}

#define TRACE_PFLASH_IO_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_IO_READ) || \
    false)

static inline void _nocheck__trace_pflash_io_read(const char * name, uint64_t offset, unsigned int size, uint32_t value, uint8_t cmd, uint8_t wcycle)
{
    if (trace_event_get_state(TRACE_PFLASH_IO_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 20 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_io_read " "%s: offset:0x%04" PRIx64 " size:%u value:0x%04x cmd:0x%02x wcycle:%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset, size, value, cmd, wcycle);
#line 573 "trace/trace-hw_block.h"
        } else {
#line 20 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("pflash_io_read " "%s: offset:0x%04" PRIx64 " size:%u value:0x%04x cmd:0x%02x wcycle:%u" "\n", name, offset, size, value, cmd, wcycle);
#line 577 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_io_read(const char * name, uint64_t offset, unsigned int size, uint32_t value, uint8_t cmd, uint8_t wcycle)
{
    if (true) {
        _nocheck__trace_pflash_io_read(name, offset, size, value, cmd, wcycle);
    }
}

#define TRACE_PFLASH_IO_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_IO_WRITE) || \
    false)

static inline void _nocheck__trace_pflash_io_write(const char * name, uint64_t offset, unsigned int size, uint32_t value, uint8_t wcycle)
{
    if (trace_event_get_state(TRACE_PFLASH_IO_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 21 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_io_write " "%s: offset:0x%04"PRIx64" size:%u value:0x%04x wcycle:%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset, size, value, wcycle);
#line 604 "trace/trace-hw_block.h"
        } else {
#line 21 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("pflash_io_write " "%s: offset:0x%04"PRIx64" size:%u value:0x%04x wcycle:%u" "\n", name, offset, size, value, wcycle);
#line 608 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_io_write(const char * name, uint64_t offset, unsigned int size, uint32_t value, uint8_t wcycle)
{
    if (true) {
        _nocheck__trace_pflash_io_write(name, offset, size, value, wcycle);
    }
}

#define TRACE_PFLASH_MANUFACTURER_ID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_MANUFACTURER_ID) || \
    false)

static inline void _nocheck__trace_pflash_manufacturer_id(const char * name, uint16_t id)
{
    if (trace_event_get_state(TRACE_PFLASH_MANUFACTURER_ID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 22 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_manufacturer_id " "%s: read manufacturer ID: 0x%04x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, id);
#line 635 "trace/trace-hw_block.h"
        } else {
#line 22 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("pflash_manufacturer_id " "%s: read manufacturer ID: 0x%04x" "\n", name, id);
#line 639 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_manufacturer_id(const char * name, uint16_t id)
{
    if (true) {
        _nocheck__trace_pflash_manufacturer_id(name, id);
    }
}

#define TRACE_PFLASH_MODE_READ_ARRAY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_MODE_READ_ARRAY) || \
    false)

static inline void _nocheck__trace_pflash_mode_read_array(const char * name)
{
    if (trace_event_get_state(TRACE_PFLASH_MODE_READ_ARRAY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 23 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_mode_read_array " "%s: read array mode" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 666 "trace/trace-hw_block.h"
        } else {
#line 23 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("pflash_mode_read_array " "%s: read array mode" "\n", name);
#line 670 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_mode_read_array(const char * name)
{
    if (true) {
        _nocheck__trace_pflash_mode_read_array(name);
    }
}

#define TRACE_PFLASH_POSTLOAD_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_POSTLOAD_CB) || \
    false)

static inline void _nocheck__trace_pflash_postload_cb(const char * name)
{
    if (trace_event_get_state(TRACE_PFLASH_POSTLOAD_CB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 24 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_postload_cb " "%s: updating bdrv" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 697 "trace/trace-hw_block.h"
        } else {
#line 24 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("pflash_postload_cb " "%s: updating bdrv" "\n", name);
#line 701 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_postload_cb(const char * name)
{
    if (true) {
        _nocheck__trace_pflash_postload_cb(name);
    }
}

#define TRACE_PFLASH_READ_DONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_READ_DONE) || \
    false)

static inline void _nocheck__trace_pflash_read_done(const char * name, uint64_t offset, uint64_t ret)
{
    if (trace_event_get_state(TRACE_PFLASH_READ_DONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 25 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_read_done " "%s: ID:0x%" PRIx64 " ret:0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset, ret);
#line 728 "trace/trace-hw_block.h"
        } else {
#line 25 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("pflash_read_done " "%s: ID:0x%" PRIx64 " ret:0x%" PRIx64 "\n", name, offset, ret);
#line 732 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_read_done(const char * name, uint64_t offset, uint64_t ret)
{
    if (true) {
        _nocheck__trace_pflash_read_done(name, offset, ret);
    }
}

#define TRACE_PFLASH_READ_STATUS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_READ_STATUS) || \
    false)

static inline void _nocheck__trace_pflash_read_status(const char * name, uint32_t ret)
{
    if (trace_event_get_state(TRACE_PFLASH_READ_STATUS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 26 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_read_status " "%s: status:0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, ret);
#line 759 "trace/trace-hw_block.h"
        } else {
#line 26 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("pflash_read_status " "%s: status:0x%x" "\n", name, ret);
#line 763 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_read_status(const char * name, uint32_t ret)
{
    if (true) {
        _nocheck__trace_pflash_read_status(name, ret);
    }
}

#define TRACE_PFLASH_READ_UNKNOWN_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_READ_UNKNOWN_STATE) || \
    false)

static inline void _nocheck__trace_pflash_read_unknown_state(const char * name, uint8_t cmd)
{
    if (trace_event_get_state(TRACE_PFLASH_READ_UNKNOWN_STATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 27 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_read_unknown_state " "%s: unknown command state:0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, cmd);
#line 790 "trace/trace-hw_block.h"
        } else {
#line 27 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("pflash_read_unknown_state " "%s: unknown command state:0x%x" "\n", name, cmd);
#line 794 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_read_unknown_state(const char * name, uint8_t cmd)
{
    if (true) {
        _nocheck__trace_pflash_read_unknown_state(name, cmd);
    }
}

#define TRACE_PFLASH_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_RESET) || \
    false)

static inline void _nocheck__trace_pflash_reset(const char * name)
{
    if (trace_event_get_state(TRACE_PFLASH_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 28 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_reset " "%s: reset" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 821 "trace/trace-hw_block.h"
        } else {
#line 28 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("pflash_reset " "%s: reset" "\n", name);
#line 825 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_reset(const char * name)
{
    if (true) {
        _nocheck__trace_pflash_reset(name);
    }
}

#define TRACE_PFLASH_SECTOR_ERASE_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_SECTOR_ERASE_START) || \
    false)

static inline void _nocheck__trace_pflash_sector_erase_start(const char * name, int width1, uint64_t start, int width2, uint64_t end)
{
    if (trace_event_get_state(TRACE_PFLASH_SECTOR_ERASE_START) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 29 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_sector_erase_start " "%s: start sector erase at: 0x%0*" PRIx64 "-0x%0*" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, width1, start, width2, end);
#line 852 "trace/trace-hw_block.h"
        } else {
#line 29 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("pflash_sector_erase_start " "%s: start sector erase at: 0x%0*" PRIx64 "-0x%0*" PRIx64 "\n", name, width1, start, width2, end);
#line 856 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_sector_erase_start(const char * name, int width1, uint64_t start, int width2, uint64_t end)
{
    if (true) {
        _nocheck__trace_pflash_sector_erase_start(name, width1, start, width2, end);
    }
}

#define TRACE_PFLASH_TIMER_EXPIRED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_TIMER_EXPIRED) || \
    false)

static inline void _nocheck__trace_pflash_timer_expired(const char * name, uint8_t cmd)
{
    if (trace_event_get_state(TRACE_PFLASH_TIMER_EXPIRED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 30 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_timer_expired " "%s: command 0x%02x done" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, cmd);
#line 883 "trace/trace-hw_block.h"
        } else {
#line 30 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("pflash_timer_expired " "%s: command 0x%02x done" "\n", name, cmd);
#line 887 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_timer_expired(const char * name, uint8_t cmd)
{
    if (true) {
        _nocheck__trace_pflash_timer_expired(name, cmd);
    }
}

#define TRACE_PFLASH_UNLOCK0_FAILED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_UNLOCK0_FAILED) || \
    false)

static inline void _nocheck__trace_pflash_unlock0_failed(const char * name, uint64_t offset, uint8_t cmd, uint16_t addr0)
{
    if (trace_event_get_state(TRACE_PFLASH_UNLOCK0_FAILED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 31 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_unlock0_failed " "%s: unlock0 failed 0x%" PRIx64 " 0x%02x 0x%04x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset, cmd, addr0);
#line 914 "trace/trace-hw_block.h"
        } else {
#line 31 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("pflash_unlock0_failed " "%s: unlock0 failed 0x%" PRIx64 " 0x%02x 0x%04x" "\n", name, offset, cmd, addr0);
#line 918 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_unlock0_failed(const char * name, uint64_t offset, uint8_t cmd, uint16_t addr0)
{
    if (true) {
        _nocheck__trace_pflash_unlock0_failed(name, offset, cmd, addr0);
    }
}

#define TRACE_PFLASH_UNLOCK1_FAILED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_UNLOCK1_FAILED) || \
    false)

static inline void _nocheck__trace_pflash_unlock1_failed(const char * name, uint64_t offset, uint8_t cmd)
{
    if (trace_event_get_state(TRACE_PFLASH_UNLOCK1_FAILED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 32 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_unlock1_failed " "%s: unlock0 failed 0x%" PRIx64 " 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset, cmd);
#line 945 "trace/trace-hw_block.h"
        } else {
#line 32 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("pflash_unlock1_failed " "%s: unlock0 failed 0x%" PRIx64 " 0x%02x" "\n", name, offset, cmd);
#line 949 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_unlock1_failed(const char * name, uint64_t offset, uint8_t cmd)
{
    if (true) {
        _nocheck__trace_pflash_unlock1_failed(name, offset, cmd);
    }
}

#define TRACE_PFLASH_UNSUPPORTED_DEVICE_CONFIGURATION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_UNSUPPORTED_DEVICE_CONFIGURATION) || \
    false)

static inline void _nocheck__trace_pflash_unsupported_device_configuration(const char * name, uint8_t width, uint8_t max)
{
    if (trace_event_get_state(TRACE_PFLASH_UNSUPPORTED_DEVICE_CONFIGURATION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 33 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_unsupported_device_configuration " "%s: unsupported device configuration: device_width:%d max_device_width:%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, width, max);
#line 976 "trace/trace-hw_block.h"
        } else {
#line 33 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("pflash_unsupported_device_configuration " "%s: unsupported device configuration: device_width:%d max_device_width:%d" "\n", name, width, max);
#line 980 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_unsupported_device_configuration(const char * name, uint8_t width, uint8_t max)
{
    if (true) {
        _nocheck__trace_pflash_unsupported_device_configuration(name, width, max);
    }
}

#define TRACE_PFLASH_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_WRITE) || \
    false)

static inline void _nocheck__trace_pflash_write(const char * name, const char * str)
{
    if (trace_event_get_state(TRACE_PFLASH_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 34 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_write " "%s: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, str);
#line 1007 "trace/trace-hw_block.h"
        } else {
#line 34 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("pflash_write " "%s: %s" "\n", name, str);
#line 1011 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_write(const char * name, const char * str)
{
    if (true) {
        _nocheck__trace_pflash_write(name, str);
    }
}

#define TRACE_PFLASH_WRITE_BLOCK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_WRITE_BLOCK) || \
    false)

static inline void _nocheck__trace_pflash_write_block(const char * name, uint32_t value)
{
    if (trace_event_get_state(TRACE_PFLASH_WRITE_BLOCK) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 35 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_write_block " "%s: block write: bytes:0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, value);
#line 1038 "trace/trace-hw_block.h"
        } else {
#line 35 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("pflash_write_block " "%s: block write: bytes:0x%x" "\n", name, value);
#line 1042 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_write_block(const char * name, uint32_t value)
{
    if (true) {
        _nocheck__trace_pflash_write_block(name, value);
    }
}

#define TRACE_PFLASH_WRITE_BLOCK_ERASE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_WRITE_BLOCK_ERASE) || \
    false)

static inline void _nocheck__trace_pflash_write_block_erase(const char * name, uint64_t offset, uint64_t len)
{
    if (trace_event_get_state(TRACE_PFLASH_WRITE_BLOCK_ERASE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 36 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_write_block_erase " "%s: block erase offset:0x%" PRIx64 " bytes:0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset, len);
#line 1069 "trace/trace-hw_block.h"
        } else {
#line 36 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("pflash_write_block_erase " "%s: block erase offset:0x%" PRIx64 " bytes:0x%" PRIx64 "\n", name, offset, len);
#line 1073 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_write_block_erase(const char * name, uint64_t offset, uint64_t len)
{
    if (true) {
        _nocheck__trace_pflash_write_block_erase(name, offset, len);
    }
}

#define TRACE_PFLASH_WRITE_FAILED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_WRITE_FAILED) || \
    false)

static inline void _nocheck__trace_pflash_write_failed(const char * name, uint64_t offset, uint8_t cmd)
{
    if (trace_event_get_state(TRACE_PFLASH_WRITE_FAILED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 37 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_write_failed " "%s: command failed 0x%" PRIx64 " 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset, cmd);
#line 1100 "trace/trace-hw_block.h"
        } else {
#line 37 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("pflash_write_failed " "%s: command failed 0x%" PRIx64 " 0x%02x" "\n", name, offset, cmd);
#line 1104 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_write_failed(const char * name, uint64_t offset, uint8_t cmd)
{
    if (true) {
        _nocheck__trace_pflash_write_failed(name, offset, cmd);
    }
}

#define TRACE_PFLASH_WRITE_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_WRITE_INVALID) || \
    false)

static inline void _nocheck__trace_pflash_write_invalid(const char * name, uint8_t cmd)
{
    if (trace_event_get_state(TRACE_PFLASH_WRITE_INVALID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 38 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_write_invalid " "%s: invalid write for command 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, cmd);
#line 1131 "trace/trace-hw_block.h"
        } else {
#line 38 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("pflash_write_invalid " "%s: invalid write for command 0x%02x" "\n", name, cmd);
#line 1135 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_write_invalid(const char * name, uint8_t cmd)
{
    if (true) {
        _nocheck__trace_pflash_write_invalid(name, cmd);
    }
}

#define TRACE_PFLASH_WRITE_INVALID_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_WRITE_INVALID_COMMAND) || \
    false)

static inline void _nocheck__trace_pflash_write_invalid_command(const char * name, uint8_t cmd)
{
    if (trace_event_get_state(TRACE_PFLASH_WRITE_INVALID_COMMAND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 39 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_write_invalid_command " "%s: invalid command 0x%02x (wc 5)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, cmd);
#line 1162 "trace/trace-hw_block.h"
        } else {
#line 39 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("pflash_write_invalid_command " "%s: invalid command 0x%02x (wc 5)" "\n", name, cmd);
#line 1166 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_write_invalid_command(const char * name, uint8_t cmd)
{
    if (true) {
        _nocheck__trace_pflash_write_invalid_command(name, cmd);
    }
}

#define TRACE_PFLASH_WRITE_INVALID_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_WRITE_INVALID_STATE) || \
    false)

static inline void _nocheck__trace_pflash_write_invalid_state(const char * name, uint8_t cmd, int wc)
{
    if (trace_event_get_state(TRACE_PFLASH_WRITE_INVALID_STATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 40 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_write_invalid_state " "%s: invalid command state 0x%02x (wc %d)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, cmd, wc);
#line 1193 "trace/trace-hw_block.h"
        } else {
#line 40 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("pflash_write_invalid_state " "%s: invalid command state 0x%02x (wc %d)" "\n", name, cmd, wc);
#line 1197 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_write_invalid_state(const char * name, uint8_t cmd, int wc)
{
    if (true) {
        _nocheck__trace_pflash_write_invalid_state(name, cmd, wc);
    }
}

#define TRACE_PFLASH_WRITE_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_WRITE_START) || \
    false)

static inline void _nocheck__trace_pflash_write_start(const char * name, uint8_t cmd)
{
    if (trace_event_get_state(TRACE_PFLASH_WRITE_START) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 41 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_write_start " "%s: starting command 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, cmd);
#line 1224 "trace/trace-hw_block.h"
        } else {
#line 41 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("pflash_write_start " "%s: starting command 0x%02x" "\n", name, cmd);
#line 1228 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_write_start(const char * name, uint8_t cmd)
{
    if (true) {
        _nocheck__trace_pflash_write_start(name, cmd);
    }
}

#define TRACE_PFLASH_WRITE_UNKNOWN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_WRITE_UNKNOWN) || \
    false)

static inline void _nocheck__trace_pflash_write_unknown(const char * name, uint8_t cmd)
{
    if (trace_event_get_state(TRACE_PFLASH_WRITE_UNKNOWN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 42 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_write_unknown " "%s: unknown command 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, cmd);
#line 1255 "trace/trace-hw_block.h"
        } else {
#line 42 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("pflash_write_unknown " "%s: unknown command 0x%02x" "\n", name, cmd);
#line 1259 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_write_unknown(const char * name, uint8_t cmd)
{
    if (true) {
        _nocheck__trace_pflash_write_unknown(name, cmd);
    }
}

#define TRACE_VIRTIO_BLK_REQ_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BLK_REQ_COMPLETE) || \
    false)

static inline void _nocheck__trace_virtio_blk_req_complete(void * vdev, void * req, int status)
{
    if (trace_event_get_state(TRACE_VIRTIO_BLK_REQ_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 45 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_blk_req_complete " "vdev %p req %p status %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vdev, req, status);
#line 1286 "trace/trace-hw_block.h"
        } else {
#line 45 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("virtio_blk_req_complete " "vdev %p req %p status %d" "\n", vdev, req, status);
#line 1290 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_virtio_blk_req_complete(void * vdev, void * req, int status)
{
    if (true) {
        _nocheck__trace_virtio_blk_req_complete(vdev, req, status);
    }
}

#define TRACE_VIRTIO_BLK_RW_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BLK_RW_COMPLETE) || \
    false)

static inline void _nocheck__trace_virtio_blk_rw_complete(void * vdev, void * req, int ret)
{
    if (trace_event_get_state(TRACE_VIRTIO_BLK_RW_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 46 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_blk_rw_complete " "vdev %p req %p ret %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vdev, req, ret);
#line 1317 "trace/trace-hw_block.h"
        } else {
#line 46 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("virtio_blk_rw_complete " "vdev %p req %p ret %d" "\n", vdev, req, ret);
#line 1321 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_virtio_blk_rw_complete(void * vdev, void * req, int ret)
{
    if (true) {
        _nocheck__trace_virtio_blk_rw_complete(vdev, req, ret);
    }
}

#define TRACE_VIRTIO_BLK_HANDLE_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BLK_HANDLE_WRITE) || \
    false)

static inline void _nocheck__trace_virtio_blk_handle_write(void * vdev, void * req, uint64_t sector, size_t nsectors)
{
    if (trace_event_get_state(TRACE_VIRTIO_BLK_HANDLE_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 47 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_blk_handle_write " "vdev %p req %p sector %"PRIu64" nsectors %zu" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vdev, req, sector, nsectors);
#line 1348 "trace/trace-hw_block.h"
        } else {
#line 47 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("virtio_blk_handle_write " "vdev %p req %p sector %"PRIu64" nsectors %zu" "\n", vdev, req, sector, nsectors);
#line 1352 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_virtio_blk_handle_write(void * vdev, void * req, uint64_t sector, size_t nsectors)
{
    if (true) {
        _nocheck__trace_virtio_blk_handle_write(vdev, req, sector, nsectors);
    }
}

#define TRACE_VIRTIO_BLK_HANDLE_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BLK_HANDLE_READ) || \
    false)

static inline void _nocheck__trace_virtio_blk_handle_read(void * vdev, void * req, uint64_t sector, size_t nsectors)
{
    if (trace_event_get_state(TRACE_VIRTIO_BLK_HANDLE_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 48 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_blk_handle_read " "vdev %p req %p sector %"PRIu64" nsectors %zu" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vdev, req, sector, nsectors);
#line 1379 "trace/trace-hw_block.h"
        } else {
#line 48 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("virtio_blk_handle_read " "vdev %p req %p sector %"PRIu64" nsectors %zu" "\n", vdev, req, sector, nsectors);
#line 1383 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_virtio_blk_handle_read(void * vdev, void * req, uint64_t sector, size_t nsectors)
{
    if (true) {
        _nocheck__trace_virtio_blk_handle_read(vdev, req, sector, nsectors);
    }
}

#define TRACE_VIRTIO_BLK_SUBMIT_MULTIREQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BLK_SUBMIT_MULTIREQ) || \
    false)

static inline void _nocheck__trace_virtio_blk_submit_multireq(void * vdev, void * mrb, int start, int num_reqs, uint64_t offset, size_t size, bool is_write)
{
    if (trace_event_get_state(TRACE_VIRTIO_BLK_SUBMIT_MULTIREQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 49 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_blk_submit_multireq " "vdev %p mrb %p start %d num_reqs %d offset %"PRIu64" size %zu is_write %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vdev, mrb, start, num_reqs, offset, size, is_write);
#line 1410 "trace/trace-hw_block.h"
        } else {
#line 49 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("virtio_blk_submit_multireq " "vdev %p mrb %p start %d num_reqs %d offset %"PRIu64" size %zu is_write %d" "\n", vdev, mrb, start, num_reqs, offset, size, is_write);
#line 1414 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_virtio_blk_submit_multireq(void * vdev, void * mrb, int start, int num_reqs, uint64_t offset, size_t size, bool is_write)
{
    if (true) {
        _nocheck__trace_virtio_blk_submit_multireq(vdev, mrb, start, num_reqs, offset, size, is_write);
    }
}

#define TRACE_HD_GEOMETRY_LCHS_GUESS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HD_GEOMETRY_LCHS_GUESS) || \
    false)

static inline void _nocheck__trace_hd_geometry_lchs_guess(void * blk, int cyls, int heads, int secs)
{
    if (trace_event_get_state(TRACE_HD_GEOMETRY_LCHS_GUESS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 52 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:hd_geometry_lchs_guess " "blk %p LCHS %d %d %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , blk, cyls, heads, secs);
#line 1441 "trace/trace-hw_block.h"
        } else {
#line 52 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("hd_geometry_lchs_guess " "blk %p LCHS %d %d %d" "\n", blk, cyls, heads, secs);
#line 1445 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_hd_geometry_lchs_guess(void * blk, int cyls, int heads, int secs)
{
    if (true) {
        _nocheck__trace_hd_geometry_lchs_guess(blk, cyls, heads, secs);
    }
}

#define TRACE_HD_GEOMETRY_GUESS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HD_GEOMETRY_GUESS) || \
    false)

static inline void _nocheck__trace_hd_geometry_guess(void * blk, uint32_t cyls, uint32_t heads, uint32_t secs, int trans)
{
    if (trace_event_get_state(TRACE_HD_GEOMETRY_GUESS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 53 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:hd_geometry_guess " "blk %p CHS %u %u %u trans %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , blk, cyls, heads, secs, trans);
#line 1472 "trace/trace-hw_block.h"
        } else {
#line 53 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("hd_geometry_guess " "blk %p CHS %u %u %u trans %d" "\n", blk, cyls, heads, secs, trans);
#line 1476 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_hd_geometry_guess(void * blk, uint32_t cyls, uint32_t heads, uint32_t secs, int trans)
{
    if (true) {
        _nocheck__trace_hd_geometry_guess(blk, cyls, heads, secs, trans);
    }
}

#define TRACE_XEN_BLOCK_REALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BLOCK_REALIZE) || \
    false)

static inline void _nocheck__trace_xen_block_realize(const char * type, uint32_t disk, uint32_t partition)
{
    if (trace_event_get_state(TRACE_XEN_BLOCK_REALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 56 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_block_realize " "%s d%up%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, disk, partition);
#line 1503 "trace/trace-hw_block.h"
        } else {
#line 56 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("xen_block_realize " "%s d%up%u" "\n", type, disk, partition);
#line 1507 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_block_realize(const char * type, uint32_t disk, uint32_t partition)
{
    if (true) {
        _nocheck__trace_xen_block_realize(type, disk, partition);
    }
}

#define TRACE_XEN_BLOCK_CONNECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BLOCK_CONNECT) || \
    false)

static inline void _nocheck__trace_xen_block_connect(const char * type, uint32_t disk, uint32_t partition)
{
    if (trace_event_get_state(TRACE_XEN_BLOCK_CONNECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 57 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_block_connect " "%s d%up%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, disk, partition);
#line 1534 "trace/trace-hw_block.h"
        } else {
#line 57 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("xen_block_connect " "%s d%up%u" "\n", type, disk, partition);
#line 1538 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_block_connect(const char * type, uint32_t disk, uint32_t partition)
{
    if (true) {
        _nocheck__trace_xen_block_connect(type, disk, partition);
    }
}

#define TRACE_XEN_BLOCK_DISCONNECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BLOCK_DISCONNECT) || \
    false)

static inline void _nocheck__trace_xen_block_disconnect(const char * type, uint32_t disk, uint32_t partition)
{
    if (trace_event_get_state(TRACE_XEN_BLOCK_DISCONNECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 58 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_block_disconnect " "%s d%up%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, disk, partition);
#line 1565 "trace/trace-hw_block.h"
        } else {
#line 58 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("xen_block_disconnect " "%s d%up%u" "\n", type, disk, partition);
#line 1569 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_block_disconnect(const char * type, uint32_t disk, uint32_t partition)
{
    if (true) {
        _nocheck__trace_xen_block_disconnect(type, disk, partition);
    }
}

#define TRACE_XEN_BLOCK_UNREALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BLOCK_UNREALIZE) || \
    false)

static inline void _nocheck__trace_xen_block_unrealize(const char * type, uint32_t disk, uint32_t partition)
{
    if (trace_event_get_state(TRACE_XEN_BLOCK_UNREALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 59 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_block_unrealize " "%s d%up%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, disk, partition);
#line 1596 "trace/trace-hw_block.h"
        } else {
#line 59 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("xen_block_unrealize " "%s d%up%u" "\n", type, disk, partition);
#line 1600 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_block_unrealize(const char * type, uint32_t disk, uint32_t partition)
{
    if (true) {
        _nocheck__trace_xen_block_unrealize(type, disk, partition);
    }
}

#define TRACE_XEN_BLOCK_SIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BLOCK_SIZE) || \
    false)

static inline void _nocheck__trace_xen_block_size(const char * type, uint32_t disk, uint32_t partition, int64_t sectors)
{
    if (trace_event_get_state(TRACE_XEN_BLOCK_SIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 60 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_block_size " "%s d%up%u %"PRIi64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, disk, partition, sectors);
#line 1627 "trace/trace-hw_block.h"
        } else {
#line 60 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("xen_block_size " "%s d%up%u %"PRIi64 "\n", type, disk, partition, sectors);
#line 1631 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_block_size(const char * type, uint32_t disk, uint32_t partition, int64_t sectors)
{
    if (true) {
        _nocheck__trace_xen_block_size(type, disk, partition, sectors);
    }
}

#define TRACE_XEN_DISK_REALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DISK_REALIZE) || \
    false)

static inline void _nocheck__trace_xen_disk_realize(void)
{
    if (trace_event_get_state(TRACE_XEN_DISK_REALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 61 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_disk_realize " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1658 "trace/trace-hw_block.h"
        } else {
#line 61 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("xen_disk_realize " "" "\n");
#line 1662 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_disk_realize(void)
{
    if (true) {
        _nocheck__trace_xen_disk_realize();
    }
}

#define TRACE_XEN_DISK_UNREALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DISK_UNREALIZE) || \
    false)

static inline void _nocheck__trace_xen_disk_unrealize(void)
{
    if (trace_event_get_state(TRACE_XEN_DISK_UNREALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 62 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_disk_unrealize " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1689 "trace/trace-hw_block.h"
        } else {
#line 62 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("xen_disk_unrealize " "" "\n");
#line 1693 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_disk_unrealize(void)
{
    if (true) {
        _nocheck__trace_xen_disk_unrealize();
    }
}

#define TRACE_XEN_CDROM_REALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_CDROM_REALIZE) || \
    false)

static inline void _nocheck__trace_xen_cdrom_realize(void)
{
    if (trace_event_get_state(TRACE_XEN_CDROM_REALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 63 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_cdrom_realize " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1720 "trace/trace-hw_block.h"
        } else {
#line 63 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("xen_cdrom_realize " "" "\n");
#line 1724 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_cdrom_realize(void)
{
    if (true) {
        _nocheck__trace_xen_cdrom_realize();
    }
}

#define TRACE_XEN_CDROM_UNREALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_CDROM_UNREALIZE) || \
    false)

static inline void _nocheck__trace_xen_cdrom_unrealize(void)
{
    if (trace_event_get_state(TRACE_XEN_CDROM_UNREALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 64 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_cdrom_unrealize " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1751 "trace/trace-hw_block.h"
        } else {
#line 64 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("xen_cdrom_unrealize " "" "\n");
#line 1755 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_cdrom_unrealize(void)
{
    if (true) {
        _nocheck__trace_xen_cdrom_unrealize();
    }
}

#define TRACE_XEN_BLOCK_BLOCKDEV_ADD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BLOCK_BLOCKDEV_ADD) || \
    false)

static inline void _nocheck__trace_xen_block_blockdev_add(char * str)
{
    if (trace_event_get_state(TRACE_XEN_BLOCK_BLOCKDEV_ADD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 65 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_block_blockdev_add " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , str);
#line 1782 "trace/trace-hw_block.h"
        } else {
#line 65 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("xen_block_blockdev_add " "%s" "\n", str);
#line 1786 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_block_blockdev_add(char * str)
{
    if (true) {
        _nocheck__trace_xen_block_blockdev_add(str);
    }
}

#define TRACE_XEN_BLOCK_BLOCKDEV_DEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BLOCK_BLOCKDEV_DEL) || \
    false)

static inline void _nocheck__trace_xen_block_blockdev_del(const char * node_name)
{
    if (trace_event_get_state(TRACE_XEN_BLOCK_BLOCKDEV_DEL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 66 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_block_blockdev_del " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , node_name);
#line 1813 "trace/trace-hw_block.h"
        } else {
#line 66 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("xen_block_blockdev_del " "%s" "\n", node_name);
#line 1817 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_block_blockdev_del(const char * node_name)
{
    if (true) {
        _nocheck__trace_xen_block_blockdev_del(node_name);
    }
}

#define TRACE_XEN_BLOCK_DEVICE_CREATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BLOCK_DEVICE_CREATE) || \
    false)

static inline void _nocheck__trace_xen_block_device_create(unsigned int number)
{
    if (trace_event_get_state(TRACE_XEN_BLOCK_DEVICE_CREATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 67 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_block_device_create " "%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , number);
#line 1844 "trace/trace-hw_block.h"
        } else {
#line 67 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("xen_block_device_create " "%u" "\n", number);
#line 1848 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_block_device_create(unsigned int number)
{
    if (true) {
        _nocheck__trace_xen_block_device_create(number);
    }
}

#define TRACE_XEN_BLOCK_DEVICE_DESTROY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BLOCK_DEVICE_DESTROY) || \
    false)

static inline void _nocheck__trace_xen_block_device_destroy(unsigned int number)
{
    if (trace_event_get_state(TRACE_XEN_BLOCK_DEVICE_DESTROY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 68 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_block_device_destroy " "%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , number);
#line 1875 "trace/trace-hw_block.h"
        } else {
#line 68 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("xen_block_device_destroy " "%u" "\n", number);
#line 1879 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_block_device_destroy(unsigned int number)
{
    if (true) {
        _nocheck__trace_xen_block_device_destroy(number);
    }
}

#define TRACE_M25P80_FLASH_ERASE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_FLASH_ERASE) || \
    false)

static inline void _nocheck__trace_m25p80_flash_erase(void * s, int offset, uint32_t len)
{
    if (trace_event_get_state(TRACE_M25P80_FLASH_ERASE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 71 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_flash_erase " "[%p] offset = 0x%"PRIx32", len = %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, offset, len);
#line 1906 "trace/trace-hw_block.h"
        } else {
#line 71 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("m25p80_flash_erase " "[%p] offset = 0x%"PRIx32", len = %u" "\n", s, offset, len);
#line 1910 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_flash_erase(void * s, int offset, uint32_t len)
{
    if (true) {
        _nocheck__trace_m25p80_flash_erase(s, offset, len);
    }
}

#define TRACE_M25P80_PROGRAMMING_ZERO_TO_ONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_PROGRAMMING_ZERO_TO_ONE) || \
    false)

static inline void _nocheck__trace_m25p80_programming_zero_to_one(void * s, uint32_t addr, uint8_t prev, uint8_t data)
{
    if (trace_event_get_state(TRACE_M25P80_PROGRAMMING_ZERO_TO_ONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 72 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_programming_zero_to_one " "[%p] programming zero to one! addr=0x%"PRIx32"  0x%"PRIx8" -> 0x%"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, addr, prev, data);
#line 1937 "trace/trace-hw_block.h"
        } else {
#line 72 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("m25p80_programming_zero_to_one " "[%p] programming zero to one! addr=0x%"PRIx32"  0x%"PRIx8" -> 0x%"PRIx8 "\n", s, addr, prev, data);
#line 1941 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_programming_zero_to_one(void * s, uint32_t addr, uint8_t prev, uint8_t data)
{
    if (true) {
        _nocheck__trace_m25p80_programming_zero_to_one(s, addr, prev, data);
    }
}

#define TRACE_M25P80_RESET_DONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_RESET_DONE) || \
    false)

static inline void _nocheck__trace_m25p80_reset_done(void * s)
{
    if (trace_event_get_state(TRACE_M25P80_RESET_DONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 73 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_reset_done " "[%p] Reset done." "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s);
#line 1968 "trace/trace-hw_block.h"
        } else {
#line 73 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("m25p80_reset_done " "[%p] Reset done." "\n", s);
#line 1972 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_reset_done(void * s)
{
    if (true) {
        _nocheck__trace_m25p80_reset_done(s);
    }
}

#define TRACE_M25P80_COMMAND_DECODED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_COMMAND_DECODED) || \
    false)

static inline void _nocheck__trace_m25p80_command_decoded(void * s, uint32_t cmd)
{
    if (trace_event_get_state(TRACE_M25P80_COMMAND_DECODED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 74 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_command_decoded " "[%p] new command:0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, cmd);
#line 1999 "trace/trace-hw_block.h"
        } else {
#line 74 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("m25p80_command_decoded " "[%p] new command:0x%"PRIx32 "\n", s, cmd);
#line 2003 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_command_decoded(void * s, uint32_t cmd)
{
    if (true) {
        _nocheck__trace_m25p80_command_decoded(s, cmd);
    }
}

#define TRACE_M25P80_COMPLETE_COLLECTING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_COMPLETE_COLLECTING) || \
    false)

static inline void _nocheck__trace_m25p80_complete_collecting(void * s, uint32_t cmd, int n, uint8_t ear, uint32_t cur_addr)
{
    if (trace_event_get_state(TRACE_M25P80_COMPLETE_COLLECTING) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 75 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_complete_collecting " "[%p] decode cmd: 0x%"PRIx32" len %d ear 0x%"PRIx8" addr 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, cmd, n, ear, cur_addr);
#line 2030 "trace/trace-hw_block.h"
        } else {
#line 75 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("m25p80_complete_collecting " "[%p] decode cmd: 0x%"PRIx32" len %d ear 0x%"PRIx8" addr 0x%"PRIx32 "\n", s, cmd, n, ear, cur_addr);
#line 2034 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_complete_collecting(void * s, uint32_t cmd, int n, uint8_t ear, uint32_t cur_addr)
{
    if (true) {
        _nocheck__trace_m25p80_complete_collecting(s, cmd, n, ear, cur_addr);
    }
}

#define TRACE_M25P80_POPULATED_JEDEC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_POPULATED_JEDEC) || \
    false)

static inline void _nocheck__trace_m25p80_populated_jedec(void * s)
{
    if (trace_event_get_state(TRACE_M25P80_POPULATED_JEDEC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 76 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_populated_jedec " "[%p] populated jedec code" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s);
#line 2061 "trace/trace-hw_block.h"
        } else {
#line 76 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("m25p80_populated_jedec " "[%p] populated jedec code" "\n", s);
#line 2065 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_populated_jedec(void * s)
{
    if (true) {
        _nocheck__trace_m25p80_populated_jedec(s);
    }
}

#define TRACE_M25P80_CHIP_ERASE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_CHIP_ERASE) || \
    false)

static inline void _nocheck__trace_m25p80_chip_erase(void * s)
{
    if (trace_event_get_state(TRACE_M25P80_CHIP_ERASE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 77 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_chip_erase " "[%p] chip erase" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s);
#line 2092 "trace/trace-hw_block.h"
        } else {
#line 77 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("m25p80_chip_erase " "[%p] chip erase" "\n", s);
#line 2096 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_chip_erase(void * s)
{
    if (true) {
        _nocheck__trace_m25p80_chip_erase(s);
    }
}

#define TRACE_M25P80_SELECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_SELECT) || \
    false)

static inline void _nocheck__trace_m25p80_select(void * s, const char * what)
{
    if (trace_event_get_state(TRACE_M25P80_SELECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 78 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_select " "[%p] %sselect" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, what);
#line 2123 "trace/trace-hw_block.h"
        } else {
#line 78 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("m25p80_select " "[%p] %sselect" "\n", s, what);
#line 2127 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_select(void * s, const char * what)
{
    if (true) {
        _nocheck__trace_m25p80_select(s, what);
    }
}

#define TRACE_M25P80_PAGE_PROGRAM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_PAGE_PROGRAM) || \
    false)

static inline void _nocheck__trace_m25p80_page_program(void * s, uint32_t addr, uint8_t tx)
{
    if (trace_event_get_state(TRACE_M25P80_PAGE_PROGRAM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 79 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_page_program " "[%p] page program cur_addr=0x%"PRIx32" data=0x%"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, addr, tx);
#line 2154 "trace/trace-hw_block.h"
        } else {
#line 79 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("m25p80_page_program " "[%p] page program cur_addr=0x%"PRIx32" data=0x%"PRIx8 "\n", s, addr, tx);
#line 2158 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_page_program(void * s, uint32_t addr, uint8_t tx)
{
    if (true) {
        _nocheck__trace_m25p80_page_program(s, addr, tx);
    }
}

#define TRACE_M25P80_TRANSFER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_TRANSFER) || \
    false)

static inline void _nocheck__trace_m25p80_transfer(void * s, uint8_t state, uint32_t len, uint8_t needed, uint32_t pos, uint32_t cur_addr, uint8_t t)
{
    if (trace_event_get_state(TRACE_M25P80_TRANSFER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 80 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_transfer " "[%p] Transfer state 0x%"PRIx8" len 0x%"PRIx32" needed 0x%"PRIx8" pos 0x%"PRIx32" addr 0x%"PRIx32" tx 0x%"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, state, len, needed, pos, cur_addr, t);
#line 2185 "trace/trace-hw_block.h"
        } else {
#line 80 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("m25p80_transfer " "[%p] Transfer state 0x%"PRIx8" len 0x%"PRIx32" needed 0x%"PRIx8" pos 0x%"PRIx32" addr 0x%"PRIx32" tx 0x%"PRIx8 "\n", s, state, len, needed, pos, cur_addr, t);
#line 2189 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_transfer(void * s, uint8_t state, uint32_t len, uint8_t needed, uint32_t pos, uint32_t cur_addr, uint8_t t)
{
    if (true) {
        _nocheck__trace_m25p80_transfer(s, state, len, needed, pos, cur_addr, t);
    }
}

#define TRACE_M25P80_READ_BYTE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_READ_BYTE) || \
    false)

static inline void _nocheck__trace_m25p80_read_byte(void * s, uint32_t addr, uint8_t v)
{
    if (trace_event_get_state(TRACE_M25P80_READ_BYTE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 81 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_read_byte " "[%p] Read byte 0x%"PRIx32"=0x%"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, addr, v);
#line 2216 "trace/trace-hw_block.h"
        } else {
#line 81 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("m25p80_read_byte " "[%p] Read byte 0x%"PRIx32"=0x%"PRIx8 "\n", s, addr, v);
#line 2220 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_read_byte(void * s, uint32_t addr, uint8_t v)
{
    if (true) {
        _nocheck__trace_m25p80_read_byte(s, addr, v);
    }
}

#define TRACE_M25P80_READ_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_READ_DATA) || \
    false)

static inline void _nocheck__trace_m25p80_read_data(void * s, uint32_t pos, uint8_t v)
{
    if (trace_event_get_state(TRACE_M25P80_READ_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 82 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_read_data " "[%p] Read data 0x%"PRIx32"=0x%"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, pos, v);
#line 2247 "trace/trace-hw_block.h"
        } else {
#line 82 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("m25p80_read_data " "[%p] Read data 0x%"PRIx32"=0x%"PRIx8 "\n", s, pos, v);
#line 2251 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_read_data(void * s, uint32_t pos, uint8_t v)
{
    if (true) {
        _nocheck__trace_m25p80_read_data(s, pos, v);
    }
}

#define TRACE_M25P80_BINDING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_BINDING) || \
    false)

static inline void _nocheck__trace_m25p80_binding(void * s)
{
    if (trace_event_get_state(TRACE_M25P80_BINDING) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 83 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_binding " "[%p] Binding to IF_MTD drive" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s);
#line 2278 "trace/trace-hw_block.h"
        } else {
#line 83 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("m25p80_binding " "[%p] Binding to IF_MTD drive" "\n", s);
#line 2282 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_binding(void * s)
{
    if (true) {
        _nocheck__trace_m25p80_binding(s);
    }
}

#define TRACE_M25P80_BINDING_NO_BDRV_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_BINDING_NO_BDRV) || \
    false)

static inline void _nocheck__trace_m25p80_binding_no_bdrv(void * s)
{
    if (trace_event_get_state(TRACE_M25P80_BINDING_NO_BDRV) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 84 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_binding_no_bdrv " "[%p] No BDRV - binding to RAM" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s);
#line 2309 "trace/trace-hw_block.h"
        } else {
#line 84 "/home/inhoinno/FEMU/hw/block/trace-events"
            qemu_log("m25p80_binding_no_bdrv " "[%p] No BDRV - binding to RAM" "\n", s);
#line 2313 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_binding_no_bdrv(void * s)
{
    if (true) {
        _nocheck__trace_m25p80_binding_no_bdrv(s);
    }
}
#endif /* TRACE_HW_BLOCK_GENERATED_TRACERS_H */
