/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_I386_GENERATED_TRACERS_H
#define TRACE_HW_I386_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_X86_IOMMU_IEC_NOTIFY_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_CC_DOMAIN_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_CC_GLOBAL_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_CC_DEVICE_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_CC_DEVICES_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_IOTLB_GLOBAL_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_IOTLB_DOMAIN_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_IOTLB_PAGES_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_WAIT_SW_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_WAIT_IRQ_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_WAIT_WRITE_FAIL_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_IEC_EVENT;
extern TraceEvent _TRACE_VTD_INV_QI_ENABLE_EVENT;
extern TraceEvent _TRACE_VTD_INV_QI_SETUP_EVENT;
extern TraceEvent _TRACE_VTD_INV_QI_HEAD_EVENT;
extern TraceEvent _TRACE_VTD_INV_QI_TAIL_EVENT;
extern TraceEvent _TRACE_VTD_INV_QI_FETCH_EVENT;
extern TraceEvent _TRACE_VTD_CONTEXT_CACHE_RESET_EVENT;
extern TraceEvent _TRACE_VTD_RE_NOT_PRESENT_EVENT;
extern TraceEvent _TRACE_VTD_CE_NOT_PRESENT_EVENT;
extern TraceEvent _TRACE_VTD_IOTLB_PAGE_HIT_EVENT;
extern TraceEvent _TRACE_VTD_IOTLB_PAGE_UPDATE_EVENT;
extern TraceEvent _TRACE_VTD_IOTLB_CC_HIT_EVENT;
extern TraceEvent _TRACE_VTD_IOTLB_CC_UPDATE_EVENT;
extern TraceEvent _TRACE_VTD_IOTLB_RESET_EVENT;
extern TraceEvent _TRACE_VTD_FAULT_DISABLED_EVENT;
extern TraceEvent _TRACE_VTD_REPLAY_CE_VALID_EVENT;
extern TraceEvent _TRACE_VTD_REPLAY_CE_INVALID_EVENT;
extern TraceEvent _TRACE_VTD_PAGE_WALK_LEVEL_EVENT;
extern TraceEvent _TRACE_VTD_PAGE_WALK_ONE_EVENT;
extern TraceEvent _TRACE_VTD_PAGE_WALK_ONE_SKIP_MAP_EVENT;
extern TraceEvent _TRACE_VTD_PAGE_WALK_ONE_SKIP_UNMAP_EVENT;
extern TraceEvent _TRACE_VTD_PAGE_WALK_SKIP_READ_EVENT;
extern TraceEvent _TRACE_VTD_PAGE_WALK_SKIP_RESERVE_EVENT;
extern TraceEvent _TRACE_VTD_SWITCH_ADDRESS_SPACE_EVENT;
extern TraceEvent _TRACE_VTD_AS_UNMAP_WHOLE_EVENT;
extern TraceEvent _TRACE_VTD_TRANSLATE_PT_EVENT;
extern TraceEvent _TRACE_VTD_PT_ENABLE_FAST_PATH_EVENT;
extern TraceEvent _TRACE_VTD_IRQ_GENERATE_EVENT;
extern TraceEvent _TRACE_VTD_REG_READ_EVENT;
extern TraceEvent _TRACE_VTD_REG_WRITE_EVENT;
extern TraceEvent _TRACE_VTD_REG_DMAR_ROOT_EVENT;
extern TraceEvent _TRACE_VTD_REG_IR_ROOT_EVENT;
extern TraceEvent _TRACE_VTD_REG_WRITE_GCMD_EVENT;
extern TraceEvent _TRACE_VTD_REG_WRITE_FECTL_EVENT;
extern TraceEvent _TRACE_VTD_REG_WRITE_IECTL_EVENT;
extern TraceEvent _TRACE_VTD_REG_ICS_CLEAR_IP_EVENT;
extern TraceEvent _TRACE_VTD_DMAR_TRANSLATE_EVENT;
extern TraceEvent _TRACE_VTD_DMAR_ENABLE_EVENT;
extern TraceEvent _TRACE_VTD_DMAR_FAULT_EVENT;
extern TraceEvent _TRACE_VTD_IR_ENABLE_EVENT;
extern TraceEvent _TRACE_VTD_IR_IRTE_GET_EVENT;
extern TraceEvent _TRACE_VTD_IR_REMAP_EVENT;
extern TraceEvent _TRACE_VTD_IR_REMAP_TYPE_EVENT;
extern TraceEvent _TRACE_VTD_IR_REMAP_MSI_EVENT;
extern TraceEvent _TRACE_VTD_IR_REMAP_MSI_REQ_EVENT;
extern TraceEvent _TRACE_VTD_FSTS_PPF_EVENT;
extern TraceEvent _TRACE_VTD_FSTS_CLEAR_IP_EVENT;
extern TraceEvent _TRACE_VTD_FRR_NEW_EVENT;
extern TraceEvent _TRACE_VTD_WARN_INVALID_QI_TAIL_EVENT;
extern TraceEvent _TRACE_VTD_WARN_IR_VECTOR_EVENT;
extern TraceEvent _TRACE_VTD_WARN_IR_TRIGGER_EVENT;
extern TraceEvent _TRACE_AMDVI_EVNTLOG_FAIL_EVENT;
extern TraceEvent _TRACE_AMDVI_CACHE_UPDATE_EVENT;
extern TraceEvent _TRACE_AMDVI_COMPLETION_WAIT_FAIL_EVENT;
extern TraceEvent _TRACE_AMDVI_MMIO_WRITE_EVENT;
extern TraceEvent _TRACE_AMDVI_MMIO_READ_EVENT;
extern TraceEvent _TRACE_AMDVI_MMIO_READ_INVALID_EVENT;
extern TraceEvent _TRACE_AMDVI_COMMAND_ERROR_EVENT;
extern TraceEvent _TRACE_AMDVI_COMMAND_READ_FAIL_EVENT;
extern TraceEvent _TRACE_AMDVI_COMMAND_EXEC_EVENT;
extern TraceEvent _TRACE_AMDVI_UNHANDLED_COMMAND_EVENT;
extern TraceEvent _TRACE_AMDVI_INTR_INVAL_EVENT;
extern TraceEvent _TRACE_AMDVI_IOTLB_INVAL_EVENT;
extern TraceEvent _TRACE_AMDVI_PREFETCH_PAGES_EVENT;
extern TraceEvent _TRACE_AMDVI_PAGES_INVAL_EVENT;
extern TraceEvent _TRACE_AMDVI_ALL_INVAL_EVENT;
extern TraceEvent _TRACE_AMDVI_PPR_EXEC_EVENT;
extern TraceEvent _TRACE_AMDVI_DEVTAB_INVAL_EVENT;
extern TraceEvent _TRACE_AMDVI_COMPLETION_WAIT_EVENT;
extern TraceEvent _TRACE_AMDVI_CONTROL_STATUS_EVENT;
extern TraceEvent _TRACE_AMDVI_IOTLB_RESET_EVENT;
extern TraceEvent _TRACE_AMDVI_DTE_GET_FAIL_EVENT;
extern TraceEvent _TRACE_AMDVI_INVALID_DTE_EVENT;
extern TraceEvent _TRACE_AMDVI_GET_PTE_HWERROR_EVENT;
extern TraceEvent _TRACE_AMDVI_MODE_INVALID_EVENT;
extern TraceEvent _TRACE_AMDVI_PAGE_FAULT_EVENT;
extern TraceEvent _TRACE_AMDVI_IOTLB_HIT_EVENT;
extern TraceEvent _TRACE_AMDVI_TRANSLATION_RESULT_EVENT;
extern TraceEvent _TRACE_AMDVI_MEM_IR_WRITE_REQ_EVENT;
extern TraceEvent _TRACE_AMDVI_MEM_IR_WRITE_EVENT;
extern TraceEvent _TRACE_AMDVI_IR_REMAP_MSI_REQ_EVENT;
extern TraceEvent _TRACE_AMDVI_IR_REMAP_MSI_EVENT;
extern TraceEvent _TRACE_AMDVI_ERR_EVENT;
extern TraceEvent _TRACE_AMDVI_IR_IRTE_EVENT;
extern TraceEvent _TRACE_AMDVI_IR_IRTE_VAL_EVENT;
extern TraceEvent _TRACE_AMDVI_IR_ERR_EVENT;
extern TraceEvent _TRACE_AMDVI_IR_INTCTL_EVENT;
extern TraceEvent _TRACE_AMDVI_IR_TARGET_ABORT_EVENT;
extern TraceEvent _TRACE_AMDVI_IR_DELIVERY_MODE_EVENT;
extern TraceEvent _TRACE_AMDVI_IR_IRTE_GA_VAL_EVENT;
extern TraceEvent _TRACE_VMPORT_REGISTER_EVENT;
extern TraceEvent _TRACE_VMPORT_COMMAND_EVENT;
extern TraceEvent _TRACE_X86_GSI_INTERRUPT_EVENT;
extern TraceEvent _TRACE_X86_PIC_INTERRUPT_EVENT;
extern TraceEvent _TRACE_PORT92_READ_EVENT;
extern TraceEvent _TRACE_PORT92_WRITE_EVENT;
extern uint16_t _TRACE_X86_IOMMU_IEC_NOTIFY_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_CC_DOMAIN_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_CC_GLOBAL_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_CC_DEVICE_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_CC_DEVICES_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_IOTLB_GLOBAL_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_IOTLB_DOMAIN_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_IOTLB_PAGES_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_WAIT_SW_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_WAIT_IRQ_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_WAIT_WRITE_FAIL_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_IEC_DSTATE;
extern uint16_t _TRACE_VTD_INV_QI_ENABLE_DSTATE;
extern uint16_t _TRACE_VTD_INV_QI_SETUP_DSTATE;
extern uint16_t _TRACE_VTD_INV_QI_HEAD_DSTATE;
extern uint16_t _TRACE_VTD_INV_QI_TAIL_DSTATE;
extern uint16_t _TRACE_VTD_INV_QI_FETCH_DSTATE;
extern uint16_t _TRACE_VTD_CONTEXT_CACHE_RESET_DSTATE;
extern uint16_t _TRACE_VTD_RE_NOT_PRESENT_DSTATE;
extern uint16_t _TRACE_VTD_CE_NOT_PRESENT_DSTATE;
extern uint16_t _TRACE_VTD_IOTLB_PAGE_HIT_DSTATE;
extern uint16_t _TRACE_VTD_IOTLB_PAGE_UPDATE_DSTATE;
extern uint16_t _TRACE_VTD_IOTLB_CC_HIT_DSTATE;
extern uint16_t _TRACE_VTD_IOTLB_CC_UPDATE_DSTATE;
extern uint16_t _TRACE_VTD_IOTLB_RESET_DSTATE;
extern uint16_t _TRACE_VTD_FAULT_DISABLED_DSTATE;
extern uint16_t _TRACE_VTD_REPLAY_CE_VALID_DSTATE;
extern uint16_t _TRACE_VTD_REPLAY_CE_INVALID_DSTATE;
extern uint16_t _TRACE_VTD_PAGE_WALK_LEVEL_DSTATE;
extern uint16_t _TRACE_VTD_PAGE_WALK_ONE_DSTATE;
extern uint16_t _TRACE_VTD_PAGE_WALK_ONE_SKIP_MAP_DSTATE;
extern uint16_t _TRACE_VTD_PAGE_WALK_ONE_SKIP_UNMAP_DSTATE;
extern uint16_t _TRACE_VTD_PAGE_WALK_SKIP_READ_DSTATE;
extern uint16_t _TRACE_VTD_PAGE_WALK_SKIP_RESERVE_DSTATE;
extern uint16_t _TRACE_VTD_SWITCH_ADDRESS_SPACE_DSTATE;
extern uint16_t _TRACE_VTD_AS_UNMAP_WHOLE_DSTATE;
extern uint16_t _TRACE_VTD_TRANSLATE_PT_DSTATE;
extern uint16_t _TRACE_VTD_PT_ENABLE_FAST_PATH_DSTATE;
extern uint16_t _TRACE_VTD_IRQ_GENERATE_DSTATE;
extern uint16_t _TRACE_VTD_REG_READ_DSTATE;
extern uint16_t _TRACE_VTD_REG_WRITE_DSTATE;
extern uint16_t _TRACE_VTD_REG_DMAR_ROOT_DSTATE;
extern uint16_t _TRACE_VTD_REG_IR_ROOT_DSTATE;
extern uint16_t _TRACE_VTD_REG_WRITE_GCMD_DSTATE;
extern uint16_t _TRACE_VTD_REG_WRITE_FECTL_DSTATE;
extern uint16_t _TRACE_VTD_REG_WRITE_IECTL_DSTATE;
extern uint16_t _TRACE_VTD_REG_ICS_CLEAR_IP_DSTATE;
extern uint16_t _TRACE_VTD_DMAR_TRANSLATE_DSTATE;
extern uint16_t _TRACE_VTD_DMAR_ENABLE_DSTATE;
extern uint16_t _TRACE_VTD_DMAR_FAULT_DSTATE;
extern uint16_t _TRACE_VTD_IR_ENABLE_DSTATE;
extern uint16_t _TRACE_VTD_IR_IRTE_GET_DSTATE;
extern uint16_t _TRACE_VTD_IR_REMAP_DSTATE;
extern uint16_t _TRACE_VTD_IR_REMAP_TYPE_DSTATE;
extern uint16_t _TRACE_VTD_IR_REMAP_MSI_DSTATE;
extern uint16_t _TRACE_VTD_IR_REMAP_MSI_REQ_DSTATE;
extern uint16_t _TRACE_VTD_FSTS_PPF_DSTATE;
extern uint16_t _TRACE_VTD_FSTS_CLEAR_IP_DSTATE;
extern uint16_t _TRACE_VTD_FRR_NEW_DSTATE;
extern uint16_t _TRACE_VTD_WARN_INVALID_QI_TAIL_DSTATE;
extern uint16_t _TRACE_VTD_WARN_IR_VECTOR_DSTATE;
extern uint16_t _TRACE_VTD_WARN_IR_TRIGGER_DSTATE;
extern uint16_t _TRACE_AMDVI_EVNTLOG_FAIL_DSTATE;
extern uint16_t _TRACE_AMDVI_CACHE_UPDATE_DSTATE;
extern uint16_t _TRACE_AMDVI_COMPLETION_WAIT_FAIL_DSTATE;
extern uint16_t _TRACE_AMDVI_MMIO_WRITE_DSTATE;
extern uint16_t _TRACE_AMDVI_MMIO_READ_DSTATE;
extern uint16_t _TRACE_AMDVI_MMIO_READ_INVALID_DSTATE;
extern uint16_t _TRACE_AMDVI_COMMAND_ERROR_DSTATE;
extern uint16_t _TRACE_AMDVI_COMMAND_READ_FAIL_DSTATE;
extern uint16_t _TRACE_AMDVI_COMMAND_EXEC_DSTATE;
extern uint16_t _TRACE_AMDVI_UNHANDLED_COMMAND_DSTATE;
extern uint16_t _TRACE_AMDVI_INTR_INVAL_DSTATE;
extern uint16_t _TRACE_AMDVI_IOTLB_INVAL_DSTATE;
extern uint16_t _TRACE_AMDVI_PREFETCH_PAGES_DSTATE;
extern uint16_t _TRACE_AMDVI_PAGES_INVAL_DSTATE;
extern uint16_t _TRACE_AMDVI_ALL_INVAL_DSTATE;
extern uint16_t _TRACE_AMDVI_PPR_EXEC_DSTATE;
extern uint16_t _TRACE_AMDVI_DEVTAB_INVAL_DSTATE;
extern uint16_t _TRACE_AMDVI_COMPLETION_WAIT_DSTATE;
extern uint16_t _TRACE_AMDVI_CONTROL_STATUS_DSTATE;
extern uint16_t _TRACE_AMDVI_IOTLB_RESET_DSTATE;
extern uint16_t _TRACE_AMDVI_DTE_GET_FAIL_DSTATE;
extern uint16_t _TRACE_AMDVI_INVALID_DTE_DSTATE;
extern uint16_t _TRACE_AMDVI_GET_PTE_HWERROR_DSTATE;
extern uint16_t _TRACE_AMDVI_MODE_INVALID_DSTATE;
extern uint16_t _TRACE_AMDVI_PAGE_FAULT_DSTATE;
extern uint16_t _TRACE_AMDVI_IOTLB_HIT_DSTATE;
extern uint16_t _TRACE_AMDVI_TRANSLATION_RESULT_DSTATE;
extern uint16_t _TRACE_AMDVI_MEM_IR_WRITE_REQ_DSTATE;
extern uint16_t _TRACE_AMDVI_MEM_IR_WRITE_DSTATE;
extern uint16_t _TRACE_AMDVI_IR_REMAP_MSI_REQ_DSTATE;
extern uint16_t _TRACE_AMDVI_IR_REMAP_MSI_DSTATE;
extern uint16_t _TRACE_AMDVI_ERR_DSTATE;
extern uint16_t _TRACE_AMDVI_IR_IRTE_DSTATE;
extern uint16_t _TRACE_AMDVI_IR_IRTE_VAL_DSTATE;
extern uint16_t _TRACE_AMDVI_IR_ERR_DSTATE;
extern uint16_t _TRACE_AMDVI_IR_INTCTL_DSTATE;
extern uint16_t _TRACE_AMDVI_IR_TARGET_ABORT_DSTATE;
extern uint16_t _TRACE_AMDVI_IR_DELIVERY_MODE_DSTATE;
extern uint16_t _TRACE_AMDVI_IR_IRTE_GA_VAL_DSTATE;
extern uint16_t _TRACE_VMPORT_REGISTER_DSTATE;
extern uint16_t _TRACE_VMPORT_COMMAND_DSTATE;
extern uint16_t _TRACE_X86_GSI_INTERRUPT_DSTATE;
extern uint16_t _TRACE_X86_PIC_INTERRUPT_DSTATE;
extern uint16_t _TRACE_PORT92_READ_DSTATE;
extern uint16_t _TRACE_PORT92_WRITE_DSTATE;
#define TRACE_X86_IOMMU_IEC_NOTIFY_ENABLED 1
#define TRACE_VTD_INV_DESC_ENABLED 1
#define TRACE_VTD_INV_DESC_CC_DOMAIN_ENABLED 1
#define TRACE_VTD_INV_DESC_CC_GLOBAL_ENABLED 1
#define TRACE_VTD_INV_DESC_CC_DEVICE_ENABLED 1
#define TRACE_VTD_INV_DESC_CC_DEVICES_ENABLED 1
#define TRACE_VTD_INV_DESC_IOTLB_GLOBAL_ENABLED 1
#define TRACE_VTD_INV_DESC_IOTLB_DOMAIN_ENABLED 1
#define TRACE_VTD_INV_DESC_IOTLB_PAGES_ENABLED 1
#define TRACE_VTD_INV_DESC_WAIT_SW_ENABLED 1
#define TRACE_VTD_INV_DESC_WAIT_IRQ_ENABLED 1
#define TRACE_VTD_INV_DESC_WAIT_WRITE_FAIL_ENABLED 1
#define TRACE_VTD_INV_DESC_IEC_ENABLED 1
#define TRACE_VTD_INV_QI_ENABLE_ENABLED 1
#define TRACE_VTD_INV_QI_SETUP_ENABLED 1
#define TRACE_VTD_INV_QI_HEAD_ENABLED 1
#define TRACE_VTD_INV_QI_TAIL_ENABLED 1
#define TRACE_VTD_INV_QI_FETCH_ENABLED 1
#define TRACE_VTD_CONTEXT_CACHE_RESET_ENABLED 1
#define TRACE_VTD_RE_NOT_PRESENT_ENABLED 1
#define TRACE_VTD_CE_NOT_PRESENT_ENABLED 1
#define TRACE_VTD_IOTLB_PAGE_HIT_ENABLED 1
#define TRACE_VTD_IOTLB_PAGE_UPDATE_ENABLED 1
#define TRACE_VTD_IOTLB_CC_HIT_ENABLED 1
#define TRACE_VTD_IOTLB_CC_UPDATE_ENABLED 1
#define TRACE_VTD_IOTLB_RESET_ENABLED 1
#define TRACE_VTD_FAULT_DISABLED_ENABLED 1
#define TRACE_VTD_REPLAY_CE_VALID_ENABLED 1
#define TRACE_VTD_REPLAY_CE_INVALID_ENABLED 1
#define TRACE_VTD_PAGE_WALK_LEVEL_ENABLED 1
#define TRACE_VTD_PAGE_WALK_ONE_ENABLED 1
#define TRACE_VTD_PAGE_WALK_ONE_SKIP_MAP_ENABLED 1
#define TRACE_VTD_PAGE_WALK_ONE_SKIP_UNMAP_ENABLED 1
#define TRACE_VTD_PAGE_WALK_SKIP_READ_ENABLED 1
#define TRACE_VTD_PAGE_WALK_SKIP_RESERVE_ENABLED 1
#define TRACE_VTD_SWITCH_ADDRESS_SPACE_ENABLED 1
#define TRACE_VTD_AS_UNMAP_WHOLE_ENABLED 1
#define TRACE_VTD_TRANSLATE_PT_ENABLED 1
#define TRACE_VTD_PT_ENABLE_FAST_PATH_ENABLED 1
#define TRACE_VTD_IRQ_GENERATE_ENABLED 1
#define TRACE_VTD_REG_READ_ENABLED 1
#define TRACE_VTD_REG_WRITE_ENABLED 1
#define TRACE_VTD_REG_DMAR_ROOT_ENABLED 1
#define TRACE_VTD_REG_IR_ROOT_ENABLED 1
#define TRACE_VTD_REG_WRITE_GCMD_ENABLED 1
#define TRACE_VTD_REG_WRITE_FECTL_ENABLED 1
#define TRACE_VTD_REG_WRITE_IECTL_ENABLED 1
#define TRACE_VTD_REG_ICS_CLEAR_IP_ENABLED 1
#define TRACE_VTD_DMAR_TRANSLATE_ENABLED 1
#define TRACE_VTD_DMAR_ENABLE_ENABLED 1
#define TRACE_VTD_DMAR_FAULT_ENABLED 1
#define TRACE_VTD_IR_ENABLE_ENABLED 1
#define TRACE_VTD_IR_IRTE_GET_ENABLED 1
#define TRACE_VTD_IR_REMAP_ENABLED 1
#define TRACE_VTD_IR_REMAP_TYPE_ENABLED 1
#define TRACE_VTD_IR_REMAP_MSI_ENABLED 1
#define TRACE_VTD_IR_REMAP_MSI_REQ_ENABLED 1
#define TRACE_VTD_FSTS_PPF_ENABLED 1
#define TRACE_VTD_FSTS_CLEAR_IP_ENABLED 1
#define TRACE_VTD_FRR_NEW_ENABLED 1
#define TRACE_VTD_WARN_INVALID_QI_TAIL_ENABLED 1
#define TRACE_VTD_WARN_IR_VECTOR_ENABLED 1
#define TRACE_VTD_WARN_IR_TRIGGER_ENABLED 1
#define TRACE_AMDVI_EVNTLOG_FAIL_ENABLED 1
#define TRACE_AMDVI_CACHE_UPDATE_ENABLED 1
#define TRACE_AMDVI_COMPLETION_WAIT_FAIL_ENABLED 1
#define TRACE_AMDVI_MMIO_WRITE_ENABLED 1
#define TRACE_AMDVI_MMIO_READ_ENABLED 1
#define TRACE_AMDVI_MMIO_READ_INVALID_ENABLED 1
#define TRACE_AMDVI_COMMAND_ERROR_ENABLED 1
#define TRACE_AMDVI_COMMAND_READ_FAIL_ENABLED 1
#define TRACE_AMDVI_COMMAND_EXEC_ENABLED 1
#define TRACE_AMDVI_UNHANDLED_COMMAND_ENABLED 1
#define TRACE_AMDVI_INTR_INVAL_ENABLED 1
#define TRACE_AMDVI_IOTLB_INVAL_ENABLED 1
#define TRACE_AMDVI_PREFETCH_PAGES_ENABLED 1
#define TRACE_AMDVI_PAGES_INVAL_ENABLED 1
#define TRACE_AMDVI_ALL_INVAL_ENABLED 1
#define TRACE_AMDVI_PPR_EXEC_ENABLED 1
#define TRACE_AMDVI_DEVTAB_INVAL_ENABLED 1
#define TRACE_AMDVI_COMPLETION_WAIT_ENABLED 1
#define TRACE_AMDVI_CONTROL_STATUS_ENABLED 1
#define TRACE_AMDVI_IOTLB_RESET_ENABLED 1
#define TRACE_AMDVI_DTE_GET_FAIL_ENABLED 1
#define TRACE_AMDVI_INVALID_DTE_ENABLED 1
#define TRACE_AMDVI_GET_PTE_HWERROR_ENABLED 1
#define TRACE_AMDVI_MODE_INVALID_ENABLED 1
#define TRACE_AMDVI_PAGE_FAULT_ENABLED 1
#define TRACE_AMDVI_IOTLB_HIT_ENABLED 1
#define TRACE_AMDVI_TRANSLATION_RESULT_ENABLED 1
#define TRACE_AMDVI_MEM_IR_WRITE_REQ_ENABLED 1
#define TRACE_AMDVI_MEM_IR_WRITE_ENABLED 1
#define TRACE_AMDVI_IR_REMAP_MSI_REQ_ENABLED 1
#define TRACE_AMDVI_IR_REMAP_MSI_ENABLED 1
#define TRACE_AMDVI_ERR_ENABLED 1
#define TRACE_AMDVI_IR_IRTE_ENABLED 1
#define TRACE_AMDVI_IR_IRTE_VAL_ENABLED 1
#define TRACE_AMDVI_IR_ERR_ENABLED 1
#define TRACE_AMDVI_IR_INTCTL_ENABLED 1
#define TRACE_AMDVI_IR_TARGET_ABORT_ENABLED 1
#define TRACE_AMDVI_IR_DELIVERY_MODE_ENABLED 1
#define TRACE_AMDVI_IR_IRTE_GA_VAL_ENABLED 1
#define TRACE_VMPORT_REGISTER_ENABLED 1
#define TRACE_VMPORT_COMMAND_ENABLED 1
#define TRACE_X86_GSI_INTERRUPT_ENABLED 1
#define TRACE_X86_PIC_INTERRUPT_ENABLED 1
#define TRACE_PORT92_READ_ENABLED 1
#define TRACE_PORT92_WRITE_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_X86_IOMMU_IEC_NOTIFY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_X86_IOMMU_IEC_NOTIFY) || \
    false)

static inline void _nocheck__trace_x86_iommu_iec_notify(bool global, uint32_t index, uint32_t mask)
{
    if (trace_event_get_state(TRACE_X86_IOMMU_IEC_NOTIFY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 4 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:x86_iommu_iec_notify " "Notify IEC invalidation: global=%d index=%" PRIu32 " mask=%" PRIu32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , global, index, mask);
#line 352 "trace/trace-hw_i386.h"
        } else {
#line 4 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("x86_iommu_iec_notify " "Notify IEC invalidation: global=%d index=%" PRIu32 " mask=%" PRIu32 "\n", global, index, mask);
#line 356 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_x86_iommu_iec_notify(bool global, uint32_t index, uint32_t mask)
{
    if (true) {
        _nocheck__trace_x86_iommu_iec_notify(global, index, mask);
    }
}

#define TRACE_VTD_INV_DESC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc(const char * type, uint64_t hi, uint64_t lo)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 7 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_inv_desc " "invalidate desc type %s high 0x%"PRIx64" low 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, hi, lo);
#line 383 "trace/trace-hw_i386.h"
        } else {
#line 7 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_inv_desc " "invalidate desc type %s high 0x%"PRIx64" low 0x%"PRIx64 "\n", type, hi, lo);
#line 387 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_inv_desc(const char * type, uint64_t hi, uint64_t lo)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc(type, hi, lo);
    }
}

#define TRACE_VTD_INV_DESC_CC_DOMAIN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_CC_DOMAIN) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_cc_domain(uint16_t domain)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_CC_DOMAIN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 8 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_inv_desc_cc_domain " "context invalidate domain 0x%"PRIx16 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , domain);
#line 414 "trace/trace-hw_i386.h"
        } else {
#line 8 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_inv_desc_cc_domain " "context invalidate domain 0x%"PRIx16 "\n", domain);
#line 418 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_inv_desc_cc_domain(uint16_t domain)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_cc_domain(domain);
    }
}

#define TRACE_VTD_INV_DESC_CC_GLOBAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_CC_GLOBAL) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_cc_global(void)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_CC_GLOBAL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 9 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_inv_desc_cc_global " "context invalidate globally" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 445 "trace/trace-hw_i386.h"
        } else {
#line 9 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_inv_desc_cc_global " "context invalidate globally" "\n");
#line 449 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_inv_desc_cc_global(void)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_cc_global();
    }
}

#define TRACE_VTD_INV_DESC_CC_DEVICE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_CC_DEVICE) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_cc_device(uint8_t bus, uint8_t dev, uint8_t fn)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_CC_DEVICE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 10 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_inv_desc_cc_device " "context invalidate device %02"PRIx8":%02"PRIx8".%02"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bus, dev, fn);
#line 476 "trace/trace-hw_i386.h"
        } else {
#line 10 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_inv_desc_cc_device " "context invalidate device %02"PRIx8":%02"PRIx8".%02"PRIx8 "\n", bus, dev, fn);
#line 480 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_inv_desc_cc_device(uint8_t bus, uint8_t dev, uint8_t fn)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_cc_device(bus, dev, fn);
    }
}

#define TRACE_VTD_INV_DESC_CC_DEVICES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_CC_DEVICES) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_cc_devices(uint16_t sid, uint16_t fmask)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_CC_DEVICES) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 11 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_inv_desc_cc_devices " "context invalidate devices sid 0x%"PRIx16" fmask 0x%"PRIx16 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , sid, fmask);
#line 507 "trace/trace-hw_i386.h"
        } else {
#line 11 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_inv_desc_cc_devices " "context invalidate devices sid 0x%"PRIx16" fmask 0x%"PRIx16 "\n", sid, fmask);
#line 511 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_inv_desc_cc_devices(uint16_t sid, uint16_t fmask)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_cc_devices(sid, fmask);
    }
}

#define TRACE_VTD_INV_DESC_IOTLB_GLOBAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_IOTLB_GLOBAL) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_iotlb_global(void)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_IOTLB_GLOBAL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 12 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_inv_desc_iotlb_global " "iotlb invalidate global" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 538 "trace/trace-hw_i386.h"
        } else {
#line 12 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_inv_desc_iotlb_global " "iotlb invalidate global" "\n");
#line 542 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_inv_desc_iotlb_global(void)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_iotlb_global();
    }
}

#define TRACE_VTD_INV_DESC_IOTLB_DOMAIN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_IOTLB_DOMAIN) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_iotlb_domain(uint16_t domain)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_IOTLB_DOMAIN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 13 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_inv_desc_iotlb_domain " "iotlb invalidate whole domain 0x%"PRIx16 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , domain);
#line 569 "trace/trace-hw_i386.h"
        } else {
#line 13 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_inv_desc_iotlb_domain " "iotlb invalidate whole domain 0x%"PRIx16 "\n", domain);
#line 573 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_inv_desc_iotlb_domain(uint16_t domain)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_iotlb_domain(domain);
    }
}

#define TRACE_VTD_INV_DESC_IOTLB_PAGES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_IOTLB_PAGES) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_iotlb_pages(uint16_t domain, uint64_t addr, uint8_t mask)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_IOTLB_PAGES) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 14 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_inv_desc_iotlb_pages " "iotlb invalidate domain 0x%"PRIx16" addr 0x%"PRIx64" mask 0x%"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , domain, addr, mask);
#line 600 "trace/trace-hw_i386.h"
        } else {
#line 14 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_inv_desc_iotlb_pages " "iotlb invalidate domain 0x%"PRIx16" addr 0x%"PRIx64" mask 0x%"PRIx8 "\n", domain, addr, mask);
#line 604 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_inv_desc_iotlb_pages(uint16_t domain, uint64_t addr, uint8_t mask)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_iotlb_pages(domain, addr, mask);
    }
}

#define TRACE_VTD_INV_DESC_WAIT_SW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_WAIT_SW) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_wait_sw(uint64_t addr, uint32_t data)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_WAIT_SW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 15 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_inv_desc_wait_sw " "wait invalidate status write addr 0x%"PRIx64" data 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, data);
#line 631 "trace/trace-hw_i386.h"
        } else {
#line 15 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_inv_desc_wait_sw " "wait invalidate status write addr 0x%"PRIx64" data 0x%"PRIx32 "\n", addr, data);
#line 635 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_inv_desc_wait_sw(uint64_t addr, uint32_t data)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_wait_sw(addr, data);
    }
}

#define TRACE_VTD_INV_DESC_WAIT_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_WAIT_IRQ) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_wait_irq(const char * msg)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_WAIT_IRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 16 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_inv_desc_wait_irq " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , msg);
#line 662 "trace/trace-hw_i386.h"
        } else {
#line 16 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_inv_desc_wait_irq " "%s" "\n", msg);
#line 666 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_inv_desc_wait_irq(const char * msg)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_wait_irq(msg);
    }
}

#define TRACE_VTD_INV_DESC_WAIT_WRITE_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_WAIT_WRITE_FAIL) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_wait_write_fail(uint64_t hi, uint64_t lo)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_WAIT_WRITE_FAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 17 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_inv_desc_wait_write_fail " "write fail for wait desc hi 0x%"PRIx64" lo 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , hi, lo);
#line 693 "trace/trace-hw_i386.h"
        } else {
#line 17 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_inv_desc_wait_write_fail " "write fail for wait desc hi 0x%"PRIx64" lo 0x%"PRIx64 "\n", hi, lo);
#line 697 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_inv_desc_wait_write_fail(uint64_t hi, uint64_t lo)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_wait_write_fail(hi, lo);
    }
}

#define TRACE_VTD_INV_DESC_IEC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_IEC) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_iec(uint32_t granularity, uint32_t index, uint32_t mask)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_IEC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 18 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_inv_desc_iec " "granularity 0x%"PRIx32" index 0x%"PRIx32" mask 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , granularity, index, mask);
#line 724 "trace/trace-hw_i386.h"
        } else {
#line 18 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_inv_desc_iec " "granularity 0x%"PRIx32" index 0x%"PRIx32" mask 0x%"PRIx32 "\n", granularity, index, mask);
#line 728 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_inv_desc_iec(uint32_t granularity, uint32_t index, uint32_t mask)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_iec(granularity, index, mask);
    }
}

#define TRACE_VTD_INV_QI_ENABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_QI_ENABLE) || \
    false)

static inline void _nocheck__trace_vtd_inv_qi_enable(bool enable)
{
    if (trace_event_get_state(TRACE_VTD_INV_QI_ENABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 19 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_inv_qi_enable " "enabled %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , enable);
#line 755 "trace/trace-hw_i386.h"
        } else {
#line 19 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_inv_qi_enable " "enabled %d" "\n", enable);
#line 759 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_inv_qi_enable(bool enable)
{
    if (true) {
        _nocheck__trace_vtd_inv_qi_enable(enable);
    }
}

#define TRACE_VTD_INV_QI_SETUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_QI_SETUP) || \
    false)

static inline void _nocheck__trace_vtd_inv_qi_setup(uint64_t addr, int size)
{
    if (trace_event_get_state(TRACE_VTD_INV_QI_SETUP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 20 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_inv_qi_setup " "addr 0x%"PRIx64" size %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, size);
#line 786 "trace/trace-hw_i386.h"
        } else {
#line 20 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_inv_qi_setup " "addr 0x%"PRIx64" size %d" "\n", addr, size);
#line 790 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_inv_qi_setup(uint64_t addr, int size)
{
    if (true) {
        _nocheck__trace_vtd_inv_qi_setup(addr, size);
    }
}

#define TRACE_VTD_INV_QI_HEAD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_QI_HEAD) || \
    false)

static inline void _nocheck__trace_vtd_inv_qi_head(uint16_t head)
{
    if (trace_event_get_state(TRACE_VTD_INV_QI_HEAD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 21 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_inv_qi_head " "read head %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , head);
#line 817 "trace/trace-hw_i386.h"
        } else {
#line 21 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_inv_qi_head " "read head %d" "\n", head);
#line 821 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_inv_qi_head(uint16_t head)
{
    if (true) {
        _nocheck__trace_vtd_inv_qi_head(head);
    }
}

#define TRACE_VTD_INV_QI_TAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_QI_TAIL) || \
    false)

static inline void _nocheck__trace_vtd_inv_qi_tail(uint16_t head)
{
    if (trace_event_get_state(TRACE_VTD_INV_QI_TAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 22 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_inv_qi_tail " "write tail %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , head);
#line 848 "trace/trace-hw_i386.h"
        } else {
#line 22 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_inv_qi_tail " "write tail %d" "\n", head);
#line 852 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_inv_qi_tail(uint16_t head)
{
    if (true) {
        _nocheck__trace_vtd_inv_qi_tail(head);
    }
}

#define TRACE_VTD_INV_QI_FETCH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_QI_FETCH) || \
    false)

static inline void _nocheck__trace_vtd_inv_qi_fetch(void)
{
    if (trace_event_get_state(TRACE_VTD_INV_QI_FETCH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 23 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_inv_qi_fetch " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 879 "trace/trace-hw_i386.h"
        } else {
#line 23 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_inv_qi_fetch " "" "\n");
#line 883 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_inv_qi_fetch(void)
{
    if (true) {
        _nocheck__trace_vtd_inv_qi_fetch();
    }
}

#define TRACE_VTD_CONTEXT_CACHE_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_CONTEXT_CACHE_RESET) || \
    false)

static inline void _nocheck__trace_vtd_context_cache_reset(void)
{
    if (trace_event_get_state(TRACE_VTD_CONTEXT_CACHE_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 24 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_context_cache_reset " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 910 "trace/trace-hw_i386.h"
        } else {
#line 24 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_context_cache_reset " "" "\n");
#line 914 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_context_cache_reset(void)
{
    if (true) {
        _nocheck__trace_vtd_context_cache_reset();
    }
}

#define TRACE_VTD_RE_NOT_PRESENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_RE_NOT_PRESENT) || \
    false)

static inline void _nocheck__trace_vtd_re_not_present(uint8_t bus)
{
    if (trace_event_get_state(TRACE_VTD_RE_NOT_PRESENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 25 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_re_not_present " "Root entry bus %"PRIu8" not present" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bus);
#line 941 "trace/trace-hw_i386.h"
        } else {
#line 25 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_re_not_present " "Root entry bus %"PRIu8" not present" "\n", bus);
#line 945 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_re_not_present(uint8_t bus)
{
    if (true) {
        _nocheck__trace_vtd_re_not_present(bus);
    }
}

#define TRACE_VTD_CE_NOT_PRESENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_CE_NOT_PRESENT) || \
    false)

static inline void _nocheck__trace_vtd_ce_not_present(uint8_t bus, uint8_t devfn)
{
    if (trace_event_get_state(TRACE_VTD_CE_NOT_PRESENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 26 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_ce_not_present " "Context entry bus %"PRIu8" devfn %"PRIu8" not present" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bus, devfn);
#line 972 "trace/trace-hw_i386.h"
        } else {
#line 26 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_ce_not_present " "Context entry bus %"PRIu8" devfn %"PRIu8" not present" "\n", bus, devfn);
#line 976 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_ce_not_present(uint8_t bus, uint8_t devfn)
{
    if (true) {
        _nocheck__trace_vtd_ce_not_present(bus, devfn);
    }
}

#define TRACE_VTD_IOTLB_PAGE_HIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IOTLB_PAGE_HIT) || \
    false)

static inline void _nocheck__trace_vtd_iotlb_page_hit(uint16_t sid, uint64_t addr, uint64_t slpte, uint16_t domain)
{
    if (trace_event_get_state(TRACE_VTD_IOTLB_PAGE_HIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 27 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_iotlb_page_hit " "IOTLB page hit sid 0x%"PRIx16" iova 0x%"PRIx64" slpte 0x%"PRIx64" domain 0x%"PRIx16 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , sid, addr, slpte, domain);
#line 1003 "trace/trace-hw_i386.h"
        } else {
#line 27 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_iotlb_page_hit " "IOTLB page hit sid 0x%"PRIx16" iova 0x%"PRIx64" slpte 0x%"PRIx64" domain 0x%"PRIx16 "\n", sid, addr, slpte, domain);
#line 1007 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_iotlb_page_hit(uint16_t sid, uint64_t addr, uint64_t slpte, uint16_t domain)
{
    if (true) {
        _nocheck__trace_vtd_iotlb_page_hit(sid, addr, slpte, domain);
    }
}

#define TRACE_VTD_IOTLB_PAGE_UPDATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IOTLB_PAGE_UPDATE) || \
    false)

static inline void _nocheck__trace_vtd_iotlb_page_update(uint16_t sid, uint64_t addr, uint64_t slpte, uint16_t domain)
{
    if (trace_event_get_state(TRACE_VTD_IOTLB_PAGE_UPDATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 28 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_iotlb_page_update " "IOTLB page update sid 0x%"PRIx16" iova 0x%"PRIx64" slpte 0x%"PRIx64" domain 0x%"PRIx16 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , sid, addr, slpte, domain);
#line 1034 "trace/trace-hw_i386.h"
        } else {
#line 28 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_iotlb_page_update " "IOTLB page update sid 0x%"PRIx16" iova 0x%"PRIx64" slpte 0x%"PRIx64" domain 0x%"PRIx16 "\n", sid, addr, slpte, domain);
#line 1038 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_iotlb_page_update(uint16_t sid, uint64_t addr, uint64_t slpte, uint16_t domain)
{
    if (true) {
        _nocheck__trace_vtd_iotlb_page_update(sid, addr, slpte, domain);
    }
}

#define TRACE_VTD_IOTLB_CC_HIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IOTLB_CC_HIT) || \
    false)

static inline void _nocheck__trace_vtd_iotlb_cc_hit(uint8_t bus, uint8_t devfn, uint64_t high, uint64_t low, uint32_t gen)
{
    if (trace_event_get_state(TRACE_VTD_IOTLB_CC_HIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 29 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_iotlb_cc_hit " "IOTLB context hit bus 0x%"PRIx8" devfn 0x%"PRIx8" high 0x%"PRIx64" low 0x%"PRIx64" gen %"PRIu32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bus, devfn, high, low, gen);
#line 1065 "trace/trace-hw_i386.h"
        } else {
#line 29 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_iotlb_cc_hit " "IOTLB context hit bus 0x%"PRIx8" devfn 0x%"PRIx8" high 0x%"PRIx64" low 0x%"PRIx64" gen %"PRIu32 "\n", bus, devfn, high, low, gen);
#line 1069 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_iotlb_cc_hit(uint8_t bus, uint8_t devfn, uint64_t high, uint64_t low, uint32_t gen)
{
    if (true) {
        _nocheck__trace_vtd_iotlb_cc_hit(bus, devfn, high, low, gen);
    }
}

#define TRACE_VTD_IOTLB_CC_UPDATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IOTLB_CC_UPDATE) || \
    false)

static inline void _nocheck__trace_vtd_iotlb_cc_update(uint8_t bus, uint8_t devfn, uint64_t high, uint64_t low, uint32_t gen1, uint32_t gen2)
{
    if (trace_event_get_state(TRACE_VTD_IOTLB_CC_UPDATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 30 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_iotlb_cc_update " "IOTLB context update bus 0x%"PRIx8" devfn 0x%"PRIx8" high 0x%"PRIx64" low 0x%"PRIx64" gen %"PRIu32" -> gen %"PRIu32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bus, devfn, high, low, gen1, gen2);
#line 1096 "trace/trace-hw_i386.h"
        } else {
#line 30 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_iotlb_cc_update " "IOTLB context update bus 0x%"PRIx8" devfn 0x%"PRIx8" high 0x%"PRIx64" low 0x%"PRIx64" gen %"PRIu32" -> gen %"PRIu32 "\n", bus, devfn, high, low, gen1, gen2);
#line 1100 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_iotlb_cc_update(uint8_t bus, uint8_t devfn, uint64_t high, uint64_t low, uint32_t gen1, uint32_t gen2)
{
    if (true) {
        _nocheck__trace_vtd_iotlb_cc_update(bus, devfn, high, low, gen1, gen2);
    }
}

#define TRACE_VTD_IOTLB_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IOTLB_RESET) || \
    false)

static inline void _nocheck__trace_vtd_iotlb_reset(const char * reason)
{
    if (trace_event_get_state(TRACE_VTD_IOTLB_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 31 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_iotlb_reset " "IOTLB reset (reason: %s)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reason);
#line 1127 "trace/trace-hw_i386.h"
        } else {
#line 31 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_iotlb_reset " "IOTLB reset (reason: %s)" "\n", reason);
#line 1131 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_iotlb_reset(const char * reason)
{
    if (true) {
        _nocheck__trace_vtd_iotlb_reset(reason);
    }
}

#define TRACE_VTD_FAULT_DISABLED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_FAULT_DISABLED) || \
    false)

static inline void _nocheck__trace_vtd_fault_disabled(void)
{
    if (trace_event_get_state(TRACE_VTD_FAULT_DISABLED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 32 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_fault_disabled " "Fault processing disabled for context entry" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1158 "trace/trace-hw_i386.h"
        } else {
#line 32 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_fault_disabled " "Fault processing disabled for context entry" "\n");
#line 1162 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_fault_disabled(void)
{
    if (true) {
        _nocheck__trace_vtd_fault_disabled();
    }
}

#define TRACE_VTD_REPLAY_CE_VALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REPLAY_CE_VALID) || \
    false)

static inline void _nocheck__trace_vtd_replay_ce_valid(const char * mode, uint8_t bus, uint8_t dev, uint8_t fn, uint16_t domain, uint64_t hi, uint64_t lo)
{
    if (trace_event_get_state(TRACE_VTD_REPLAY_CE_VALID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 33 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_replay_ce_valid " "%s: replay valid context device %02"PRIx8":%02"PRIx8".%02"PRIx8" domain 0x%"PRIx16" hi 0x%"PRIx64" lo 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , mode, bus, dev, fn, domain, hi, lo);
#line 1189 "trace/trace-hw_i386.h"
        } else {
#line 33 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_replay_ce_valid " "%s: replay valid context device %02"PRIx8":%02"PRIx8".%02"PRIx8" domain 0x%"PRIx16" hi 0x%"PRIx64" lo 0x%"PRIx64 "\n", mode, bus, dev, fn, domain, hi, lo);
#line 1193 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_replay_ce_valid(const char * mode, uint8_t bus, uint8_t dev, uint8_t fn, uint16_t domain, uint64_t hi, uint64_t lo)
{
    if (true) {
        _nocheck__trace_vtd_replay_ce_valid(mode, bus, dev, fn, domain, hi, lo);
    }
}

#define TRACE_VTD_REPLAY_CE_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REPLAY_CE_INVALID) || \
    false)

static inline void _nocheck__trace_vtd_replay_ce_invalid(uint8_t bus, uint8_t dev, uint8_t fn)
{
    if (trace_event_get_state(TRACE_VTD_REPLAY_CE_INVALID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 34 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_replay_ce_invalid " "replay invalid context device %02"PRIx8":%02"PRIx8".%02"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bus, dev, fn);
#line 1220 "trace/trace-hw_i386.h"
        } else {
#line 34 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_replay_ce_invalid " "replay invalid context device %02"PRIx8":%02"PRIx8".%02"PRIx8 "\n", bus, dev, fn);
#line 1224 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_replay_ce_invalid(uint8_t bus, uint8_t dev, uint8_t fn)
{
    if (true) {
        _nocheck__trace_vtd_replay_ce_invalid(bus, dev, fn);
    }
}

#define TRACE_VTD_PAGE_WALK_LEVEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_PAGE_WALK_LEVEL) || \
    false)

static inline void _nocheck__trace_vtd_page_walk_level(uint64_t addr, uint32_t level, uint64_t start, uint64_t end)
{
    if (trace_event_get_state(TRACE_VTD_PAGE_WALK_LEVEL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 35 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_page_walk_level " "walk (base=0x%"PRIx64", level=%"PRIu32") iova range 0x%"PRIx64" - 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, level, start, end);
#line 1251 "trace/trace-hw_i386.h"
        } else {
#line 35 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_page_walk_level " "walk (base=0x%"PRIx64", level=%"PRIu32") iova range 0x%"PRIx64" - 0x%"PRIx64 "\n", addr, level, start, end);
#line 1255 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_page_walk_level(uint64_t addr, uint32_t level, uint64_t start, uint64_t end)
{
    if (true) {
        _nocheck__trace_vtd_page_walk_level(addr, level, start, end);
    }
}

#define TRACE_VTD_PAGE_WALK_ONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_PAGE_WALK_ONE) || \
    false)

static inline void _nocheck__trace_vtd_page_walk_one(uint16_t domain, uint64_t iova, uint64_t gpa, uint64_t mask, int perm)
{
    if (trace_event_get_state(TRACE_VTD_PAGE_WALK_ONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 36 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_page_walk_one " "domain 0x%"PRIx16" iova 0x%"PRIx64" -> gpa 0x%"PRIx64" mask 0x%"PRIx64" perm %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , domain, iova, gpa, mask, perm);
#line 1282 "trace/trace-hw_i386.h"
        } else {
#line 36 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_page_walk_one " "domain 0x%"PRIx16" iova 0x%"PRIx64" -> gpa 0x%"PRIx64" mask 0x%"PRIx64" perm %d" "\n", domain, iova, gpa, mask, perm);
#line 1286 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_page_walk_one(uint16_t domain, uint64_t iova, uint64_t gpa, uint64_t mask, int perm)
{
    if (true) {
        _nocheck__trace_vtd_page_walk_one(domain, iova, gpa, mask, perm);
    }
}

#define TRACE_VTD_PAGE_WALK_ONE_SKIP_MAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_PAGE_WALK_ONE_SKIP_MAP) || \
    false)

static inline void _nocheck__trace_vtd_page_walk_one_skip_map(uint64_t iova, uint64_t mask, uint64_t translated)
{
    if (trace_event_get_state(TRACE_VTD_PAGE_WALK_ONE_SKIP_MAP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 37 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_page_walk_one_skip_map " "iova 0x%"PRIx64" mask 0x%"PRIx64" translated 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , iova, mask, translated);
#line 1313 "trace/trace-hw_i386.h"
        } else {
#line 37 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_page_walk_one_skip_map " "iova 0x%"PRIx64" mask 0x%"PRIx64" translated 0x%"PRIx64 "\n", iova, mask, translated);
#line 1317 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_page_walk_one_skip_map(uint64_t iova, uint64_t mask, uint64_t translated)
{
    if (true) {
        _nocheck__trace_vtd_page_walk_one_skip_map(iova, mask, translated);
    }
}

#define TRACE_VTD_PAGE_WALK_ONE_SKIP_UNMAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_PAGE_WALK_ONE_SKIP_UNMAP) || \
    false)

static inline void _nocheck__trace_vtd_page_walk_one_skip_unmap(uint64_t iova, uint64_t mask)
{
    if (trace_event_get_state(TRACE_VTD_PAGE_WALK_ONE_SKIP_UNMAP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 38 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_page_walk_one_skip_unmap " "iova 0x%"PRIx64" mask 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , iova, mask);
#line 1344 "trace/trace-hw_i386.h"
        } else {
#line 38 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_page_walk_one_skip_unmap " "iova 0x%"PRIx64" mask 0x%"PRIx64 "\n", iova, mask);
#line 1348 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_page_walk_one_skip_unmap(uint64_t iova, uint64_t mask)
{
    if (true) {
        _nocheck__trace_vtd_page_walk_one_skip_unmap(iova, mask);
    }
}

#define TRACE_VTD_PAGE_WALK_SKIP_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_PAGE_WALK_SKIP_READ) || \
    false)

static inline void _nocheck__trace_vtd_page_walk_skip_read(uint64_t iova, uint64_t next)
{
    if (trace_event_get_state(TRACE_VTD_PAGE_WALK_SKIP_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 39 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_page_walk_skip_read " "Page walk skip iova 0x%"PRIx64" - 0x%"PRIx64" due to unable to read" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , iova, next);
#line 1375 "trace/trace-hw_i386.h"
        } else {
#line 39 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_page_walk_skip_read " "Page walk skip iova 0x%"PRIx64" - 0x%"PRIx64" due to unable to read" "\n", iova, next);
#line 1379 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_page_walk_skip_read(uint64_t iova, uint64_t next)
{
    if (true) {
        _nocheck__trace_vtd_page_walk_skip_read(iova, next);
    }
}

#define TRACE_VTD_PAGE_WALK_SKIP_RESERVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_PAGE_WALK_SKIP_RESERVE) || \
    false)

static inline void _nocheck__trace_vtd_page_walk_skip_reserve(uint64_t iova, uint64_t next)
{
    if (trace_event_get_state(TRACE_VTD_PAGE_WALK_SKIP_RESERVE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 40 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_page_walk_skip_reserve " "Page walk skip iova 0x%"PRIx64" - 0x%"PRIx64" due to rsrv set" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , iova, next);
#line 1406 "trace/trace-hw_i386.h"
        } else {
#line 40 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_page_walk_skip_reserve " "Page walk skip iova 0x%"PRIx64" - 0x%"PRIx64" due to rsrv set" "\n", iova, next);
#line 1410 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_page_walk_skip_reserve(uint64_t iova, uint64_t next)
{
    if (true) {
        _nocheck__trace_vtd_page_walk_skip_reserve(iova, next);
    }
}

#define TRACE_VTD_SWITCH_ADDRESS_SPACE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_SWITCH_ADDRESS_SPACE) || \
    false)

static inline void _nocheck__trace_vtd_switch_address_space(uint8_t bus, uint8_t slot, uint8_t fn, bool on)
{
    if (trace_event_get_state(TRACE_VTD_SWITCH_ADDRESS_SPACE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 41 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_switch_address_space " "Device %02x:%02x.%x switching address space (iommu enabled=%d)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bus, slot, fn, on);
#line 1437 "trace/trace-hw_i386.h"
        } else {
#line 41 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_switch_address_space " "Device %02x:%02x.%x switching address space (iommu enabled=%d)" "\n", bus, slot, fn, on);
#line 1441 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_switch_address_space(uint8_t bus, uint8_t slot, uint8_t fn, bool on)
{
    if (true) {
        _nocheck__trace_vtd_switch_address_space(bus, slot, fn, on);
    }
}

#define TRACE_VTD_AS_UNMAP_WHOLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_AS_UNMAP_WHOLE) || \
    false)

static inline void _nocheck__trace_vtd_as_unmap_whole(uint8_t bus, uint8_t slot, uint8_t fn, uint64_t iova, uint64_t size)
{
    if (trace_event_get_state(TRACE_VTD_AS_UNMAP_WHOLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 42 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_as_unmap_whole " "Device %02x:%02x.%x start 0x%"PRIx64" size 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bus, slot, fn, iova, size);
#line 1468 "trace/trace-hw_i386.h"
        } else {
#line 42 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_as_unmap_whole " "Device %02x:%02x.%x start 0x%"PRIx64" size 0x%"PRIx64 "\n", bus, slot, fn, iova, size);
#line 1472 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_as_unmap_whole(uint8_t bus, uint8_t slot, uint8_t fn, uint64_t iova, uint64_t size)
{
    if (true) {
        _nocheck__trace_vtd_as_unmap_whole(bus, slot, fn, iova, size);
    }
}

#define TRACE_VTD_TRANSLATE_PT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_TRANSLATE_PT) || \
    false)

static inline void _nocheck__trace_vtd_translate_pt(uint16_t sid, uint64_t addr)
{
    if (trace_event_get_state(TRACE_VTD_TRANSLATE_PT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 43 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_translate_pt " "source id 0x%"PRIx16", iova 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , sid, addr);
#line 1499 "trace/trace-hw_i386.h"
        } else {
#line 43 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_translate_pt " "source id 0x%"PRIx16", iova 0x%"PRIx64 "\n", sid, addr);
#line 1503 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_translate_pt(uint16_t sid, uint64_t addr)
{
    if (true) {
        _nocheck__trace_vtd_translate_pt(sid, addr);
    }
}

#define TRACE_VTD_PT_ENABLE_FAST_PATH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_PT_ENABLE_FAST_PATH) || \
    false)

static inline void _nocheck__trace_vtd_pt_enable_fast_path(uint16_t sid, bool success)
{
    if (trace_event_get_state(TRACE_VTD_PT_ENABLE_FAST_PATH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 44 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_pt_enable_fast_path " "sid 0x%"PRIx16" %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , sid, success);
#line 1530 "trace/trace-hw_i386.h"
        } else {
#line 44 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_pt_enable_fast_path " "sid 0x%"PRIx16" %d" "\n", sid, success);
#line 1534 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_pt_enable_fast_path(uint16_t sid, bool success)
{
    if (true) {
        _nocheck__trace_vtd_pt_enable_fast_path(sid, success);
    }
}

#define TRACE_VTD_IRQ_GENERATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IRQ_GENERATE) || \
    false)

static inline void _nocheck__trace_vtd_irq_generate(uint64_t addr, uint64_t data)
{
    if (trace_event_get_state(TRACE_VTD_IRQ_GENERATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 45 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_irq_generate " "addr 0x%"PRIx64" data 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, data);
#line 1561 "trace/trace-hw_i386.h"
        } else {
#line 45 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_irq_generate " "addr 0x%"PRIx64" data 0x%"PRIx64 "\n", addr, data);
#line 1565 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_irq_generate(uint64_t addr, uint64_t data)
{
    if (true) {
        _nocheck__trace_vtd_irq_generate(addr, data);
    }
}

#define TRACE_VTD_REG_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REG_READ) || \
    false)

static inline void _nocheck__trace_vtd_reg_read(uint64_t addr, uint64_t size)
{
    if (trace_event_get_state(TRACE_VTD_REG_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 46 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_reg_read " "addr 0x%"PRIx64" size 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, size);
#line 1592 "trace/trace-hw_i386.h"
        } else {
#line 46 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_reg_read " "addr 0x%"PRIx64" size 0x%"PRIx64 "\n", addr, size);
#line 1596 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_reg_read(uint64_t addr, uint64_t size)
{
    if (true) {
        _nocheck__trace_vtd_reg_read(addr, size);
    }
}

#define TRACE_VTD_REG_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REG_WRITE) || \
    false)

static inline void _nocheck__trace_vtd_reg_write(uint64_t addr, uint64_t size, uint64_t val)
{
    if (trace_event_get_state(TRACE_VTD_REG_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 47 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_reg_write " "addr 0x%"PRIx64" size 0x%"PRIx64" value 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, size, val);
#line 1623 "trace/trace-hw_i386.h"
        } else {
#line 47 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_reg_write " "addr 0x%"PRIx64" size 0x%"PRIx64" value 0x%"PRIx64 "\n", addr, size, val);
#line 1627 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_reg_write(uint64_t addr, uint64_t size, uint64_t val)
{
    if (true) {
        _nocheck__trace_vtd_reg_write(addr, size, val);
    }
}

#define TRACE_VTD_REG_DMAR_ROOT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REG_DMAR_ROOT) || \
    false)

static inline void _nocheck__trace_vtd_reg_dmar_root(uint64_t addr, bool scalable)
{
    if (trace_event_get_state(TRACE_VTD_REG_DMAR_ROOT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 48 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_reg_dmar_root " "addr 0x%"PRIx64" scalable %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, scalable);
#line 1654 "trace/trace-hw_i386.h"
        } else {
#line 48 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_reg_dmar_root " "addr 0x%"PRIx64" scalable %d" "\n", addr, scalable);
#line 1658 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_reg_dmar_root(uint64_t addr, bool scalable)
{
    if (true) {
        _nocheck__trace_vtd_reg_dmar_root(addr, scalable);
    }
}

#define TRACE_VTD_REG_IR_ROOT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REG_IR_ROOT) || \
    false)

static inline void _nocheck__trace_vtd_reg_ir_root(uint64_t addr, uint32_t size)
{
    if (trace_event_get_state(TRACE_VTD_REG_IR_ROOT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 49 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_reg_ir_root " "addr 0x%"PRIx64" size 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, size);
#line 1685 "trace/trace-hw_i386.h"
        } else {
#line 49 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_reg_ir_root " "addr 0x%"PRIx64" size 0x%"PRIx32 "\n", addr, size);
#line 1689 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_reg_ir_root(uint64_t addr, uint32_t size)
{
    if (true) {
        _nocheck__trace_vtd_reg_ir_root(addr, size);
    }
}

#define TRACE_VTD_REG_WRITE_GCMD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REG_WRITE_GCMD) || \
    false)

static inline void _nocheck__trace_vtd_reg_write_gcmd(uint32_t status, uint32_t val)
{
    if (trace_event_get_state(TRACE_VTD_REG_WRITE_GCMD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 50 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_reg_write_gcmd " "status 0x%"PRIx32" value 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , status, val);
#line 1716 "trace/trace-hw_i386.h"
        } else {
#line 50 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_reg_write_gcmd " "status 0x%"PRIx32" value 0x%"PRIx32 "\n", status, val);
#line 1720 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_reg_write_gcmd(uint32_t status, uint32_t val)
{
    if (true) {
        _nocheck__trace_vtd_reg_write_gcmd(status, val);
    }
}

#define TRACE_VTD_REG_WRITE_FECTL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REG_WRITE_FECTL) || \
    false)

static inline void _nocheck__trace_vtd_reg_write_fectl(uint32_t value)
{
    if (trace_event_get_state(TRACE_VTD_REG_WRITE_FECTL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 51 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_reg_write_fectl " "value 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , value);
#line 1747 "trace/trace-hw_i386.h"
        } else {
#line 51 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_reg_write_fectl " "value 0x%"PRIx32 "\n", value);
#line 1751 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_reg_write_fectl(uint32_t value)
{
    if (true) {
        _nocheck__trace_vtd_reg_write_fectl(value);
    }
}

#define TRACE_VTD_REG_WRITE_IECTL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REG_WRITE_IECTL) || \
    false)

static inline void _nocheck__trace_vtd_reg_write_iectl(uint32_t value)
{
    if (trace_event_get_state(TRACE_VTD_REG_WRITE_IECTL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 52 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_reg_write_iectl " "value 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , value);
#line 1778 "trace/trace-hw_i386.h"
        } else {
#line 52 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_reg_write_iectl " "value 0x%"PRIx32 "\n", value);
#line 1782 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_reg_write_iectl(uint32_t value)
{
    if (true) {
        _nocheck__trace_vtd_reg_write_iectl(value);
    }
}

#define TRACE_VTD_REG_ICS_CLEAR_IP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REG_ICS_CLEAR_IP) || \
    false)

static inline void _nocheck__trace_vtd_reg_ics_clear_ip(void)
{
    if (trace_event_get_state(TRACE_VTD_REG_ICS_CLEAR_IP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 53 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_reg_ics_clear_ip " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1809 "trace/trace-hw_i386.h"
        } else {
#line 53 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_reg_ics_clear_ip " "" "\n");
#line 1813 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_reg_ics_clear_ip(void)
{
    if (true) {
        _nocheck__trace_vtd_reg_ics_clear_ip();
    }
}

#define TRACE_VTD_DMAR_TRANSLATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_DMAR_TRANSLATE) || \
    false)

static inline void _nocheck__trace_vtd_dmar_translate(uint8_t bus, uint8_t slot, uint8_t func, uint64_t iova, uint64_t gpa, uint64_t mask)
{
    if (trace_event_get_state(TRACE_VTD_DMAR_TRANSLATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 54 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_dmar_translate " "dev %02x:%02x.%02x iova 0x%"PRIx64" -> gpa 0x%"PRIx64" mask 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bus, slot, func, iova, gpa, mask);
#line 1840 "trace/trace-hw_i386.h"
        } else {
#line 54 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_dmar_translate " "dev %02x:%02x.%02x iova 0x%"PRIx64" -> gpa 0x%"PRIx64" mask 0x%"PRIx64 "\n", bus, slot, func, iova, gpa, mask);
#line 1844 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_dmar_translate(uint8_t bus, uint8_t slot, uint8_t func, uint64_t iova, uint64_t gpa, uint64_t mask)
{
    if (true) {
        _nocheck__trace_vtd_dmar_translate(bus, slot, func, iova, gpa, mask);
    }
}

#define TRACE_VTD_DMAR_ENABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_DMAR_ENABLE) || \
    false)

static inline void _nocheck__trace_vtd_dmar_enable(bool en)
{
    if (trace_event_get_state(TRACE_VTD_DMAR_ENABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 55 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_dmar_enable " "enable %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , en);
#line 1871 "trace/trace-hw_i386.h"
        } else {
#line 55 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_dmar_enable " "enable %d" "\n", en);
#line 1875 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_dmar_enable(bool en)
{
    if (true) {
        _nocheck__trace_vtd_dmar_enable(en);
    }
}

#define TRACE_VTD_DMAR_FAULT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_DMAR_FAULT) || \
    false)

static inline void _nocheck__trace_vtd_dmar_fault(uint16_t sid, int fault, uint64_t addr, bool is_write)
{
    if (trace_event_get_state(TRACE_VTD_DMAR_FAULT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 56 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_dmar_fault " "sid 0x%"PRIx16" fault %d addr 0x%"PRIx64" write %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , sid, fault, addr, is_write);
#line 1902 "trace/trace-hw_i386.h"
        } else {
#line 56 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_dmar_fault " "sid 0x%"PRIx16" fault %d addr 0x%"PRIx64" write %d" "\n", sid, fault, addr, is_write);
#line 1906 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_dmar_fault(uint16_t sid, int fault, uint64_t addr, bool is_write)
{
    if (true) {
        _nocheck__trace_vtd_dmar_fault(sid, fault, addr, is_write);
    }
}

#define TRACE_VTD_IR_ENABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IR_ENABLE) || \
    false)

static inline void _nocheck__trace_vtd_ir_enable(bool en)
{
    if (trace_event_get_state(TRACE_VTD_IR_ENABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 57 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_ir_enable " "enable %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , en);
#line 1933 "trace/trace-hw_i386.h"
        } else {
#line 57 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_ir_enable " "enable %d" "\n", en);
#line 1937 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_ir_enable(bool en)
{
    if (true) {
        _nocheck__trace_vtd_ir_enable(en);
    }
}

#define TRACE_VTD_IR_IRTE_GET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IR_IRTE_GET) || \
    false)

static inline void _nocheck__trace_vtd_ir_irte_get(int index, uint64_t lo, uint64_t hi)
{
    if (trace_event_get_state(TRACE_VTD_IR_IRTE_GET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 58 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_ir_irte_get " "index %d low 0x%"PRIx64" high 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index, lo, hi);
#line 1964 "trace/trace-hw_i386.h"
        } else {
#line 58 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_ir_irte_get " "index %d low 0x%"PRIx64" high 0x%"PRIx64 "\n", index, lo, hi);
#line 1968 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_ir_irte_get(int index, uint64_t lo, uint64_t hi)
{
    if (true) {
        _nocheck__trace_vtd_ir_irte_get(index, lo, hi);
    }
}

#define TRACE_VTD_IR_REMAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IR_REMAP) || \
    false)

static inline void _nocheck__trace_vtd_ir_remap(int index, int tri, int vec, int deliver, uint32_t dest, int dest_mode)
{
    if (trace_event_get_state(TRACE_VTD_IR_REMAP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 59 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_ir_remap " "index %d trigger %d vector %d deliver %d dest 0x%"PRIx32" mode %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index, tri, vec, deliver, dest, dest_mode);
#line 1995 "trace/trace-hw_i386.h"
        } else {
#line 59 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_ir_remap " "index %d trigger %d vector %d deliver %d dest 0x%"PRIx32" mode %d" "\n", index, tri, vec, deliver, dest, dest_mode);
#line 1999 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_ir_remap(int index, int tri, int vec, int deliver, uint32_t dest, int dest_mode)
{
    if (true) {
        _nocheck__trace_vtd_ir_remap(index, tri, vec, deliver, dest, dest_mode);
    }
}

#define TRACE_VTD_IR_REMAP_TYPE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IR_REMAP_TYPE) || \
    false)

static inline void _nocheck__trace_vtd_ir_remap_type(const char * type)
{
    if (trace_event_get_state(TRACE_VTD_IR_REMAP_TYPE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 60 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_ir_remap_type " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type);
#line 2026 "trace/trace-hw_i386.h"
        } else {
#line 60 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_ir_remap_type " "%s" "\n", type);
#line 2030 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_ir_remap_type(const char * type)
{
    if (true) {
        _nocheck__trace_vtd_ir_remap_type(type);
    }
}

#define TRACE_VTD_IR_REMAP_MSI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IR_REMAP_MSI) || \
    false)

static inline void _nocheck__trace_vtd_ir_remap_msi(uint64_t addr, uint64_t data, uint64_t addr2, uint64_t data2)
{
    if (trace_event_get_state(TRACE_VTD_IR_REMAP_MSI) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 61 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_ir_remap_msi " "(addr 0x%"PRIx64", data 0x%"PRIx64") -> (addr 0x%"PRIx64", data 0x%"PRIx64")" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, data, addr2, data2);
#line 2057 "trace/trace-hw_i386.h"
        } else {
#line 61 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_ir_remap_msi " "(addr 0x%"PRIx64", data 0x%"PRIx64") -> (addr 0x%"PRIx64", data 0x%"PRIx64")" "\n", addr, data, addr2, data2);
#line 2061 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_ir_remap_msi(uint64_t addr, uint64_t data, uint64_t addr2, uint64_t data2)
{
    if (true) {
        _nocheck__trace_vtd_ir_remap_msi(addr, data, addr2, data2);
    }
}

#define TRACE_VTD_IR_REMAP_MSI_REQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IR_REMAP_MSI_REQ) || \
    false)

static inline void _nocheck__trace_vtd_ir_remap_msi_req(uint64_t addr, uint64_t data)
{
    if (trace_event_get_state(TRACE_VTD_IR_REMAP_MSI_REQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 62 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_ir_remap_msi_req " "addr 0x%"PRIx64" data 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, data);
#line 2088 "trace/trace-hw_i386.h"
        } else {
#line 62 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_ir_remap_msi_req " "addr 0x%"PRIx64" data 0x%"PRIx64 "\n", addr, data);
#line 2092 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_ir_remap_msi_req(uint64_t addr, uint64_t data)
{
    if (true) {
        _nocheck__trace_vtd_ir_remap_msi_req(addr, data);
    }
}

#define TRACE_VTD_FSTS_PPF_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_FSTS_PPF) || \
    false)

static inline void _nocheck__trace_vtd_fsts_ppf(bool set)
{
    if (trace_event_get_state(TRACE_VTD_FSTS_PPF) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 63 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_fsts_ppf " "FSTS PPF bit set to %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , set);
#line 2119 "trace/trace-hw_i386.h"
        } else {
#line 63 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_fsts_ppf " "FSTS PPF bit set to %d" "\n", set);
#line 2123 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_fsts_ppf(bool set)
{
    if (true) {
        _nocheck__trace_vtd_fsts_ppf(set);
    }
}

#define TRACE_VTD_FSTS_CLEAR_IP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_FSTS_CLEAR_IP) || \
    false)

static inline void _nocheck__trace_vtd_fsts_clear_ip(void)
{
    if (trace_event_get_state(TRACE_VTD_FSTS_CLEAR_IP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 64 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_fsts_clear_ip " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2150 "trace/trace-hw_i386.h"
        } else {
#line 64 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_fsts_clear_ip " "" "\n");
#line 2154 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_fsts_clear_ip(void)
{
    if (true) {
        _nocheck__trace_vtd_fsts_clear_ip();
    }
}

#define TRACE_VTD_FRR_NEW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_FRR_NEW) || \
    false)

static inline void _nocheck__trace_vtd_frr_new(int index, uint64_t hi, uint64_t lo)
{
    if (trace_event_get_state(TRACE_VTD_FRR_NEW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 65 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_frr_new " "index %d high 0x%"PRIx64" low 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index, hi, lo);
#line 2181 "trace/trace-hw_i386.h"
        } else {
#line 65 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_frr_new " "index %d high 0x%"PRIx64" low 0x%"PRIx64 "\n", index, hi, lo);
#line 2185 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_frr_new(int index, uint64_t hi, uint64_t lo)
{
    if (true) {
        _nocheck__trace_vtd_frr_new(index, hi, lo);
    }
}

#define TRACE_VTD_WARN_INVALID_QI_TAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_WARN_INVALID_QI_TAIL) || \
    false)

static inline void _nocheck__trace_vtd_warn_invalid_qi_tail(uint16_t tail)
{
    if (trace_event_get_state(TRACE_VTD_WARN_INVALID_QI_TAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 66 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_warn_invalid_qi_tail " "tail 0x%"PRIx16 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tail);
#line 2212 "trace/trace-hw_i386.h"
        } else {
#line 66 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_warn_invalid_qi_tail " "tail 0x%"PRIx16 "\n", tail);
#line 2216 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_warn_invalid_qi_tail(uint16_t tail)
{
    if (true) {
        _nocheck__trace_vtd_warn_invalid_qi_tail(tail);
    }
}

#define TRACE_VTD_WARN_IR_VECTOR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_WARN_IR_VECTOR) || \
    false)

static inline void _nocheck__trace_vtd_warn_ir_vector(uint16_t sid, int index, int vec, int target)
{
    if (trace_event_get_state(TRACE_VTD_WARN_IR_VECTOR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 67 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_warn_ir_vector " "sid 0x%"PRIx16" index %d vec %d (should be: %d)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , sid, index, vec, target);
#line 2243 "trace/trace-hw_i386.h"
        } else {
#line 67 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_warn_ir_vector " "sid 0x%"PRIx16" index %d vec %d (should be: %d)" "\n", sid, index, vec, target);
#line 2247 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_warn_ir_vector(uint16_t sid, int index, int vec, int target)
{
    if (true) {
        _nocheck__trace_vtd_warn_ir_vector(sid, index, vec, target);
    }
}

#define TRACE_VTD_WARN_IR_TRIGGER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_WARN_IR_TRIGGER) || \
    false)

static inline void _nocheck__trace_vtd_warn_ir_trigger(uint16_t sid, int index, int trig, int target)
{
    if (trace_event_get_state(TRACE_VTD_WARN_IR_TRIGGER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 68 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vtd_warn_ir_trigger " "sid 0x%"PRIx16" index %d trigger %d (should be: %d)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , sid, index, trig, target);
#line 2274 "trace/trace-hw_i386.h"
        } else {
#line 68 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vtd_warn_ir_trigger " "sid 0x%"PRIx16" index %d trigger %d (should be: %d)" "\n", sid, index, trig, target);
#line 2278 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vtd_warn_ir_trigger(uint16_t sid, int index, int trig, int target)
{
    if (true) {
        _nocheck__trace_vtd_warn_ir_trigger(sid, index, trig, target);
    }
}

#define TRACE_AMDVI_EVNTLOG_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_EVNTLOG_FAIL) || \
    false)

static inline void _nocheck__trace_amdvi_evntlog_fail(uint64_t addr, uint32_t head)
{
    if (trace_event_get_state(TRACE_AMDVI_EVNTLOG_FAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 71 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_evntlog_fail " "error: fail to write at addr 0x%"PRIx64" +  offset 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, head);
#line 2305 "trace/trace-hw_i386.h"
        } else {
#line 71 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_evntlog_fail " "error: fail to write at addr 0x%"PRIx64" +  offset 0x%"PRIx32 "\n", addr, head);
#line 2309 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_evntlog_fail(uint64_t addr, uint32_t head)
{
    if (true) {
        _nocheck__trace_amdvi_evntlog_fail(addr, head);
    }
}

#define TRACE_AMDVI_CACHE_UPDATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_CACHE_UPDATE) || \
    false)

static inline void _nocheck__trace_amdvi_cache_update(uint16_t domid, uint8_t bus, uint8_t slot, uint8_t func, uint64_t gpa, uint64_t txaddr)
{
    if (trace_event_get_state(TRACE_AMDVI_CACHE_UPDATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 72 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_cache_update " " update iotlb domid 0x%"PRIx16" devid: %02x:%02x.%x gpa 0x%"PRIx64" hpa 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , domid, bus, slot, func, gpa, txaddr);
#line 2336 "trace/trace-hw_i386.h"
        } else {
#line 72 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_cache_update " " update iotlb domid 0x%"PRIx16" devid: %02x:%02x.%x gpa 0x%"PRIx64" hpa 0x%"PRIx64 "\n", domid, bus, slot, func, gpa, txaddr);
#line 2340 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_cache_update(uint16_t domid, uint8_t bus, uint8_t slot, uint8_t func, uint64_t gpa, uint64_t txaddr)
{
    if (true) {
        _nocheck__trace_amdvi_cache_update(domid, bus, slot, func, gpa, txaddr);
    }
}

#define TRACE_AMDVI_COMPLETION_WAIT_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_COMPLETION_WAIT_FAIL) || \
    false)

static inline void _nocheck__trace_amdvi_completion_wait_fail(uint64_t addr)
{
    if (trace_event_get_state(TRACE_AMDVI_COMPLETION_WAIT_FAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 73 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_completion_wait_fail " "error: fail to write at address 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 2367 "trace/trace-hw_i386.h"
        } else {
#line 73 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_completion_wait_fail " "error: fail to write at address 0x%"PRIx64 "\n", addr);
#line 2371 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_completion_wait_fail(uint64_t addr)
{
    if (true) {
        _nocheck__trace_amdvi_completion_wait_fail(addr);
    }
}

#define TRACE_AMDVI_MMIO_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_MMIO_WRITE) || \
    false)

static inline void _nocheck__trace_amdvi_mmio_write(const char * reg, uint64_t addr, unsigned size, uint64_t val, uint64_t offset)
{
    if (trace_event_get_state(TRACE_AMDVI_MMIO_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 74 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_mmio_write " "%s write addr 0x%"PRIx64", size %u, val 0x%"PRIx64", offset 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reg, addr, size, val, offset);
#line 2398 "trace/trace-hw_i386.h"
        } else {
#line 74 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_mmio_write " "%s write addr 0x%"PRIx64", size %u, val 0x%"PRIx64", offset 0x%"PRIx64 "\n", reg, addr, size, val, offset);
#line 2402 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_mmio_write(const char * reg, uint64_t addr, unsigned size, uint64_t val, uint64_t offset)
{
    if (true) {
        _nocheck__trace_amdvi_mmio_write(reg, addr, size, val, offset);
    }
}

#define TRACE_AMDVI_MMIO_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_MMIO_READ) || \
    false)

static inline void _nocheck__trace_amdvi_mmio_read(const char * reg, uint64_t addr, unsigned size, uint64_t offset)
{
    if (trace_event_get_state(TRACE_AMDVI_MMIO_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 75 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_mmio_read " "%s read addr 0x%"PRIx64", size %u offset 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reg, addr, size, offset);
#line 2429 "trace/trace-hw_i386.h"
        } else {
#line 75 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_mmio_read " "%s read addr 0x%"PRIx64", size %u offset 0x%"PRIx64 "\n", reg, addr, size, offset);
#line 2433 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_mmio_read(const char * reg, uint64_t addr, unsigned size, uint64_t offset)
{
    if (true) {
        _nocheck__trace_amdvi_mmio_read(reg, addr, size, offset);
    }
}

#define TRACE_AMDVI_MMIO_READ_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_MMIO_READ_INVALID) || \
    false)

static inline void _nocheck__trace_amdvi_mmio_read_invalid(int max, uint64_t addr, unsigned size)
{
    if (trace_event_get_state(TRACE_AMDVI_MMIO_READ_INVALID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 76 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_mmio_read_invalid " "error: addr outside region (max 0x%x): read addr 0x%" PRIx64 ", size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , max, addr, size);
#line 2460 "trace/trace-hw_i386.h"
        } else {
#line 76 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_mmio_read_invalid " "error: addr outside region (max 0x%x): read addr 0x%" PRIx64 ", size %u" "\n", max, addr, size);
#line 2464 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_mmio_read_invalid(int max, uint64_t addr, unsigned size)
{
    if (true) {
        _nocheck__trace_amdvi_mmio_read_invalid(max, addr, size);
    }
}

#define TRACE_AMDVI_COMMAND_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_COMMAND_ERROR) || \
    false)

static inline void _nocheck__trace_amdvi_command_error(uint64_t status)
{
    if (trace_event_get_state(TRACE_AMDVI_COMMAND_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 77 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_command_error " "error: Executing commands with command buffer disabled 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , status);
#line 2491 "trace/trace-hw_i386.h"
        } else {
#line 77 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_command_error " "error: Executing commands with command buffer disabled 0x%"PRIx64 "\n", status);
#line 2495 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_command_error(uint64_t status)
{
    if (true) {
        _nocheck__trace_amdvi_command_error(status);
    }
}

#define TRACE_AMDVI_COMMAND_READ_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_COMMAND_READ_FAIL) || \
    false)

static inline void _nocheck__trace_amdvi_command_read_fail(uint64_t addr, uint32_t head)
{
    if (trace_event_get_state(TRACE_AMDVI_COMMAND_READ_FAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 78 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_command_read_fail " "error: fail to access memory at 0x%"PRIx64" + 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, head);
#line 2522 "trace/trace-hw_i386.h"
        } else {
#line 78 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_command_read_fail " "error: fail to access memory at 0x%"PRIx64" + 0x%"PRIx32 "\n", addr, head);
#line 2526 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_command_read_fail(uint64_t addr, uint32_t head)
{
    if (true) {
        _nocheck__trace_amdvi_command_read_fail(addr, head);
    }
}

#define TRACE_AMDVI_COMMAND_EXEC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_COMMAND_EXEC) || \
    false)

static inline void _nocheck__trace_amdvi_command_exec(uint32_t head, uint32_t tail, uint64_t buf)
{
    if (trace_event_get_state(TRACE_AMDVI_COMMAND_EXEC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 79 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_command_exec " "command buffer head at 0x%"PRIx32" command buffer tail at 0x%"PRIx32" command buffer base at 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , head, tail, buf);
#line 2553 "trace/trace-hw_i386.h"
        } else {
#line 79 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_command_exec " "command buffer head at 0x%"PRIx32" command buffer tail at 0x%"PRIx32" command buffer base at 0x%"PRIx64 "\n", head, tail, buf);
#line 2557 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_command_exec(uint32_t head, uint32_t tail, uint64_t buf)
{
    if (true) {
        _nocheck__trace_amdvi_command_exec(head, tail, buf);
    }
}

#define TRACE_AMDVI_UNHANDLED_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_UNHANDLED_COMMAND) || \
    false)

static inline void _nocheck__trace_amdvi_unhandled_command(uint8_t type)
{
    if (trace_event_get_state(TRACE_AMDVI_UNHANDLED_COMMAND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 80 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_unhandled_command " "unhandled command 0x%"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type);
#line 2584 "trace/trace-hw_i386.h"
        } else {
#line 80 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_unhandled_command " "unhandled command 0x%"PRIx8 "\n", type);
#line 2588 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_unhandled_command(uint8_t type)
{
    if (true) {
        _nocheck__trace_amdvi_unhandled_command(type);
    }
}

#define TRACE_AMDVI_INTR_INVAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_INTR_INVAL) || \
    false)

static inline void _nocheck__trace_amdvi_intr_inval(void)
{
    if (trace_event_get_state(TRACE_AMDVI_INTR_INVAL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 81 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_intr_inval " "Interrupt table invalidated" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2615 "trace/trace-hw_i386.h"
        } else {
#line 81 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_intr_inval " "Interrupt table invalidated" "\n");
#line 2619 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_intr_inval(void)
{
    if (true) {
        _nocheck__trace_amdvi_intr_inval();
    }
}

#define TRACE_AMDVI_IOTLB_INVAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IOTLB_INVAL) || \
    false)

static inline void _nocheck__trace_amdvi_iotlb_inval(void)
{
    if (trace_event_get_state(TRACE_AMDVI_IOTLB_INVAL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 82 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_iotlb_inval " "IOTLB pages invalidated" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2646 "trace/trace-hw_i386.h"
        } else {
#line 82 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_iotlb_inval " "IOTLB pages invalidated" "\n");
#line 2650 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_iotlb_inval(void)
{
    if (true) {
        _nocheck__trace_amdvi_iotlb_inval();
    }
}

#define TRACE_AMDVI_PREFETCH_PAGES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_PREFETCH_PAGES) || \
    false)

static inline void _nocheck__trace_amdvi_prefetch_pages(void)
{
    if (trace_event_get_state(TRACE_AMDVI_PREFETCH_PAGES) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 83 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_prefetch_pages " "Pre-fetch of AMD-Vi pages requested" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2677 "trace/trace-hw_i386.h"
        } else {
#line 83 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_prefetch_pages " "Pre-fetch of AMD-Vi pages requested" "\n");
#line 2681 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_prefetch_pages(void)
{
    if (true) {
        _nocheck__trace_amdvi_prefetch_pages();
    }
}

#define TRACE_AMDVI_PAGES_INVAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_PAGES_INVAL) || \
    false)

static inline void _nocheck__trace_amdvi_pages_inval(uint16_t domid)
{
    if (trace_event_get_state(TRACE_AMDVI_PAGES_INVAL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 84 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_pages_inval " "AMD-Vi pages for domain 0x%"PRIx16 " invalidated" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , domid);
#line 2708 "trace/trace-hw_i386.h"
        } else {
#line 84 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_pages_inval " "AMD-Vi pages for domain 0x%"PRIx16 " invalidated" "\n", domid);
#line 2712 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_pages_inval(uint16_t domid)
{
    if (true) {
        _nocheck__trace_amdvi_pages_inval(domid);
    }
}

#define TRACE_AMDVI_ALL_INVAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_ALL_INVAL) || \
    false)

static inline void _nocheck__trace_amdvi_all_inval(void)
{
    if (trace_event_get_state(TRACE_AMDVI_ALL_INVAL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 85 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_all_inval " "Invalidation of all AMD-Vi cache requested " "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2739 "trace/trace-hw_i386.h"
        } else {
#line 85 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_all_inval " "Invalidation of all AMD-Vi cache requested " "\n");
#line 2743 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_all_inval(void)
{
    if (true) {
        _nocheck__trace_amdvi_all_inval();
    }
}

#define TRACE_AMDVI_PPR_EXEC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_PPR_EXEC) || \
    false)

static inline void _nocheck__trace_amdvi_ppr_exec(void)
{
    if (trace_event_get_state(TRACE_AMDVI_PPR_EXEC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 86 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_ppr_exec " "Execution of PPR queue requested " "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2770 "trace/trace-hw_i386.h"
        } else {
#line 86 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_ppr_exec " "Execution of PPR queue requested " "\n");
#line 2774 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_ppr_exec(void)
{
    if (true) {
        _nocheck__trace_amdvi_ppr_exec();
    }
}

#define TRACE_AMDVI_DEVTAB_INVAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_DEVTAB_INVAL) || \
    false)

static inline void _nocheck__trace_amdvi_devtab_inval(uint8_t bus, uint8_t slot, uint8_t func)
{
    if (trace_event_get_state(TRACE_AMDVI_DEVTAB_INVAL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 87 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_devtab_inval " "device table entry for devid: %02x:%02x.%x invalidated" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bus, slot, func);
#line 2801 "trace/trace-hw_i386.h"
        } else {
#line 87 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_devtab_inval " "device table entry for devid: %02x:%02x.%x invalidated" "\n", bus, slot, func);
#line 2805 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_devtab_inval(uint8_t bus, uint8_t slot, uint8_t func)
{
    if (true) {
        _nocheck__trace_amdvi_devtab_inval(bus, slot, func);
    }
}

#define TRACE_AMDVI_COMPLETION_WAIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_COMPLETION_WAIT) || \
    false)

static inline void _nocheck__trace_amdvi_completion_wait(uint64_t addr, uint64_t data)
{
    if (trace_event_get_state(TRACE_AMDVI_COMPLETION_WAIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 88 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_completion_wait " "completion wait requested with store address 0x%"PRIx64" and store data 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, data);
#line 2832 "trace/trace-hw_i386.h"
        } else {
#line 88 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_completion_wait " "completion wait requested with store address 0x%"PRIx64" and store data 0x%"PRIx64 "\n", addr, data);
#line 2836 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_completion_wait(uint64_t addr, uint64_t data)
{
    if (true) {
        _nocheck__trace_amdvi_completion_wait(addr, data);
    }
}

#define TRACE_AMDVI_CONTROL_STATUS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_CONTROL_STATUS) || \
    false)

static inline void _nocheck__trace_amdvi_control_status(uint64_t val)
{
    if (trace_event_get_state(TRACE_AMDVI_CONTROL_STATUS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 89 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_control_status " "MMIO_STATUS state 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 2863 "trace/trace-hw_i386.h"
        } else {
#line 89 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_control_status " "MMIO_STATUS state 0x%"PRIx64 "\n", val);
#line 2867 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_control_status(uint64_t val)
{
    if (true) {
        _nocheck__trace_amdvi_control_status(val);
    }
}

#define TRACE_AMDVI_IOTLB_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IOTLB_RESET) || \
    false)

static inline void _nocheck__trace_amdvi_iotlb_reset(void)
{
    if (trace_event_get_state(TRACE_AMDVI_IOTLB_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 90 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_iotlb_reset " "IOTLB exceed size limit - reset " "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2894 "trace/trace-hw_i386.h"
        } else {
#line 90 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_iotlb_reset " "IOTLB exceed size limit - reset " "\n");
#line 2898 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_iotlb_reset(void)
{
    if (true) {
        _nocheck__trace_amdvi_iotlb_reset();
    }
}

#define TRACE_AMDVI_DTE_GET_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_DTE_GET_FAIL) || \
    false)

static inline void _nocheck__trace_amdvi_dte_get_fail(uint64_t addr, uint32_t offset)
{
    if (trace_event_get_state(TRACE_AMDVI_DTE_GET_FAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 91 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_dte_get_fail " "error: failed to access Device Entry devtab 0x%"PRIx64" offset 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, offset);
#line 2925 "trace/trace-hw_i386.h"
        } else {
#line 91 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_dte_get_fail " "error: failed to access Device Entry devtab 0x%"PRIx64" offset 0x%"PRIx32 "\n", addr, offset);
#line 2929 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_dte_get_fail(uint64_t addr, uint32_t offset)
{
    if (true) {
        _nocheck__trace_amdvi_dte_get_fail(addr, offset);
    }
}

#define TRACE_AMDVI_INVALID_DTE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_INVALID_DTE) || \
    false)

static inline void _nocheck__trace_amdvi_invalid_dte(uint64_t addr)
{
    if (trace_event_get_state(TRACE_AMDVI_INVALID_DTE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 92 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_invalid_dte " "PTE entry at 0x%"PRIx64" is invalid " "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 2956 "trace/trace-hw_i386.h"
        } else {
#line 92 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_invalid_dte " "PTE entry at 0x%"PRIx64" is invalid " "\n", addr);
#line 2960 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_invalid_dte(uint64_t addr)
{
    if (true) {
        _nocheck__trace_amdvi_invalid_dte(addr);
    }
}

#define TRACE_AMDVI_GET_PTE_HWERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_GET_PTE_HWERROR) || \
    false)

static inline void _nocheck__trace_amdvi_get_pte_hwerror(uint64_t addr)
{
    if (trace_event_get_state(TRACE_AMDVI_GET_PTE_HWERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 93 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_get_pte_hwerror " "hardware error eccessing PTE at addr 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 2987 "trace/trace-hw_i386.h"
        } else {
#line 93 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_get_pte_hwerror " "hardware error eccessing PTE at addr 0x%"PRIx64 "\n", addr);
#line 2991 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_get_pte_hwerror(uint64_t addr)
{
    if (true) {
        _nocheck__trace_amdvi_get_pte_hwerror(addr);
    }
}

#define TRACE_AMDVI_MODE_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_MODE_INVALID) || \
    false)

static inline void _nocheck__trace_amdvi_mode_invalid(uint8_t level, uint64_t addr)
{
    if (trace_event_get_state(TRACE_AMDVI_MODE_INVALID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 94 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_mode_invalid " "error: translation level 0x%"PRIx8" translating addr 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , level, addr);
#line 3018 "trace/trace-hw_i386.h"
        } else {
#line 94 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_mode_invalid " "error: translation level 0x%"PRIx8" translating addr 0x%"PRIx64 "\n", level, addr);
#line 3022 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_mode_invalid(uint8_t level, uint64_t addr)
{
    if (true) {
        _nocheck__trace_amdvi_mode_invalid(level, addr);
    }
}

#define TRACE_AMDVI_PAGE_FAULT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_PAGE_FAULT) || \
    false)

static inline void _nocheck__trace_amdvi_page_fault(uint64_t addr)
{
    if (trace_event_get_state(TRACE_AMDVI_PAGE_FAULT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 95 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_page_fault " "error: page fault accessing guest physical address 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 3049 "trace/trace-hw_i386.h"
        } else {
#line 95 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_page_fault " "error: page fault accessing guest physical address 0x%"PRIx64 "\n", addr);
#line 3053 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_page_fault(uint64_t addr)
{
    if (true) {
        _nocheck__trace_amdvi_page_fault(addr);
    }
}

#define TRACE_AMDVI_IOTLB_HIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IOTLB_HIT) || \
    false)

static inline void _nocheck__trace_amdvi_iotlb_hit(uint8_t bus, uint8_t slot, uint8_t func, uint64_t addr, uint64_t txaddr)
{
    if (trace_event_get_state(TRACE_AMDVI_IOTLB_HIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 96 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_iotlb_hit " "hit iotlb devid %02x:%02x.%x gpa 0x%"PRIx64" hpa 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bus, slot, func, addr, txaddr);
#line 3080 "trace/trace-hw_i386.h"
        } else {
#line 96 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_iotlb_hit " "hit iotlb devid %02x:%02x.%x gpa 0x%"PRIx64" hpa 0x%"PRIx64 "\n", bus, slot, func, addr, txaddr);
#line 3084 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_iotlb_hit(uint8_t bus, uint8_t slot, uint8_t func, uint64_t addr, uint64_t txaddr)
{
    if (true) {
        _nocheck__trace_amdvi_iotlb_hit(bus, slot, func, addr, txaddr);
    }
}

#define TRACE_AMDVI_TRANSLATION_RESULT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_TRANSLATION_RESULT) || \
    false)

static inline void _nocheck__trace_amdvi_translation_result(uint8_t bus, uint8_t slot, uint8_t func, uint64_t addr, uint64_t txaddr)
{
    if (trace_event_get_state(TRACE_AMDVI_TRANSLATION_RESULT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 97 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_translation_result " "devid: %02x:%02x.%x gpa 0x%"PRIx64" hpa 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bus, slot, func, addr, txaddr);
#line 3111 "trace/trace-hw_i386.h"
        } else {
#line 97 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_translation_result " "devid: %02x:%02x.%x gpa 0x%"PRIx64" hpa 0x%"PRIx64 "\n", bus, slot, func, addr, txaddr);
#line 3115 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_translation_result(uint8_t bus, uint8_t slot, uint8_t func, uint64_t addr, uint64_t txaddr)
{
    if (true) {
        _nocheck__trace_amdvi_translation_result(bus, slot, func, addr, txaddr);
    }
}

#define TRACE_AMDVI_MEM_IR_WRITE_REQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_MEM_IR_WRITE_REQ) || \
    false)

static inline void _nocheck__trace_amdvi_mem_ir_write_req(uint64_t addr, uint64_t val, uint32_t size)
{
    if (trace_event_get_state(TRACE_AMDVI_MEM_IR_WRITE_REQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 98 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_mem_ir_write_req " "addr 0x%"PRIx64" data 0x%"PRIx64" size 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val, size);
#line 3142 "trace/trace-hw_i386.h"
        } else {
#line 98 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_mem_ir_write_req " "addr 0x%"PRIx64" data 0x%"PRIx64" size 0x%"PRIx32 "\n", addr, val, size);
#line 3146 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_mem_ir_write_req(uint64_t addr, uint64_t val, uint32_t size)
{
    if (true) {
        _nocheck__trace_amdvi_mem_ir_write_req(addr, val, size);
    }
}

#define TRACE_AMDVI_MEM_IR_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_MEM_IR_WRITE) || \
    false)

static inline void _nocheck__trace_amdvi_mem_ir_write(uint64_t addr, uint64_t val)
{
    if (trace_event_get_state(TRACE_AMDVI_MEM_IR_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 99 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_mem_ir_write " "addr 0x%"PRIx64" data 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 3173 "trace/trace-hw_i386.h"
        } else {
#line 99 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_mem_ir_write " "addr 0x%"PRIx64" data 0x%"PRIx64 "\n", addr, val);
#line 3177 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_mem_ir_write(uint64_t addr, uint64_t val)
{
    if (true) {
        _nocheck__trace_amdvi_mem_ir_write(addr, val);
    }
}

#define TRACE_AMDVI_IR_REMAP_MSI_REQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IR_REMAP_MSI_REQ) || \
    false)

static inline void _nocheck__trace_amdvi_ir_remap_msi_req(uint64_t addr, uint64_t data, uint8_t devid)
{
    if (trace_event_get_state(TRACE_AMDVI_IR_REMAP_MSI_REQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 100 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_ir_remap_msi_req " "addr 0x%"PRIx64" data 0x%"PRIx64" devid 0x%"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, data, devid);
#line 3204 "trace/trace-hw_i386.h"
        } else {
#line 100 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_ir_remap_msi_req " "addr 0x%"PRIx64" data 0x%"PRIx64" devid 0x%"PRIx8 "\n", addr, data, devid);
#line 3208 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_ir_remap_msi_req(uint64_t addr, uint64_t data, uint8_t devid)
{
    if (true) {
        _nocheck__trace_amdvi_ir_remap_msi_req(addr, data, devid);
    }
}

#define TRACE_AMDVI_IR_REMAP_MSI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IR_REMAP_MSI) || \
    false)

static inline void _nocheck__trace_amdvi_ir_remap_msi(uint64_t addr, uint64_t data, uint64_t addr2, uint64_t data2)
{
    if (trace_event_get_state(TRACE_AMDVI_IR_REMAP_MSI) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 101 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_ir_remap_msi " "(addr 0x%"PRIx64", data 0x%"PRIx64") -> (addr 0x%"PRIx64", data 0x%"PRIx64")" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, data, addr2, data2);
#line 3235 "trace/trace-hw_i386.h"
        } else {
#line 101 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_ir_remap_msi " "(addr 0x%"PRIx64", data 0x%"PRIx64") -> (addr 0x%"PRIx64", data 0x%"PRIx64")" "\n", addr, data, addr2, data2);
#line 3239 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_ir_remap_msi(uint64_t addr, uint64_t data, uint64_t addr2, uint64_t data2)
{
    if (true) {
        _nocheck__trace_amdvi_ir_remap_msi(addr, data, addr2, data2);
    }
}

#define TRACE_AMDVI_ERR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_ERR) || \
    false)

static inline void _nocheck__trace_amdvi_err(const char * str)
{
    if (trace_event_get_state(TRACE_AMDVI_ERR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 102 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_err " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , str);
#line 3266 "trace/trace-hw_i386.h"
        } else {
#line 102 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_err " "%s" "\n", str);
#line 3270 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_err(const char * str)
{
    if (true) {
        _nocheck__trace_amdvi_err(str);
    }
}

#define TRACE_AMDVI_IR_IRTE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IR_IRTE) || \
    false)

static inline void _nocheck__trace_amdvi_ir_irte(uint64_t addr, uint64_t data)
{
    if (trace_event_get_state(TRACE_AMDVI_IR_IRTE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 103 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_ir_irte " "addr 0x%"PRIx64" offset 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, data);
#line 3297 "trace/trace-hw_i386.h"
        } else {
#line 103 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_ir_irte " "addr 0x%"PRIx64" offset 0x%"PRIx64 "\n", addr, data);
#line 3301 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_ir_irte(uint64_t addr, uint64_t data)
{
    if (true) {
        _nocheck__trace_amdvi_ir_irte(addr, data);
    }
}

#define TRACE_AMDVI_IR_IRTE_VAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IR_IRTE_VAL) || \
    false)

static inline void _nocheck__trace_amdvi_ir_irte_val(uint32_t data)
{
    if (trace_event_get_state(TRACE_AMDVI_IR_IRTE_VAL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 104 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_ir_irte_val " "data 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , data);
#line 3328 "trace/trace-hw_i386.h"
        } else {
#line 104 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_ir_irte_val " "data 0x%"PRIx32 "\n", data);
#line 3332 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_ir_irte_val(uint32_t data)
{
    if (true) {
        _nocheck__trace_amdvi_ir_irte_val(data);
    }
}

#define TRACE_AMDVI_IR_ERR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IR_ERR) || \
    false)

static inline void _nocheck__trace_amdvi_ir_err(const char * str)
{
    if (trace_event_get_state(TRACE_AMDVI_IR_ERR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 105 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_ir_err " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , str);
#line 3359 "trace/trace-hw_i386.h"
        } else {
#line 105 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_ir_err " "%s" "\n", str);
#line 3363 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_ir_err(const char * str)
{
    if (true) {
        _nocheck__trace_amdvi_ir_err(str);
    }
}

#define TRACE_AMDVI_IR_INTCTL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IR_INTCTL) || \
    false)

static inline void _nocheck__trace_amdvi_ir_intctl(uint8_t val)
{
    if (trace_event_get_state(TRACE_AMDVI_IR_INTCTL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 106 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_ir_intctl " "int_ctl 0x%"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 3390 "trace/trace-hw_i386.h"
        } else {
#line 106 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_ir_intctl " "int_ctl 0x%"PRIx8 "\n", val);
#line 3394 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_ir_intctl(uint8_t val)
{
    if (true) {
        _nocheck__trace_amdvi_ir_intctl(val);
    }
}

#define TRACE_AMDVI_IR_TARGET_ABORT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IR_TARGET_ABORT) || \
    false)

static inline void _nocheck__trace_amdvi_ir_target_abort(const char * str)
{
    if (trace_event_get_state(TRACE_AMDVI_IR_TARGET_ABORT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 107 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_ir_target_abort " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , str);
#line 3421 "trace/trace-hw_i386.h"
        } else {
#line 107 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_ir_target_abort " "%s" "\n", str);
#line 3425 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_ir_target_abort(const char * str)
{
    if (true) {
        _nocheck__trace_amdvi_ir_target_abort(str);
    }
}

#define TRACE_AMDVI_IR_DELIVERY_MODE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IR_DELIVERY_MODE) || \
    false)

static inline void _nocheck__trace_amdvi_ir_delivery_mode(const char * str)
{
    if (trace_event_get_state(TRACE_AMDVI_IR_DELIVERY_MODE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 108 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_ir_delivery_mode " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , str);
#line 3452 "trace/trace-hw_i386.h"
        } else {
#line 108 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_ir_delivery_mode " "%s" "\n", str);
#line 3456 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_ir_delivery_mode(const char * str)
{
    if (true) {
        _nocheck__trace_amdvi_ir_delivery_mode(str);
    }
}

#define TRACE_AMDVI_IR_IRTE_GA_VAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IR_IRTE_GA_VAL) || \
    false)

static inline void _nocheck__trace_amdvi_ir_irte_ga_val(uint64_t hi, uint64_t lo)
{
    if (trace_event_get_state(TRACE_AMDVI_IR_IRTE_GA_VAL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 109 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:amdvi_ir_irte_ga_val " "hi 0x%"PRIx64" lo 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , hi, lo);
#line 3483 "trace/trace-hw_i386.h"
        } else {
#line 109 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("amdvi_ir_irte_ga_val " "hi 0x%"PRIx64" lo 0x%"PRIx64 "\n", hi, lo);
#line 3487 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_amdvi_ir_irte_ga_val(uint64_t hi, uint64_t lo)
{
    if (true) {
        _nocheck__trace_amdvi_ir_irte_ga_val(hi, lo);
    }
}

#define TRACE_VMPORT_REGISTER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMPORT_REGISTER) || \
    false)

static inline void _nocheck__trace_vmport_register(unsigned char command, void * func, void * opaque)
{
    if (trace_event_get_state(TRACE_VMPORT_REGISTER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 112 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vmport_register " "command: 0x%02x func: %p opaque: %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , command, func, opaque);
#line 3514 "trace/trace-hw_i386.h"
        } else {
#line 112 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vmport_register " "command: 0x%02x func: %p opaque: %p" "\n", command, func, opaque);
#line 3518 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vmport_register(unsigned char command, void * func, void * opaque)
{
    if (true) {
        _nocheck__trace_vmport_register(command, func, opaque);
    }
}

#define TRACE_VMPORT_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VMPORT_COMMAND) || \
    false)

static inline void _nocheck__trace_vmport_command(unsigned char command)
{
    if (trace_event_get_state(TRACE_VMPORT_COMMAND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 113 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:vmport_command " "command: 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , command);
#line 3545 "trace/trace-hw_i386.h"
        } else {
#line 113 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("vmport_command " "command: 0x%02x" "\n", command);
#line 3549 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_vmport_command(unsigned char command)
{
    if (true) {
        _nocheck__trace_vmport_command(command);
    }
}

#define TRACE_X86_GSI_INTERRUPT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_X86_GSI_INTERRUPT) || \
    false)

static inline void _nocheck__trace_x86_gsi_interrupt(int irqn, int level)
{
    if (trace_event_get_state(TRACE_X86_GSI_INTERRUPT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 116 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:x86_gsi_interrupt " "GSI interrupt #%d level:%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , irqn, level);
#line 3576 "trace/trace-hw_i386.h"
        } else {
#line 116 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("x86_gsi_interrupt " "GSI interrupt #%d level:%d" "\n", irqn, level);
#line 3580 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_x86_gsi_interrupt(int irqn, int level)
{
    if (true) {
        _nocheck__trace_x86_gsi_interrupt(irqn, level);
    }
}

#define TRACE_X86_PIC_INTERRUPT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_X86_PIC_INTERRUPT) || \
    false)

static inline void _nocheck__trace_x86_pic_interrupt(int irqn, int level)
{
    if (trace_event_get_state(TRACE_X86_PIC_INTERRUPT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 117 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:x86_pic_interrupt " "PIC interrupt #%d level:%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , irqn, level);
#line 3607 "trace/trace-hw_i386.h"
        } else {
#line 117 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("x86_pic_interrupt " "PIC interrupt #%d level:%d" "\n", irqn, level);
#line 3611 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_x86_pic_interrupt(int irqn, int level)
{
    if (true) {
        _nocheck__trace_x86_pic_interrupt(irqn, level);
    }
}

#define TRACE_PORT92_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PORT92_READ) || \
    false)

static inline void _nocheck__trace_port92_read(uint8_t val)
{
    if (trace_event_get_state(TRACE_PORT92_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 120 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:port92_read " "port92: read 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 3638 "trace/trace-hw_i386.h"
        } else {
#line 120 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("port92_read " "port92: read 0x%02x" "\n", val);
#line 3642 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_port92_read(uint8_t val)
{
    if (true) {
        _nocheck__trace_port92_read(val);
    }
}

#define TRACE_PORT92_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PORT92_WRITE) || \
    false)

static inline void _nocheck__trace_port92_write(uint8_t val)
{
    if (trace_event_get_state(TRACE_PORT92_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 121 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("%d@%zu.%06zu:port92_write " "port92: write 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 3669 "trace/trace-hw_i386.h"
        } else {
#line 121 "/home/inhoinno/FEMU/hw/i386/trace-events"
            qemu_log("port92_write " "port92: write 0x%02x" "\n", val);
#line 3673 "trace/trace-hw_i386.h"
        }
    }
}

static inline void trace_port92_write(uint8_t val)
{
    if (true) {
        _nocheck__trace_port92_write(val);
    }
}
#endif /* TRACE_HW_I386_GENERATED_TRACERS_H */
