/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_NVME_GENERATED_TRACERS_H
#define TRACE_HW_NVME_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_PCI_NVME_IRQ_MSIX_EVENT;
extern TraceEvent _TRACE_PCI_NVME_IRQ_PIN_EVENT;
extern TraceEvent _TRACE_PCI_NVME_IRQ_MASKED_EVENT;
extern TraceEvent _TRACE_PCI_NVME_DMA_READ_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MAP_ADDR_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MAP_ADDR_CMB_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MAP_PRP_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MAP_SGL_EVENT;
extern TraceEvent _TRACE_PCI_NVME_IO_CMD_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ADMIN_CMD_EVENT;
extern TraceEvent _TRACE_PCI_NVME_FLUSH_NS_EVENT;
extern TraceEvent _TRACE_PCI_NVME_FORMAT_SET_EVENT;
extern TraceEvent _TRACE_PCI_NVME_READ_EVENT;
extern TraceEvent _TRACE_PCI_NVME_WRITE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_RW_CB_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MISC_CB_EVENT;
extern TraceEvent _TRACE_PCI_NVME_DIF_RW_EVENT;
extern TraceEvent _TRACE_PCI_NVME_DIF_RW_CB_EVENT;
extern TraceEvent _TRACE_PCI_NVME_DIF_RW_MDATA_IN_CB_EVENT;
extern TraceEvent _TRACE_PCI_NVME_DIF_RW_MDATA_OUT_CB_EVENT;
extern TraceEvent _TRACE_PCI_NVME_DIF_RW_CHECK_CB_EVENT;
extern TraceEvent _TRACE_PCI_NVME_DIF_PRACT_GENERATE_DIF_CRC16_EVENT;
extern TraceEvent _TRACE_PCI_NVME_DIF_PRACT_GENERATE_DIF_CRC64_EVENT;
extern TraceEvent _TRACE_PCI_NVME_DIF_CHECK_EVENT;
extern TraceEvent _TRACE_PCI_NVME_DIF_PRCHK_DISABLED_CRC16_EVENT;
extern TraceEvent _TRACE_PCI_NVME_DIF_PRCHK_DISABLED_CRC64_EVENT;
extern TraceEvent _TRACE_PCI_NVME_DIF_PRCHK_GUARD_CRC16_EVENT;
extern TraceEvent _TRACE_PCI_NVME_DIF_PRCHK_GUARD_CRC64_EVENT;
extern TraceEvent _TRACE_PCI_NVME_DIF_PRCHK_APPTAG_EVENT;
extern TraceEvent _TRACE_PCI_NVME_DIF_PRCHK_REFTAG_CRC16_EVENT;
extern TraceEvent _TRACE_PCI_NVME_DIF_PRCHK_REFTAG_CRC64_EVENT;
extern TraceEvent _TRACE_PCI_NVME_COPY_EVENT;
extern TraceEvent _TRACE_PCI_NVME_COPY_SOURCE_RANGE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_COPY_OUT_EVENT;
extern TraceEvent _TRACE_PCI_NVME_VERIFY_EVENT;
extern TraceEvent _TRACE_PCI_NVME_VERIFY_MDATA_IN_CB_EVENT;
extern TraceEvent _TRACE_PCI_NVME_VERIFY_CB_EVENT;
extern TraceEvent _TRACE_PCI_NVME_RW_COMPLETE_CB_EVENT;
extern TraceEvent _TRACE_PCI_NVME_BLOCK_STATUS_EVENT;
extern TraceEvent _TRACE_PCI_NVME_DSM_EVENT;
extern TraceEvent _TRACE_PCI_NVME_DSM_DEALLOCATE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_DSM_SINGLE_RANGE_LIMIT_EXCEEDED_EVENT;
extern TraceEvent _TRACE_PCI_NVME_COMPARE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_COMPARE_DATA_CB_EVENT;
extern TraceEvent _TRACE_PCI_NVME_COMPARE_MDATA_CB_EVENT;
extern TraceEvent _TRACE_PCI_NVME_AIO_DISCARD_CB_EVENT;
extern TraceEvent _TRACE_PCI_NVME_AIO_COPY_IN_CB_EVENT;
extern TraceEvent _TRACE_PCI_NVME_AIO_FLUSH_CB_EVENT;
extern TraceEvent _TRACE_PCI_NVME_CREATE_SQ_EVENT;
extern TraceEvent _TRACE_PCI_NVME_CREATE_CQ_EVENT;
extern TraceEvent _TRACE_PCI_NVME_DEL_SQ_EVENT;
extern TraceEvent _TRACE_PCI_NVME_DEL_CQ_EVENT;
extern TraceEvent _TRACE_PCI_NVME_IDENTIFY_EVENT;
extern TraceEvent _TRACE_PCI_NVME_IDENTIFY_CTRL_EVENT;
extern TraceEvent _TRACE_PCI_NVME_IDENTIFY_CTRL_CSI_EVENT;
extern TraceEvent _TRACE_PCI_NVME_IDENTIFY_NS_EVENT;
extern TraceEvent _TRACE_PCI_NVME_IDENTIFY_CTRL_LIST_EVENT;
extern TraceEvent _TRACE_PCI_NVME_IDENTIFY_NS_CSI_EVENT;
extern TraceEvent _TRACE_PCI_NVME_IDENTIFY_NSLIST_EVENT;
extern TraceEvent _TRACE_PCI_NVME_IDENTIFY_NSLIST_CSI_EVENT;
extern TraceEvent _TRACE_PCI_NVME_IDENTIFY_CMD_SET_EVENT;
extern TraceEvent _TRACE_PCI_NVME_IDENTIFY_NS_DESCR_LIST_EVENT;
extern TraceEvent _TRACE_PCI_NVME_GET_LOG_EVENT;
extern TraceEvent _TRACE_PCI_NVME_GETFEAT_EVENT;
extern TraceEvent _TRACE_PCI_NVME_SETFEAT_EVENT;
extern TraceEvent _TRACE_PCI_NVME_GETFEAT_VWCACHE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_GETFEAT_NUMQ_EVENT;
extern TraceEvent _TRACE_PCI_NVME_SETFEAT_NUMQ_EVENT;
extern TraceEvent _TRACE_PCI_NVME_SETFEAT_TIMESTAMP_EVENT;
extern TraceEvent _TRACE_PCI_NVME_GETFEAT_TIMESTAMP_EVENT;
extern TraceEvent _TRACE_PCI_NVME_PROCESS_AERS_EVENT;
extern TraceEvent _TRACE_PCI_NVME_AER_EVENT;
extern TraceEvent _TRACE_PCI_NVME_AER_AERL_EXCEEDED_EVENT;
extern TraceEvent _TRACE_PCI_NVME_AER_MASKED_EVENT;
extern TraceEvent _TRACE_PCI_NVME_AER_POST_CQE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_NS_ATTACHMENT_EVENT;
extern TraceEvent _TRACE_PCI_NVME_NS_ATTACHMENT_ATTACH_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ENQUEUE_EVENT_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ENQUEUE_EVENT_NOQUEUE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ENQUEUE_EVENT_MASKED_EVENT;
extern TraceEvent _TRACE_PCI_NVME_NO_OUTSTANDING_AERS_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ENQUEUE_REQ_COMPLETION_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MMIO_READ_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MMIO_WRITE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MMIO_DOORBELL_CQ_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MMIO_DOORBELL_SQ_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MMIO_INTM_SET_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MMIO_INTM_CLR_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MMIO_CFG_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MMIO_AQATTR_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MMIO_ASQADDR_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MMIO_ACQADDR_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MMIO_ASQADDR_HI_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MMIO_ACQADDR_HI_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MMIO_START_SUCCESS_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MMIO_STOPPED_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MMIO_SHUTDOWN_SET_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MMIO_SHUTDOWN_CLEARED_EVENT;
extern TraceEvent _TRACE_PCI_NVME_OPEN_ZONE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_CLOSE_ZONE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_FINISH_ZONE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_RESET_ZONE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ZNS_ZONE_RESET_EVENT;
extern TraceEvent _TRACE_PCI_NVME_OFFLINE_ZONE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_SET_DESCRIPTOR_EXTENSION_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ZD_EXTENSION_SET_EVENT;
extern TraceEvent _TRACE_PCI_NVME_CLEAR_NS_CLOSE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_CLEAR_NS_RESET_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ZONED_ZRWA_IMPLICIT_FLUSH_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_MDTS_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_ZASL_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_REQ_STATUS_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_ADDR_READ_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_ADDR_WRITE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_CFS_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_AIO_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_COPY_INVALID_FORMAT_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_SGLD_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_NUM_SGLD_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_SGL_EXCESS_LENGTH_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_DMA_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_PRPLIST_ENT_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_PRP2_ALIGN_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_OPC_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_ADMIN_OPC_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_LBA_RANGE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_LOG_PAGE_OFFSET_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_CMB_INVALID_CBA_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_CMB_NOT_ENABLED_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_UNALIGNED_ZONE_CMD_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_ZONE_STATE_TRANSITION_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_WRITE_NOT_AT_WP_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_APPEND_NOT_AT_START_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_ZONE_IS_FULL_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_ZONE_IS_READ_ONLY_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_ZONE_IS_OFFLINE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_ZONE_BOUNDARY_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_ZONE_INVALID_WRITE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_ZONE_WRITE_NOT_OK_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_ZONE_READ_NOT_OK_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INSUFF_ACTIVE_RES_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INSUFF_OPEN_RES_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_ZD_EXTENSION_MAP_ERROR_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_IOCSCI_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_DEL_SQ_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_CQID_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_SQID_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_SIZE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_ADDR_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_QFLAGS_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_DEL_CQ_CQID_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_DEL_CQ_NOTEMPTY_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_CQID_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_SIZE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_ADDR_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_VECTOR_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_QFLAGS_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_IDENTIFY_CNS_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_GETFEAT_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_SETFEAT_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_LOG_PAGE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_STARTFAIL_CQ_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_STARTFAIL_SQ_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_STARTFAIL_ASQ_MISALIGNED_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_STARTFAIL_ACQ_MISALIGNED_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_STARTFAIL_PAGE_TOO_SMALL_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_STARTFAIL_PAGE_TOO_LARGE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_STARTFAIL_CQENT_TOO_SMALL_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_STARTFAIL_CQENT_TOO_LARGE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_STARTFAIL_SQENT_TOO_SMALL_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_STARTFAIL_SQENT_TOO_LARGE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_STARTFAIL_CSS_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_STARTFAIL_ASQENT_SZ_ZERO_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_STARTFAIL_ACQENT_SZ_ZERO_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_STARTFAIL_ZASL_TOO_SMALL_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_STARTFAIL_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_MGMT_ACTION_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_MMIOWR_MISALIGNED32_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_MMIOWR_TOOSMALL_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_MMIOWR_INTMASK_WITH_MSIX_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_MMIOWR_RO_CSTS_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_MMIOWR_SSRESET_W1C_UNSUPPORTED_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_MMIOWR_SSRESET_UNSUPPORTED_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_MMIOWR_CMBLOC_RESERVED_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_MMIOWR_CMBSZ_READONLY_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_MMIOWR_PMRCAP_READONLY_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_MMIOWR_PMRSTS_READONLY_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_MMIOWR_PMREBS_READONLY_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_MMIOWR_PMRSWTP_READONLY_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_MMIOWR_INVALID_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_MMIORD_MISALIGNED32_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_MMIORD_TOOSMALL_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_MMIORD_INVALID_OFS_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_DB_WR_MISALIGNED_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_DB_WR_INVALID_CQ_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_DB_WR_INVALID_CQHEAD_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_DB_WR_INVALID_SQ_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_DB_WR_INVALID_SQTAIL_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_UNKNOWN_CSS_VALUE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_TOO_MANY_MAPPINGS_EVENT;
extern uint16_t _TRACE_PCI_NVME_IRQ_MSIX_DSTATE;
extern uint16_t _TRACE_PCI_NVME_IRQ_PIN_DSTATE;
extern uint16_t _TRACE_PCI_NVME_IRQ_MASKED_DSTATE;
extern uint16_t _TRACE_PCI_NVME_DMA_READ_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MAP_ADDR_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MAP_ADDR_CMB_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MAP_PRP_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MAP_SGL_DSTATE;
extern uint16_t _TRACE_PCI_NVME_IO_CMD_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ADMIN_CMD_DSTATE;
extern uint16_t _TRACE_PCI_NVME_FLUSH_NS_DSTATE;
extern uint16_t _TRACE_PCI_NVME_FORMAT_SET_DSTATE;
extern uint16_t _TRACE_PCI_NVME_READ_DSTATE;
extern uint16_t _TRACE_PCI_NVME_WRITE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_RW_CB_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MISC_CB_DSTATE;
extern uint16_t _TRACE_PCI_NVME_DIF_RW_DSTATE;
extern uint16_t _TRACE_PCI_NVME_DIF_RW_CB_DSTATE;
extern uint16_t _TRACE_PCI_NVME_DIF_RW_MDATA_IN_CB_DSTATE;
extern uint16_t _TRACE_PCI_NVME_DIF_RW_MDATA_OUT_CB_DSTATE;
extern uint16_t _TRACE_PCI_NVME_DIF_RW_CHECK_CB_DSTATE;
extern uint16_t _TRACE_PCI_NVME_DIF_PRACT_GENERATE_DIF_CRC16_DSTATE;
extern uint16_t _TRACE_PCI_NVME_DIF_PRACT_GENERATE_DIF_CRC64_DSTATE;
extern uint16_t _TRACE_PCI_NVME_DIF_CHECK_DSTATE;
extern uint16_t _TRACE_PCI_NVME_DIF_PRCHK_DISABLED_CRC16_DSTATE;
extern uint16_t _TRACE_PCI_NVME_DIF_PRCHK_DISABLED_CRC64_DSTATE;
extern uint16_t _TRACE_PCI_NVME_DIF_PRCHK_GUARD_CRC16_DSTATE;
extern uint16_t _TRACE_PCI_NVME_DIF_PRCHK_GUARD_CRC64_DSTATE;
extern uint16_t _TRACE_PCI_NVME_DIF_PRCHK_APPTAG_DSTATE;
extern uint16_t _TRACE_PCI_NVME_DIF_PRCHK_REFTAG_CRC16_DSTATE;
extern uint16_t _TRACE_PCI_NVME_DIF_PRCHK_REFTAG_CRC64_DSTATE;
extern uint16_t _TRACE_PCI_NVME_COPY_DSTATE;
extern uint16_t _TRACE_PCI_NVME_COPY_SOURCE_RANGE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_COPY_OUT_DSTATE;
extern uint16_t _TRACE_PCI_NVME_VERIFY_DSTATE;
extern uint16_t _TRACE_PCI_NVME_VERIFY_MDATA_IN_CB_DSTATE;
extern uint16_t _TRACE_PCI_NVME_VERIFY_CB_DSTATE;
extern uint16_t _TRACE_PCI_NVME_RW_COMPLETE_CB_DSTATE;
extern uint16_t _TRACE_PCI_NVME_BLOCK_STATUS_DSTATE;
extern uint16_t _TRACE_PCI_NVME_DSM_DSTATE;
extern uint16_t _TRACE_PCI_NVME_DSM_DEALLOCATE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_DSM_SINGLE_RANGE_LIMIT_EXCEEDED_DSTATE;
extern uint16_t _TRACE_PCI_NVME_COMPARE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_COMPARE_DATA_CB_DSTATE;
extern uint16_t _TRACE_PCI_NVME_COMPARE_MDATA_CB_DSTATE;
extern uint16_t _TRACE_PCI_NVME_AIO_DISCARD_CB_DSTATE;
extern uint16_t _TRACE_PCI_NVME_AIO_COPY_IN_CB_DSTATE;
extern uint16_t _TRACE_PCI_NVME_AIO_FLUSH_CB_DSTATE;
extern uint16_t _TRACE_PCI_NVME_CREATE_SQ_DSTATE;
extern uint16_t _TRACE_PCI_NVME_CREATE_CQ_DSTATE;
extern uint16_t _TRACE_PCI_NVME_DEL_SQ_DSTATE;
extern uint16_t _TRACE_PCI_NVME_DEL_CQ_DSTATE;
extern uint16_t _TRACE_PCI_NVME_IDENTIFY_DSTATE;
extern uint16_t _TRACE_PCI_NVME_IDENTIFY_CTRL_DSTATE;
extern uint16_t _TRACE_PCI_NVME_IDENTIFY_CTRL_CSI_DSTATE;
extern uint16_t _TRACE_PCI_NVME_IDENTIFY_NS_DSTATE;
extern uint16_t _TRACE_PCI_NVME_IDENTIFY_CTRL_LIST_DSTATE;
extern uint16_t _TRACE_PCI_NVME_IDENTIFY_NS_CSI_DSTATE;
extern uint16_t _TRACE_PCI_NVME_IDENTIFY_NSLIST_DSTATE;
extern uint16_t _TRACE_PCI_NVME_IDENTIFY_NSLIST_CSI_DSTATE;
extern uint16_t _TRACE_PCI_NVME_IDENTIFY_CMD_SET_DSTATE;
extern uint16_t _TRACE_PCI_NVME_IDENTIFY_NS_DESCR_LIST_DSTATE;
extern uint16_t _TRACE_PCI_NVME_GET_LOG_DSTATE;
extern uint16_t _TRACE_PCI_NVME_GETFEAT_DSTATE;
extern uint16_t _TRACE_PCI_NVME_SETFEAT_DSTATE;
extern uint16_t _TRACE_PCI_NVME_GETFEAT_VWCACHE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_GETFEAT_NUMQ_DSTATE;
extern uint16_t _TRACE_PCI_NVME_SETFEAT_NUMQ_DSTATE;
extern uint16_t _TRACE_PCI_NVME_SETFEAT_TIMESTAMP_DSTATE;
extern uint16_t _TRACE_PCI_NVME_GETFEAT_TIMESTAMP_DSTATE;
extern uint16_t _TRACE_PCI_NVME_PROCESS_AERS_DSTATE;
extern uint16_t _TRACE_PCI_NVME_AER_DSTATE;
extern uint16_t _TRACE_PCI_NVME_AER_AERL_EXCEEDED_DSTATE;
extern uint16_t _TRACE_PCI_NVME_AER_MASKED_DSTATE;
extern uint16_t _TRACE_PCI_NVME_AER_POST_CQE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_NS_ATTACHMENT_DSTATE;
extern uint16_t _TRACE_PCI_NVME_NS_ATTACHMENT_ATTACH_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ENQUEUE_EVENT_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ENQUEUE_EVENT_NOQUEUE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ENQUEUE_EVENT_MASKED_DSTATE;
extern uint16_t _TRACE_PCI_NVME_NO_OUTSTANDING_AERS_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ENQUEUE_REQ_COMPLETION_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MMIO_READ_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MMIO_WRITE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MMIO_DOORBELL_CQ_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MMIO_DOORBELL_SQ_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MMIO_INTM_SET_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MMIO_INTM_CLR_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MMIO_CFG_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MMIO_AQATTR_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MMIO_ASQADDR_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MMIO_ACQADDR_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MMIO_ASQADDR_HI_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MMIO_ACQADDR_HI_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MMIO_START_SUCCESS_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MMIO_STOPPED_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MMIO_SHUTDOWN_SET_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MMIO_SHUTDOWN_CLEARED_DSTATE;
extern uint16_t _TRACE_PCI_NVME_OPEN_ZONE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_CLOSE_ZONE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_FINISH_ZONE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_RESET_ZONE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ZNS_ZONE_RESET_DSTATE;
extern uint16_t _TRACE_PCI_NVME_OFFLINE_ZONE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_SET_DESCRIPTOR_EXTENSION_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ZD_EXTENSION_SET_DSTATE;
extern uint16_t _TRACE_PCI_NVME_CLEAR_NS_CLOSE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_CLEAR_NS_RESET_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ZONED_ZRWA_IMPLICIT_FLUSH_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_MDTS_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_ZASL_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_REQ_STATUS_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_ADDR_READ_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_ADDR_WRITE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_CFS_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_AIO_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_COPY_INVALID_FORMAT_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_SGLD_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_NUM_SGLD_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_SGL_EXCESS_LENGTH_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_DMA_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_PRPLIST_ENT_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_PRP2_ALIGN_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_OPC_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_ADMIN_OPC_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_LBA_RANGE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_LOG_PAGE_OFFSET_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_CMB_INVALID_CBA_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_CMB_NOT_ENABLED_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_UNALIGNED_ZONE_CMD_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_ZONE_STATE_TRANSITION_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_WRITE_NOT_AT_WP_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_APPEND_NOT_AT_START_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_ZONE_IS_FULL_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_ZONE_IS_READ_ONLY_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_ZONE_IS_OFFLINE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_ZONE_BOUNDARY_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_ZONE_INVALID_WRITE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_ZONE_WRITE_NOT_OK_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_ZONE_READ_NOT_OK_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INSUFF_ACTIVE_RES_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INSUFF_OPEN_RES_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_ZD_EXTENSION_MAP_ERROR_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_IOCSCI_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_DEL_SQ_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_CQID_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_SQID_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_SIZE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_ADDR_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_QFLAGS_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_DEL_CQ_CQID_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_DEL_CQ_NOTEMPTY_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_CQID_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_SIZE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_ADDR_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_VECTOR_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_QFLAGS_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_IDENTIFY_CNS_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_GETFEAT_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_SETFEAT_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_LOG_PAGE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_STARTFAIL_CQ_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_STARTFAIL_SQ_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_STARTFAIL_ASQ_MISALIGNED_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_STARTFAIL_ACQ_MISALIGNED_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_STARTFAIL_PAGE_TOO_SMALL_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_STARTFAIL_PAGE_TOO_LARGE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_STARTFAIL_CQENT_TOO_SMALL_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_STARTFAIL_CQENT_TOO_LARGE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_STARTFAIL_SQENT_TOO_SMALL_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_STARTFAIL_SQENT_TOO_LARGE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_STARTFAIL_CSS_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_STARTFAIL_ASQENT_SZ_ZERO_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_STARTFAIL_ACQENT_SZ_ZERO_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_STARTFAIL_ZASL_TOO_SMALL_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_STARTFAIL_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_MGMT_ACTION_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_MMIOWR_MISALIGNED32_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_MMIOWR_TOOSMALL_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_MMIOWR_INTMASK_WITH_MSIX_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_MMIOWR_RO_CSTS_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_MMIOWR_SSRESET_W1C_UNSUPPORTED_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_MMIOWR_SSRESET_UNSUPPORTED_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_MMIOWR_CMBLOC_RESERVED_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_MMIOWR_CMBSZ_READONLY_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_MMIOWR_PMRCAP_READONLY_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_MMIOWR_PMRSTS_READONLY_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_MMIOWR_PMREBS_READONLY_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_MMIOWR_PMRSWTP_READONLY_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_MMIOWR_INVALID_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_MMIORD_MISALIGNED32_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_MMIORD_TOOSMALL_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_MMIORD_INVALID_OFS_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_DB_WR_MISALIGNED_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_DB_WR_INVALID_CQ_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_DB_WR_INVALID_CQHEAD_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_DB_WR_INVALID_SQ_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_DB_WR_INVALID_SQTAIL_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_UNKNOWN_CSS_VALUE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_TOO_MANY_MAPPINGS_DSTATE;
#define TRACE_PCI_NVME_IRQ_MSIX_ENABLED 1
#define TRACE_PCI_NVME_IRQ_PIN_ENABLED 1
#define TRACE_PCI_NVME_IRQ_MASKED_ENABLED 1
#define TRACE_PCI_NVME_DMA_READ_ENABLED 1
#define TRACE_PCI_NVME_MAP_ADDR_ENABLED 1
#define TRACE_PCI_NVME_MAP_ADDR_CMB_ENABLED 1
#define TRACE_PCI_NVME_MAP_PRP_ENABLED 1
#define TRACE_PCI_NVME_MAP_SGL_ENABLED 1
#define TRACE_PCI_NVME_IO_CMD_ENABLED 1
#define TRACE_PCI_NVME_ADMIN_CMD_ENABLED 1
#define TRACE_PCI_NVME_FLUSH_NS_ENABLED 1
#define TRACE_PCI_NVME_FORMAT_SET_ENABLED 1
#define TRACE_PCI_NVME_READ_ENABLED 1
#define TRACE_PCI_NVME_WRITE_ENABLED 1
#define TRACE_PCI_NVME_RW_CB_ENABLED 1
#define TRACE_PCI_NVME_MISC_CB_ENABLED 1
#define TRACE_PCI_NVME_DIF_RW_ENABLED 1
#define TRACE_PCI_NVME_DIF_RW_CB_ENABLED 1
#define TRACE_PCI_NVME_DIF_RW_MDATA_IN_CB_ENABLED 1
#define TRACE_PCI_NVME_DIF_RW_MDATA_OUT_CB_ENABLED 1
#define TRACE_PCI_NVME_DIF_RW_CHECK_CB_ENABLED 1
#define TRACE_PCI_NVME_DIF_PRACT_GENERATE_DIF_CRC16_ENABLED 1
#define TRACE_PCI_NVME_DIF_PRACT_GENERATE_DIF_CRC64_ENABLED 1
#define TRACE_PCI_NVME_DIF_CHECK_ENABLED 1
#define TRACE_PCI_NVME_DIF_PRCHK_DISABLED_CRC16_ENABLED 1
#define TRACE_PCI_NVME_DIF_PRCHK_DISABLED_CRC64_ENABLED 1
#define TRACE_PCI_NVME_DIF_PRCHK_GUARD_CRC16_ENABLED 1
#define TRACE_PCI_NVME_DIF_PRCHK_GUARD_CRC64_ENABLED 1
#define TRACE_PCI_NVME_DIF_PRCHK_APPTAG_ENABLED 1
#define TRACE_PCI_NVME_DIF_PRCHK_REFTAG_CRC16_ENABLED 1
#define TRACE_PCI_NVME_DIF_PRCHK_REFTAG_CRC64_ENABLED 1
#define TRACE_PCI_NVME_COPY_ENABLED 1
#define TRACE_PCI_NVME_COPY_SOURCE_RANGE_ENABLED 1
#define TRACE_PCI_NVME_COPY_OUT_ENABLED 1
#define TRACE_PCI_NVME_VERIFY_ENABLED 1
#define TRACE_PCI_NVME_VERIFY_MDATA_IN_CB_ENABLED 1
#define TRACE_PCI_NVME_VERIFY_CB_ENABLED 1
#define TRACE_PCI_NVME_RW_COMPLETE_CB_ENABLED 1
#define TRACE_PCI_NVME_BLOCK_STATUS_ENABLED 1
#define TRACE_PCI_NVME_DSM_ENABLED 1
#define TRACE_PCI_NVME_DSM_DEALLOCATE_ENABLED 1
#define TRACE_PCI_NVME_DSM_SINGLE_RANGE_LIMIT_EXCEEDED_ENABLED 1
#define TRACE_PCI_NVME_COMPARE_ENABLED 1
#define TRACE_PCI_NVME_COMPARE_DATA_CB_ENABLED 1
#define TRACE_PCI_NVME_COMPARE_MDATA_CB_ENABLED 1
#define TRACE_PCI_NVME_AIO_DISCARD_CB_ENABLED 1
#define TRACE_PCI_NVME_AIO_COPY_IN_CB_ENABLED 1
#define TRACE_PCI_NVME_AIO_FLUSH_CB_ENABLED 1
#define TRACE_PCI_NVME_CREATE_SQ_ENABLED 1
#define TRACE_PCI_NVME_CREATE_CQ_ENABLED 1
#define TRACE_PCI_NVME_DEL_SQ_ENABLED 1
#define TRACE_PCI_NVME_DEL_CQ_ENABLED 1
#define TRACE_PCI_NVME_IDENTIFY_ENABLED 1
#define TRACE_PCI_NVME_IDENTIFY_CTRL_ENABLED 1
#define TRACE_PCI_NVME_IDENTIFY_CTRL_CSI_ENABLED 1
#define TRACE_PCI_NVME_IDENTIFY_NS_ENABLED 1
#define TRACE_PCI_NVME_IDENTIFY_CTRL_LIST_ENABLED 1
#define TRACE_PCI_NVME_IDENTIFY_NS_CSI_ENABLED 1
#define TRACE_PCI_NVME_IDENTIFY_NSLIST_ENABLED 1
#define TRACE_PCI_NVME_IDENTIFY_NSLIST_CSI_ENABLED 1
#define TRACE_PCI_NVME_IDENTIFY_CMD_SET_ENABLED 1
#define TRACE_PCI_NVME_IDENTIFY_NS_DESCR_LIST_ENABLED 1
#define TRACE_PCI_NVME_GET_LOG_ENABLED 1
#define TRACE_PCI_NVME_GETFEAT_ENABLED 1
#define TRACE_PCI_NVME_SETFEAT_ENABLED 1
#define TRACE_PCI_NVME_GETFEAT_VWCACHE_ENABLED 1
#define TRACE_PCI_NVME_GETFEAT_NUMQ_ENABLED 1
#define TRACE_PCI_NVME_SETFEAT_NUMQ_ENABLED 1
#define TRACE_PCI_NVME_SETFEAT_TIMESTAMP_ENABLED 1
#define TRACE_PCI_NVME_GETFEAT_TIMESTAMP_ENABLED 1
#define TRACE_PCI_NVME_PROCESS_AERS_ENABLED 1
#define TRACE_PCI_NVME_AER_ENABLED 1
#define TRACE_PCI_NVME_AER_AERL_EXCEEDED_ENABLED 1
#define TRACE_PCI_NVME_AER_MASKED_ENABLED 1
#define TRACE_PCI_NVME_AER_POST_CQE_ENABLED 1
#define TRACE_PCI_NVME_NS_ATTACHMENT_ENABLED 1
#define TRACE_PCI_NVME_NS_ATTACHMENT_ATTACH_ENABLED 1
#define TRACE_PCI_NVME_ENQUEUE_EVENT_ENABLED 1
#define TRACE_PCI_NVME_ENQUEUE_EVENT_NOQUEUE_ENABLED 1
#define TRACE_PCI_NVME_ENQUEUE_EVENT_MASKED_ENABLED 1
#define TRACE_PCI_NVME_NO_OUTSTANDING_AERS_ENABLED 1
#define TRACE_PCI_NVME_ENQUEUE_REQ_COMPLETION_ENABLED 1
#define TRACE_PCI_NVME_MMIO_READ_ENABLED 1
#define TRACE_PCI_NVME_MMIO_WRITE_ENABLED 1
#define TRACE_PCI_NVME_MMIO_DOORBELL_CQ_ENABLED 1
#define TRACE_PCI_NVME_MMIO_DOORBELL_SQ_ENABLED 1
#define TRACE_PCI_NVME_MMIO_INTM_SET_ENABLED 1
#define TRACE_PCI_NVME_MMIO_INTM_CLR_ENABLED 1
#define TRACE_PCI_NVME_MMIO_CFG_ENABLED 1
#define TRACE_PCI_NVME_MMIO_AQATTR_ENABLED 1
#define TRACE_PCI_NVME_MMIO_ASQADDR_ENABLED 1
#define TRACE_PCI_NVME_MMIO_ACQADDR_ENABLED 1
#define TRACE_PCI_NVME_MMIO_ASQADDR_HI_ENABLED 1
#define TRACE_PCI_NVME_MMIO_ACQADDR_HI_ENABLED 1
#define TRACE_PCI_NVME_MMIO_START_SUCCESS_ENABLED 1
#define TRACE_PCI_NVME_MMIO_STOPPED_ENABLED 1
#define TRACE_PCI_NVME_MMIO_SHUTDOWN_SET_ENABLED 1
#define TRACE_PCI_NVME_MMIO_SHUTDOWN_CLEARED_ENABLED 1
#define TRACE_PCI_NVME_OPEN_ZONE_ENABLED 1
#define TRACE_PCI_NVME_CLOSE_ZONE_ENABLED 1
#define TRACE_PCI_NVME_FINISH_ZONE_ENABLED 1
#define TRACE_PCI_NVME_RESET_ZONE_ENABLED 1
#define TRACE_PCI_NVME_ZNS_ZONE_RESET_ENABLED 1
#define TRACE_PCI_NVME_OFFLINE_ZONE_ENABLED 1
#define TRACE_PCI_NVME_SET_DESCRIPTOR_EXTENSION_ENABLED 1
#define TRACE_PCI_NVME_ZD_EXTENSION_SET_ENABLED 1
#define TRACE_PCI_NVME_CLEAR_NS_CLOSE_ENABLED 1
#define TRACE_PCI_NVME_CLEAR_NS_RESET_ENABLED 1
#define TRACE_PCI_NVME_ZONED_ZRWA_IMPLICIT_FLUSH_ENABLED 1
#define TRACE_PCI_NVME_ERR_MDTS_ENABLED 1
#define TRACE_PCI_NVME_ERR_ZASL_ENABLED 1
#define TRACE_PCI_NVME_ERR_REQ_STATUS_ENABLED 1
#define TRACE_PCI_NVME_ERR_ADDR_READ_ENABLED 1
#define TRACE_PCI_NVME_ERR_ADDR_WRITE_ENABLED 1
#define TRACE_PCI_NVME_ERR_CFS_ENABLED 1
#define TRACE_PCI_NVME_ERR_AIO_ENABLED 1
#define TRACE_PCI_NVME_ERR_COPY_INVALID_FORMAT_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_SGLD_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_NUM_SGLD_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_SGL_EXCESS_LENGTH_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_DMA_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_PRPLIST_ENT_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_PRP2_ALIGN_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_OPC_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_ADMIN_OPC_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_LBA_RANGE_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_LOG_PAGE_OFFSET_ENABLED 1
#define TRACE_PCI_NVME_ERR_CMB_INVALID_CBA_ENABLED 1
#define TRACE_PCI_NVME_ERR_CMB_NOT_ENABLED_ENABLED 1
#define TRACE_PCI_NVME_ERR_UNALIGNED_ZONE_CMD_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_ZONE_STATE_TRANSITION_ENABLED 1
#define TRACE_PCI_NVME_ERR_WRITE_NOT_AT_WP_ENABLED 1
#define TRACE_PCI_NVME_ERR_APPEND_NOT_AT_START_ENABLED 1
#define TRACE_PCI_NVME_ERR_ZONE_IS_FULL_ENABLED 1
#define TRACE_PCI_NVME_ERR_ZONE_IS_READ_ONLY_ENABLED 1
#define TRACE_PCI_NVME_ERR_ZONE_IS_OFFLINE_ENABLED 1
#define TRACE_PCI_NVME_ERR_ZONE_BOUNDARY_ENABLED 1
#define TRACE_PCI_NVME_ERR_ZONE_INVALID_WRITE_ENABLED 1
#define TRACE_PCI_NVME_ERR_ZONE_WRITE_NOT_OK_ENABLED 1
#define TRACE_PCI_NVME_ERR_ZONE_READ_NOT_OK_ENABLED 1
#define TRACE_PCI_NVME_ERR_INSUFF_ACTIVE_RES_ENABLED 1
#define TRACE_PCI_NVME_ERR_INSUFF_OPEN_RES_ENABLED 1
#define TRACE_PCI_NVME_ERR_ZD_EXTENSION_MAP_ERROR_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_IOCSCI_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_DEL_SQ_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_CQID_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_SQID_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_SIZE_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_ADDR_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_QFLAGS_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_DEL_CQ_CQID_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_DEL_CQ_NOTEMPTY_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_CQID_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_SIZE_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_ADDR_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_VECTOR_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_QFLAGS_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_IDENTIFY_CNS_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_GETFEAT_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_SETFEAT_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_LOG_PAGE_ENABLED 1
#define TRACE_PCI_NVME_ERR_STARTFAIL_CQ_ENABLED 1
#define TRACE_PCI_NVME_ERR_STARTFAIL_SQ_ENABLED 1
#define TRACE_PCI_NVME_ERR_STARTFAIL_ASQ_MISALIGNED_ENABLED 1
#define TRACE_PCI_NVME_ERR_STARTFAIL_ACQ_MISALIGNED_ENABLED 1
#define TRACE_PCI_NVME_ERR_STARTFAIL_PAGE_TOO_SMALL_ENABLED 1
#define TRACE_PCI_NVME_ERR_STARTFAIL_PAGE_TOO_LARGE_ENABLED 1
#define TRACE_PCI_NVME_ERR_STARTFAIL_CQENT_TOO_SMALL_ENABLED 1
#define TRACE_PCI_NVME_ERR_STARTFAIL_CQENT_TOO_LARGE_ENABLED 1
#define TRACE_PCI_NVME_ERR_STARTFAIL_SQENT_TOO_SMALL_ENABLED 1
#define TRACE_PCI_NVME_ERR_STARTFAIL_SQENT_TOO_LARGE_ENABLED 1
#define TRACE_PCI_NVME_ERR_STARTFAIL_CSS_ENABLED 1
#define TRACE_PCI_NVME_ERR_STARTFAIL_ASQENT_SZ_ZERO_ENABLED 1
#define TRACE_PCI_NVME_ERR_STARTFAIL_ACQENT_SZ_ZERO_ENABLED 1
#define TRACE_PCI_NVME_ERR_STARTFAIL_ZASL_TOO_SMALL_ENABLED 1
#define TRACE_PCI_NVME_ERR_STARTFAIL_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_MGMT_ACTION_ENABLED 1
#define TRACE_PCI_NVME_UB_MMIOWR_MISALIGNED32_ENABLED 1
#define TRACE_PCI_NVME_UB_MMIOWR_TOOSMALL_ENABLED 1
#define TRACE_PCI_NVME_UB_MMIOWR_INTMASK_WITH_MSIX_ENABLED 1
#define TRACE_PCI_NVME_UB_MMIOWR_RO_CSTS_ENABLED 1
#define TRACE_PCI_NVME_UB_MMIOWR_SSRESET_W1C_UNSUPPORTED_ENABLED 1
#define TRACE_PCI_NVME_UB_MMIOWR_SSRESET_UNSUPPORTED_ENABLED 1
#define TRACE_PCI_NVME_UB_MMIOWR_CMBLOC_RESERVED_ENABLED 1
#define TRACE_PCI_NVME_UB_MMIOWR_CMBSZ_READONLY_ENABLED 1
#define TRACE_PCI_NVME_UB_MMIOWR_PMRCAP_READONLY_ENABLED 1
#define TRACE_PCI_NVME_UB_MMIOWR_PMRSTS_READONLY_ENABLED 1
#define TRACE_PCI_NVME_UB_MMIOWR_PMREBS_READONLY_ENABLED 1
#define TRACE_PCI_NVME_UB_MMIOWR_PMRSWTP_READONLY_ENABLED 1
#define TRACE_PCI_NVME_UB_MMIOWR_INVALID_ENABLED 1
#define TRACE_PCI_NVME_UB_MMIORD_MISALIGNED32_ENABLED 1
#define TRACE_PCI_NVME_UB_MMIORD_TOOSMALL_ENABLED 1
#define TRACE_PCI_NVME_UB_MMIORD_INVALID_OFS_ENABLED 1
#define TRACE_PCI_NVME_UB_DB_WR_MISALIGNED_ENABLED 1
#define TRACE_PCI_NVME_UB_DB_WR_INVALID_CQ_ENABLED 1
#define TRACE_PCI_NVME_UB_DB_WR_INVALID_CQHEAD_ENABLED 1
#define TRACE_PCI_NVME_UB_DB_WR_INVALID_SQ_ENABLED 1
#define TRACE_PCI_NVME_UB_DB_WR_INVALID_SQTAIL_ENABLED 1
#define TRACE_PCI_NVME_UB_UNKNOWN_CSS_VALUE_ENABLED 1
#define TRACE_PCI_NVME_UB_TOO_MANY_MAPPINGS_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_PCI_NVME_IRQ_MSIX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_IRQ_MSIX) || \
    false)

static inline void _nocheck__trace_pci_nvme_irq_msix(uint32_t vector)
{
    if (trace_event_get_state(TRACE_PCI_NVME_IRQ_MSIX) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 2 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_irq_msix " "raising MSI-X IRQ vector %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vector);
#line 628 "trace/trace-hw_nvme.h"
        } else {
#line 2 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_irq_msix " "raising MSI-X IRQ vector %u" "\n", vector);
#line 632 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_irq_msix(uint32_t vector)
{
    if (true) {
        _nocheck__trace_pci_nvme_irq_msix(vector);
    }
}

#define TRACE_PCI_NVME_IRQ_PIN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_IRQ_PIN) || \
    false)

static inline void _nocheck__trace_pci_nvme_irq_pin(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_IRQ_PIN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 3 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_irq_pin " "pulsing IRQ pin" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 659 "trace/trace-hw_nvme.h"
        } else {
#line 3 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_irq_pin " "pulsing IRQ pin" "\n");
#line 663 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_irq_pin(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_irq_pin();
    }
}

#define TRACE_PCI_NVME_IRQ_MASKED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_IRQ_MASKED) || \
    false)

static inline void _nocheck__trace_pci_nvme_irq_masked(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_IRQ_MASKED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 4 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_irq_masked " "IRQ is masked" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 690 "trace/trace-hw_nvme.h"
        } else {
#line 4 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_irq_masked " "IRQ is masked" "\n");
#line 694 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_irq_masked(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_irq_masked();
    }
}

#define TRACE_PCI_NVME_DMA_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_DMA_READ) || \
    false)

static inline void _nocheck__trace_pci_nvme_dma_read(uint64_t prp1, uint64_t prp2)
{
    if (trace_event_get_state(TRACE_PCI_NVME_DMA_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 5 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_dma_read " "DMA read, prp1=0x%"PRIx64" prp2=0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , prp1, prp2);
#line 721 "trace/trace-hw_nvme.h"
        } else {
#line 5 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_dma_read " "DMA read, prp1=0x%"PRIx64" prp2=0x%"PRIx64"" "\n", prp1, prp2);
#line 725 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_dma_read(uint64_t prp1, uint64_t prp2)
{
    if (true) {
        _nocheck__trace_pci_nvme_dma_read(prp1, prp2);
    }
}

#define TRACE_PCI_NVME_MAP_ADDR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MAP_ADDR) || \
    false)

static inline void _nocheck__trace_pci_nvme_map_addr(uint64_t addr, uint64_t len)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MAP_ADDR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 6 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_map_addr " "addr 0x%"PRIx64" len %"PRIu64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, len);
#line 752 "trace/trace-hw_nvme.h"
        } else {
#line 6 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_map_addr " "addr 0x%"PRIx64" len %"PRIu64"" "\n", addr, len);
#line 756 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_map_addr(uint64_t addr, uint64_t len)
{
    if (true) {
        _nocheck__trace_pci_nvme_map_addr(addr, len);
    }
}

#define TRACE_PCI_NVME_MAP_ADDR_CMB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MAP_ADDR_CMB) || \
    false)

static inline void _nocheck__trace_pci_nvme_map_addr_cmb(uint64_t addr, uint64_t len)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MAP_ADDR_CMB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 7 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_map_addr_cmb " "addr 0x%"PRIx64" len %"PRIu64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, len);
#line 783 "trace/trace-hw_nvme.h"
        } else {
#line 7 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_map_addr_cmb " "addr 0x%"PRIx64" len %"PRIu64"" "\n", addr, len);
#line 787 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_map_addr_cmb(uint64_t addr, uint64_t len)
{
    if (true) {
        _nocheck__trace_pci_nvme_map_addr_cmb(addr, len);
    }
}

#define TRACE_PCI_NVME_MAP_PRP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MAP_PRP) || \
    false)

static inline void _nocheck__trace_pci_nvme_map_prp(uint64_t trans_len, uint32_t len, uint64_t prp1, uint64_t prp2, int num_prps)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MAP_PRP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 8 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_map_prp " "trans_len %"PRIu64" len %"PRIu32" prp1 0x%"PRIx64" prp2 0x%"PRIx64" num_prps %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , trans_len, len, prp1, prp2, num_prps);
#line 814 "trace/trace-hw_nvme.h"
        } else {
#line 8 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_map_prp " "trans_len %"PRIu64" len %"PRIu32" prp1 0x%"PRIx64" prp2 0x%"PRIx64" num_prps %d" "\n", trans_len, len, prp1, prp2, num_prps);
#line 818 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_map_prp(uint64_t trans_len, uint32_t len, uint64_t prp1, uint64_t prp2, int num_prps)
{
    if (true) {
        _nocheck__trace_pci_nvme_map_prp(trans_len, len, prp1, prp2, num_prps);
    }
}

#define TRACE_PCI_NVME_MAP_SGL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MAP_SGL) || \
    false)

static inline void _nocheck__trace_pci_nvme_map_sgl(uint8_t typ, uint64_t len)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MAP_SGL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 9 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_map_sgl " "type 0x%"PRIx8" len %"PRIu64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , typ, len);
#line 845 "trace/trace-hw_nvme.h"
        } else {
#line 9 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_map_sgl " "type 0x%"PRIx8" len %"PRIu64"" "\n", typ, len);
#line 849 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_map_sgl(uint8_t typ, uint64_t len)
{
    if (true) {
        _nocheck__trace_pci_nvme_map_sgl(typ, len);
    }
}

#define TRACE_PCI_NVME_IO_CMD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_IO_CMD) || \
    false)

static inline void _nocheck__trace_pci_nvme_io_cmd(uint16_t cid, uint32_t nsid, uint16_t sqid, uint8_t opcode, const char * opname)
{
    if (trace_event_get_state(TRACE_PCI_NVME_IO_CMD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 10 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_io_cmd " "cid %"PRIu16" nsid 0x%"PRIx32" sqid %"PRIu16" opc 0x%"PRIx8" opname '%s'" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, nsid, sqid, opcode, opname);
#line 876 "trace/trace-hw_nvme.h"
        } else {
#line 10 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_io_cmd " "cid %"PRIu16" nsid 0x%"PRIx32" sqid %"PRIu16" opc 0x%"PRIx8" opname '%s'" "\n", cid, nsid, sqid, opcode, opname);
#line 880 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_io_cmd(uint16_t cid, uint32_t nsid, uint16_t sqid, uint8_t opcode, const char * opname)
{
    if (true) {
        _nocheck__trace_pci_nvme_io_cmd(cid, nsid, sqid, opcode, opname);
    }
}

#define TRACE_PCI_NVME_ADMIN_CMD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ADMIN_CMD) || \
    false)

static inline void _nocheck__trace_pci_nvme_admin_cmd(uint16_t cid, uint16_t sqid, uint8_t opcode, const char * opname)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ADMIN_CMD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 11 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_admin_cmd " "cid %"PRIu16" sqid %"PRIu16" opc 0x%"PRIx8" opname '%s'" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, sqid, opcode, opname);
#line 907 "trace/trace-hw_nvme.h"
        } else {
#line 11 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_admin_cmd " "cid %"PRIu16" sqid %"PRIu16" opc 0x%"PRIx8" opname '%s'" "\n", cid, sqid, opcode, opname);
#line 911 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_admin_cmd(uint16_t cid, uint16_t sqid, uint8_t opcode, const char * opname)
{
    if (true) {
        _nocheck__trace_pci_nvme_admin_cmd(cid, sqid, opcode, opname);
    }
}

#define TRACE_PCI_NVME_FLUSH_NS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_FLUSH_NS) || \
    false)

static inline void _nocheck__trace_pci_nvme_flush_ns(uint32_t nsid)
{
    if (trace_event_get_state(TRACE_PCI_NVME_FLUSH_NS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 12 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_flush_ns " "nsid 0x%"PRIx32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , nsid);
#line 938 "trace/trace-hw_nvme.h"
        } else {
#line 12 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_flush_ns " "nsid 0x%"PRIx32"" "\n", nsid);
#line 942 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_flush_ns(uint32_t nsid)
{
    if (true) {
        _nocheck__trace_pci_nvme_flush_ns(nsid);
    }
}

#define TRACE_PCI_NVME_FORMAT_SET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_FORMAT_SET) || \
    false)

static inline void _nocheck__trace_pci_nvme_format_set(uint32_t nsid, uint8_t lbaf, uint8_t mset, uint8_t pi, uint8_t pil)
{
    if (trace_event_get_state(TRACE_PCI_NVME_FORMAT_SET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 13 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_format_set " "nsid %"PRIu32" lbaf %"PRIu8" mset %"PRIu8" pi %"PRIu8" pil %"PRIu8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , nsid, lbaf, mset, pi, pil);
#line 969 "trace/trace-hw_nvme.h"
        } else {
#line 13 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_format_set " "nsid %"PRIu32" lbaf %"PRIu8" mset %"PRIu8" pi %"PRIu8" pil %"PRIu8"" "\n", nsid, lbaf, mset, pi, pil);
#line 973 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_format_set(uint32_t nsid, uint8_t lbaf, uint8_t mset, uint8_t pi, uint8_t pil)
{
    if (true) {
        _nocheck__trace_pci_nvme_format_set(nsid, lbaf, mset, pi, pil);
    }
}

#define TRACE_PCI_NVME_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_READ) || \
    false)

static inline void _nocheck__trace_pci_nvme_read(uint16_t cid, uint32_t nsid, uint32_t nlb, uint64_t count, uint64_t lba)
{
    if (trace_event_get_state(TRACE_PCI_NVME_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 14 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_read " "cid %"PRIu16" nsid %"PRIu32" nlb %"PRIu32" count %"PRIu64" lba 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, nsid, nlb, count, lba);
#line 1000 "trace/trace-hw_nvme.h"
        } else {
#line 14 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_read " "cid %"PRIu16" nsid %"PRIu32" nlb %"PRIu32" count %"PRIu64" lba 0x%"PRIx64"" "\n", cid, nsid, nlb, count, lba);
#line 1004 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_read(uint16_t cid, uint32_t nsid, uint32_t nlb, uint64_t count, uint64_t lba)
{
    if (true) {
        _nocheck__trace_pci_nvme_read(cid, nsid, nlb, count, lba);
    }
}

#define TRACE_PCI_NVME_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_WRITE) || \
    false)

static inline void _nocheck__trace_pci_nvme_write(uint16_t cid, const char * verb, uint32_t nsid, uint32_t nlb, uint64_t count, uint64_t lba)
{
    if (trace_event_get_state(TRACE_PCI_NVME_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 15 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_write " "cid %"PRIu16" opname '%s' nsid %"PRIu32" nlb %"PRIu32" count %"PRIu64" lba 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, verb, nsid, nlb, count, lba);
#line 1031 "trace/trace-hw_nvme.h"
        } else {
#line 15 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_write " "cid %"PRIu16" opname '%s' nsid %"PRIu32" nlb %"PRIu32" count %"PRIu64" lba 0x%"PRIx64"" "\n", cid, verb, nsid, nlb, count, lba);
#line 1035 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_write(uint16_t cid, const char * verb, uint32_t nsid, uint32_t nlb, uint64_t count, uint64_t lba)
{
    if (true) {
        _nocheck__trace_pci_nvme_write(cid, verb, nsid, nlb, count, lba);
    }
}

#define TRACE_PCI_NVME_RW_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_RW_CB) || \
    false)

static inline void _nocheck__trace_pci_nvme_rw_cb(uint16_t cid, const char * blkname)
{
    if (trace_event_get_state(TRACE_PCI_NVME_RW_CB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 16 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_rw_cb " "cid %"PRIu16" blk '%s'" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, blkname);
#line 1062 "trace/trace-hw_nvme.h"
        } else {
#line 16 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_rw_cb " "cid %"PRIu16" blk '%s'" "\n", cid, blkname);
#line 1066 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_rw_cb(uint16_t cid, const char * blkname)
{
    if (true) {
        _nocheck__trace_pci_nvme_rw_cb(cid, blkname);
    }
}

#define TRACE_PCI_NVME_MISC_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MISC_CB) || \
    false)

static inline void _nocheck__trace_pci_nvme_misc_cb(uint16_t cid)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MISC_CB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 17 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_misc_cb " "cid %"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid);
#line 1093 "trace/trace-hw_nvme.h"
        } else {
#line 17 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_misc_cb " "cid %"PRIu16"" "\n", cid);
#line 1097 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_misc_cb(uint16_t cid)
{
    if (true) {
        _nocheck__trace_pci_nvme_misc_cb(cid);
    }
}

#define TRACE_PCI_NVME_DIF_RW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_DIF_RW) || \
    false)

static inline void _nocheck__trace_pci_nvme_dif_rw(uint8_t pract, uint8_t prinfo)
{
    if (trace_event_get_state(TRACE_PCI_NVME_DIF_RW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 18 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_dif_rw " "pract 0x%"PRIx8" prinfo 0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , pract, prinfo);
#line 1124 "trace/trace-hw_nvme.h"
        } else {
#line 18 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_dif_rw " "pract 0x%"PRIx8" prinfo 0x%"PRIx8"" "\n", pract, prinfo);
#line 1128 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_dif_rw(uint8_t pract, uint8_t prinfo)
{
    if (true) {
        _nocheck__trace_pci_nvme_dif_rw(pract, prinfo);
    }
}

#define TRACE_PCI_NVME_DIF_RW_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_DIF_RW_CB) || \
    false)

static inline void _nocheck__trace_pci_nvme_dif_rw_cb(uint16_t cid, const char * blkname)
{
    if (trace_event_get_state(TRACE_PCI_NVME_DIF_RW_CB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 19 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_dif_rw_cb " "cid %"PRIu16" blk '%s'" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, blkname);
#line 1155 "trace/trace-hw_nvme.h"
        } else {
#line 19 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_dif_rw_cb " "cid %"PRIu16" blk '%s'" "\n", cid, blkname);
#line 1159 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_dif_rw_cb(uint16_t cid, const char * blkname)
{
    if (true) {
        _nocheck__trace_pci_nvme_dif_rw_cb(cid, blkname);
    }
}

#define TRACE_PCI_NVME_DIF_RW_MDATA_IN_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_DIF_RW_MDATA_IN_CB) || \
    false)

static inline void _nocheck__trace_pci_nvme_dif_rw_mdata_in_cb(uint16_t cid, const char * blkname)
{
    if (trace_event_get_state(TRACE_PCI_NVME_DIF_RW_MDATA_IN_CB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 20 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_dif_rw_mdata_in_cb " "cid %"PRIu16" blk '%s'" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, blkname);
#line 1186 "trace/trace-hw_nvme.h"
        } else {
#line 20 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_dif_rw_mdata_in_cb " "cid %"PRIu16" blk '%s'" "\n", cid, blkname);
#line 1190 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_dif_rw_mdata_in_cb(uint16_t cid, const char * blkname)
{
    if (true) {
        _nocheck__trace_pci_nvme_dif_rw_mdata_in_cb(cid, blkname);
    }
}

#define TRACE_PCI_NVME_DIF_RW_MDATA_OUT_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_DIF_RW_MDATA_OUT_CB) || \
    false)

static inline void _nocheck__trace_pci_nvme_dif_rw_mdata_out_cb(uint16_t cid, const char * blkname)
{
    if (trace_event_get_state(TRACE_PCI_NVME_DIF_RW_MDATA_OUT_CB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 21 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_dif_rw_mdata_out_cb " "cid %"PRIu16" blk '%s'" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, blkname);
#line 1217 "trace/trace-hw_nvme.h"
        } else {
#line 21 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_dif_rw_mdata_out_cb " "cid %"PRIu16" blk '%s'" "\n", cid, blkname);
#line 1221 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_dif_rw_mdata_out_cb(uint16_t cid, const char * blkname)
{
    if (true) {
        _nocheck__trace_pci_nvme_dif_rw_mdata_out_cb(cid, blkname);
    }
}

#define TRACE_PCI_NVME_DIF_RW_CHECK_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_DIF_RW_CHECK_CB) || \
    false)

static inline void _nocheck__trace_pci_nvme_dif_rw_check_cb(uint16_t cid, uint8_t prinfo, uint16_t apptag, uint16_t appmask, uint32_t reftag)
{
    if (trace_event_get_state(TRACE_PCI_NVME_DIF_RW_CHECK_CB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 22 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_dif_rw_check_cb " "cid %"PRIu16" prinfo 0x%"PRIx8" apptag 0x%"PRIx16" appmask 0x%"PRIx16" reftag 0x%"PRIx32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, prinfo, apptag, appmask, reftag);
#line 1248 "trace/trace-hw_nvme.h"
        } else {
#line 22 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_dif_rw_check_cb " "cid %"PRIu16" prinfo 0x%"PRIx8" apptag 0x%"PRIx16" appmask 0x%"PRIx16" reftag 0x%"PRIx32"" "\n", cid, prinfo, apptag, appmask, reftag);
#line 1252 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_dif_rw_check_cb(uint16_t cid, uint8_t prinfo, uint16_t apptag, uint16_t appmask, uint32_t reftag)
{
    if (true) {
        _nocheck__trace_pci_nvme_dif_rw_check_cb(cid, prinfo, apptag, appmask, reftag);
    }
}

#define TRACE_PCI_NVME_DIF_PRACT_GENERATE_DIF_CRC16_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_DIF_PRACT_GENERATE_DIF_CRC16) || \
    false)

static inline void _nocheck__trace_pci_nvme_dif_pract_generate_dif_crc16(size_t len, size_t lba_size, size_t chksum_len, uint16_t apptag, uint32_t reftag)
{
    if (trace_event_get_state(TRACE_PCI_NVME_DIF_PRACT_GENERATE_DIF_CRC16) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 23 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_dif_pract_generate_dif_crc16 " "len %zu lba_size %zu chksum_len %zu apptag 0x%"PRIx16" reftag 0x%"PRIx32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , len, lba_size, chksum_len, apptag, reftag);
#line 1279 "trace/trace-hw_nvme.h"
        } else {
#line 23 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_dif_pract_generate_dif_crc16 " "len %zu lba_size %zu chksum_len %zu apptag 0x%"PRIx16" reftag 0x%"PRIx32"" "\n", len, lba_size, chksum_len, apptag, reftag);
#line 1283 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_dif_pract_generate_dif_crc16(size_t len, size_t lba_size, size_t chksum_len, uint16_t apptag, uint32_t reftag)
{
    if (true) {
        _nocheck__trace_pci_nvme_dif_pract_generate_dif_crc16(len, lba_size, chksum_len, apptag, reftag);
    }
}

#define TRACE_PCI_NVME_DIF_PRACT_GENERATE_DIF_CRC64_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_DIF_PRACT_GENERATE_DIF_CRC64) || \
    false)

static inline void _nocheck__trace_pci_nvme_dif_pract_generate_dif_crc64(size_t len, size_t lba_size, size_t chksum_len, uint16_t apptag, uint64_t reftag)
{
    if (trace_event_get_state(TRACE_PCI_NVME_DIF_PRACT_GENERATE_DIF_CRC64) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 24 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_dif_pract_generate_dif_crc64 " "len %zu lba_size %zu chksum_len %zu apptag 0x%"PRIx16" reftag 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , len, lba_size, chksum_len, apptag, reftag);
#line 1310 "trace/trace-hw_nvme.h"
        } else {
#line 24 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_dif_pract_generate_dif_crc64 " "len %zu lba_size %zu chksum_len %zu apptag 0x%"PRIx16" reftag 0x%"PRIx64"" "\n", len, lba_size, chksum_len, apptag, reftag);
#line 1314 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_dif_pract_generate_dif_crc64(size_t len, size_t lba_size, size_t chksum_len, uint16_t apptag, uint64_t reftag)
{
    if (true) {
        _nocheck__trace_pci_nvme_dif_pract_generate_dif_crc64(len, lba_size, chksum_len, apptag, reftag);
    }
}

#define TRACE_PCI_NVME_DIF_CHECK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_DIF_CHECK) || \
    false)

static inline void _nocheck__trace_pci_nvme_dif_check(uint8_t prinfo, uint16_t chksum_len)
{
    if (trace_event_get_state(TRACE_PCI_NVME_DIF_CHECK) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 25 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_dif_check " "prinfo 0x%"PRIx8" chksum_len %"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , prinfo, chksum_len);
#line 1341 "trace/trace-hw_nvme.h"
        } else {
#line 25 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_dif_check " "prinfo 0x%"PRIx8" chksum_len %"PRIu16"" "\n", prinfo, chksum_len);
#line 1345 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_dif_check(uint8_t prinfo, uint16_t chksum_len)
{
    if (true) {
        _nocheck__trace_pci_nvme_dif_check(prinfo, chksum_len);
    }
}

#define TRACE_PCI_NVME_DIF_PRCHK_DISABLED_CRC16_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_DIF_PRCHK_DISABLED_CRC16) || \
    false)

static inline void _nocheck__trace_pci_nvme_dif_prchk_disabled_crc16(uint16_t apptag, uint32_t reftag)
{
    if (trace_event_get_state(TRACE_PCI_NVME_DIF_PRCHK_DISABLED_CRC16) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 26 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_dif_prchk_disabled_crc16 " "apptag 0x%"PRIx16" reftag 0x%"PRIx32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , apptag, reftag);
#line 1372 "trace/trace-hw_nvme.h"
        } else {
#line 26 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_dif_prchk_disabled_crc16 " "apptag 0x%"PRIx16" reftag 0x%"PRIx32"" "\n", apptag, reftag);
#line 1376 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_dif_prchk_disabled_crc16(uint16_t apptag, uint32_t reftag)
{
    if (true) {
        _nocheck__trace_pci_nvme_dif_prchk_disabled_crc16(apptag, reftag);
    }
}

#define TRACE_PCI_NVME_DIF_PRCHK_DISABLED_CRC64_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_DIF_PRCHK_DISABLED_CRC64) || \
    false)

static inline void _nocheck__trace_pci_nvme_dif_prchk_disabled_crc64(uint16_t apptag, uint64_t reftag)
{
    if (trace_event_get_state(TRACE_PCI_NVME_DIF_PRCHK_DISABLED_CRC64) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 27 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_dif_prchk_disabled_crc64 " "apptag 0x%"PRIx16" reftag 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , apptag, reftag);
#line 1403 "trace/trace-hw_nvme.h"
        } else {
#line 27 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_dif_prchk_disabled_crc64 " "apptag 0x%"PRIx16" reftag 0x%"PRIx64"" "\n", apptag, reftag);
#line 1407 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_dif_prchk_disabled_crc64(uint16_t apptag, uint64_t reftag)
{
    if (true) {
        _nocheck__trace_pci_nvme_dif_prchk_disabled_crc64(apptag, reftag);
    }
}

#define TRACE_PCI_NVME_DIF_PRCHK_GUARD_CRC16_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_DIF_PRCHK_GUARD_CRC16) || \
    false)

static inline void _nocheck__trace_pci_nvme_dif_prchk_guard_crc16(uint16_t guard, uint16_t crc)
{
    if (trace_event_get_state(TRACE_PCI_NVME_DIF_PRCHK_GUARD_CRC16) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 28 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_dif_prchk_guard_crc16 " "guard 0x%"PRIx16" crc 0x%"PRIx16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , guard, crc);
#line 1434 "trace/trace-hw_nvme.h"
        } else {
#line 28 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_dif_prchk_guard_crc16 " "guard 0x%"PRIx16" crc 0x%"PRIx16"" "\n", guard, crc);
#line 1438 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_dif_prchk_guard_crc16(uint16_t guard, uint16_t crc)
{
    if (true) {
        _nocheck__trace_pci_nvme_dif_prchk_guard_crc16(guard, crc);
    }
}

#define TRACE_PCI_NVME_DIF_PRCHK_GUARD_CRC64_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_DIF_PRCHK_GUARD_CRC64) || \
    false)

static inline void _nocheck__trace_pci_nvme_dif_prchk_guard_crc64(uint64_t guard, uint64_t crc)
{
    if (trace_event_get_state(TRACE_PCI_NVME_DIF_PRCHK_GUARD_CRC64) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 29 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_dif_prchk_guard_crc64 " "guard 0x%"PRIx64" crc 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , guard, crc);
#line 1465 "trace/trace-hw_nvme.h"
        } else {
#line 29 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_dif_prchk_guard_crc64 " "guard 0x%"PRIx64" crc 0x%"PRIx64"" "\n", guard, crc);
#line 1469 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_dif_prchk_guard_crc64(uint64_t guard, uint64_t crc)
{
    if (true) {
        _nocheck__trace_pci_nvme_dif_prchk_guard_crc64(guard, crc);
    }
}

#define TRACE_PCI_NVME_DIF_PRCHK_APPTAG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_DIF_PRCHK_APPTAG) || \
    false)

static inline void _nocheck__trace_pci_nvme_dif_prchk_apptag(uint16_t apptag, uint16_t elbat, uint16_t elbatm)
{
    if (trace_event_get_state(TRACE_PCI_NVME_DIF_PRCHK_APPTAG) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 30 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_dif_prchk_apptag " "apptag 0x%"PRIx16" elbat 0x%"PRIx16" elbatm 0x%"PRIx16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , apptag, elbat, elbatm);
#line 1496 "trace/trace-hw_nvme.h"
        } else {
#line 30 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_dif_prchk_apptag " "apptag 0x%"PRIx16" elbat 0x%"PRIx16" elbatm 0x%"PRIx16"" "\n", apptag, elbat, elbatm);
#line 1500 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_dif_prchk_apptag(uint16_t apptag, uint16_t elbat, uint16_t elbatm)
{
    if (true) {
        _nocheck__trace_pci_nvme_dif_prchk_apptag(apptag, elbat, elbatm);
    }
}

#define TRACE_PCI_NVME_DIF_PRCHK_REFTAG_CRC16_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_DIF_PRCHK_REFTAG_CRC16) || \
    false)

static inline void _nocheck__trace_pci_nvme_dif_prchk_reftag_crc16(uint32_t reftag, uint32_t elbrt)
{
    if (trace_event_get_state(TRACE_PCI_NVME_DIF_PRCHK_REFTAG_CRC16) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 31 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_dif_prchk_reftag_crc16 " "reftag 0x%"PRIx32" elbrt 0x%"PRIx32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reftag, elbrt);
#line 1527 "trace/trace-hw_nvme.h"
        } else {
#line 31 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_dif_prchk_reftag_crc16 " "reftag 0x%"PRIx32" elbrt 0x%"PRIx32"" "\n", reftag, elbrt);
#line 1531 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_dif_prchk_reftag_crc16(uint32_t reftag, uint32_t elbrt)
{
    if (true) {
        _nocheck__trace_pci_nvme_dif_prchk_reftag_crc16(reftag, elbrt);
    }
}

#define TRACE_PCI_NVME_DIF_PRCHK_REFTAG_CRC64_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_DIF_PRCHK_REFTAG_CRC64) || \
    false)

static inline void _nocheck__trace_pci_nvme_dif_prchk_reftag_crc64(uint64_t reftag, uint64_t elbrt)
{
    if (trace_event_get_state(TRACE_PCI_NVME_DIF_PRCHK_REFTAG_CRC64) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 32 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_dif_prchk_reftag_crc64 " "reftag 0x%"PRIx64" elbrt 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reftag, elbrt);
#line 1558 "trace/trace-hw_nvme.h"
        } else {
#line 32 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_dif_prchk_reftag_crc64 " "reftag 0x%"PRIx64" elbrt 0x%"PRIx64"" "\n", reftag, elbrt);
#line 1562 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_dif_prchk_reftag_crc64(uint64_t reftag, uint64_t elbrt)
{
    if (true) {
        _nocheck__trace_pci_nvme_dif_prchk_reftag_crc64(reftag, elbrt);
    }
}

#define TRACE_PCI_NVME_COPY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_COPY) || \
    false)

static inline void _nocheck__trace_pci_nvme_copy(uint16_t cid, uint32_t nsid, uint16_t nr, uint8_t format)
{
    if (trace_event_get_state(TRACE_PCI_NVME_COPY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 33 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_copy " "cid %"PRIu16" nsid %"PRIu32" nr %"PRIu16" format 0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, nsid, nr, format);
#line 1589 "trace/trace-hw_nvme.h"
        } else {
#line 33 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_copy " "cid %"PRIu16" nsid %"PRIu32" nr %"PRIu16" format 0x%"PRIx8"" "\n", cid, nsid, nr, format);
#line 1593 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_copy(uint16_t cid, uint32_t nsid, uint16_t nr, uint8_t format)
{
    if (true) {
        _nocheck__trace_pci_nvme_copy(cid, nsid, nr, format);
    }
}

#define TRACE_PCI_NVME_COPY_SOURCE_RANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_COPY_SOURCE_RANGE) || \
    false)

static inline void _nocheck__trace_pci_nvme_copy_source_range(uint64_t slba, uint32_t nlb)
{
    if (trace_event_get_state(TRACE_PCI_NVME_COPY_SOURCE_RANGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 34 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_copy_source_range " "slba 0x%"PRIx64" nlb %"PRIu32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slba, nlb);
#line 1620 "trace/trace-hw_nvme.h"
        } else {
#line 34 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_copy_source_range " "slba 0x%"PRIx64" nlb %"PRIu32"" "\n", slba, nlb);
#line 1624 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_copy_source_range(uint64_t slba, uint32_t nlb)
{
    if (true) {
        _nocheck__trace_pci_nvme_copy_source_range(slba, nlb);
    }
}

#define TRACE_PCI_NVME_COPY_OUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_COPY_OUT) || \
    false)

static inline void _nocheck__trace_pci_nvme_copy_out(uint64_t slba, uint32_t nlb)
{
    if (trace_event_get_state(TRACE_PCI_NVME_COPY_OUT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 35 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_copy_out " "slba 0x%"PRIx64" nlb %"PRIu32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slba, nlb);
#line 1651 "trace/trace-hw_nvme.h"
        } else {
#line 35 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_copy_out " "slba 0x%"PRIx64" nlb %"PRIu32"" "\n", slba, nlb);
#line 1655 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_copy_out(uint64_t slba, uint32_t nlb)
{
    if (true) {
        _nocheck__trace_pci_nvme_copy_out(slba, nlb);
    }
}

#define TRACE_PCI_NVME_VERIFY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_VERIFY) || \
    false)

static inline void _nocheck__trace_pci_nvme_verify(uint16_t cid, uint32_t nsid, uint64_t slba, uint32_t nlb)
{
    if (trace_event_get_state(TRACE_PCI_NVME_VERIFY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 36 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_verify " "cid %"PRIu16" nsid %"PRIu32" slba 0x%"PRIx64" nlb %"PRIu32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, nsid, slba, nlb);
#line 1682 "trace/trace-hw_nvme.h"
        } else {
#line 36 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_verify " "cid %"PRIu16" nsid %"PRIu32" slba 0x%"PRIx64" nlb %"PRIu32"" "\n", cid, nsid, slba, nlb);
#line 1686 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_verify(uint16_t cid, uint32_t nsid, uint64_t slba, uint32_t nlb)
{
    if (true) {
        _nocheck__trace_pci_nvme_verify(cid, nsid, slba, nlb);
    }
}

#define TRACE_PCI_NVME_VERIFY_MDATA_IN_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_VERIFY_MDATA_IN_CB) || \
    false)

static inline void _nocheck__trace_pci_nvme_verify_mdata_in_cb(uint16_t cid, const char * blkname)
{
    if (trace_event_get_state(TRACE_PCI_NVME_VERIFY_MDATA_IN_CB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 37 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_verify_mdata_in_cb " "cid %"PRIu16" blk '%s'" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, blkname);
#line 1713 "trace/trace-hw_nvme.h"
        } else {
#line 37 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_verify_mdata_in_cb " "cid %"PRIu16" blk '%s'" "\n", cid, blkname);
#line 1717 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_verify_mdata_in_cb(uint16_t cid, const char * blkname)
{
    if (true) {
        _nocheck__trace_pci_nvme_verify_mdata_in_cb(cid, blkname);
    }
}

#define TRACE_PCI_NVME_VERIFY_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_VERIFY_CB) || \
    false)

static inline void _nocheck__trace_pci_nvme_verify_cb(uint16_t cid, uint8_t prinfo, uint16_t apptag, uint16_t appmask, uint32_t reftag)
{
    if (trace_event_get_state(TRACE_PCI_NVME_VERIFY_CB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 38 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_verify_cb " "cid %"PRIu16" prinfo 0x%"PRIx8" apptag 0x%"PRIx16" appmask 0x%"PRIx16" reftag 0x%"PRIx32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, prinfo, apptag, appmask, reftag);
#line 1744 "trace/trace-hw_nvme.h"
        } else {
#line 38 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_verify_cb " "cid %"PRIu16" prinfo 0x%"PRIx8" apptag 0x%"PRIx16" appmask 0x%"PRIx16" reftag 0x%"PRIx32"" "\n", cid, prinfo, apptag, appmask, reftag);
#line 1748 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_verify_cb(uint16_t cid, uint8_t prinfo, uint16_t apptag, uint16_t appmask, uint32_t reftag)
{
    if (true) {
        _nocheck__trace_pci_nvme_verify_cb(cid, prinfo, apptag, appmask, reftag);
    }
}

#define TRACE_PCI_NVME_RW_COMPLETE_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_RW_COMPLETE_CB) || \
    false)

static inline void _nocheck__trace_pci_nvme_rw_complete_cb(uint16_t cid, const char * blkname)
{
    if (trace_event_get_state(TRACE_PCI_NVME_RW_COMPLETE_CB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 39 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_rw_complete_cb " "cid %"PRIu16" blk '%s'" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, blkname);
#line 1775 "trace/trace-hw_nvme.h"
        } else {
#line 39 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_rw_complete_cb " "cid %"PRIu16" blk '%s'" "\n", cid, blkname);
#line 1779 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_rw_complete_cb(uint16_t cid, const char * blkname)
{
    if (true) {
        _nocheck__trace_pci_nvme_rw_complete_cb(cid, blkname);
    }
}

#define TRACE_PCI_NVME_BLOCK_STATUS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_BLOCK_STATUS) || \
    false)

static inline void _nocheck__trace_pci_nvme_block_status(int64_t offset, int64_t bytes, int64_t pnum, int ret, bool zeroed)
{
    if (trace_event_get_state(TRACE_PCI_NVME_BLOCK_STATUS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 40 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_block_status " "offset %"PRId64" bytes %"PRId64" pnum %"PRId64" ret 0x%x zeroed %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, bytes, pnum, ret, zeroed);
#line 1806 "trace/trace-hw_nvme.h"
        } else {
#line 40 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_block_status " "offset %"PRId64" bytes %"PRId64" pnum %"PRId64" ret 0x%x zeroed %d" "\n", offset, bytes, pnum, ret, zeroed);
#line 1810 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_block_status(int64_t offset, int64_t bytes, int64_t pnum, int ret, bool zeroed)
{
    if (true) {
        _nocheck__trace_pci_nvme_block_status(offset, bytes, pnum, ret, zeroed);
    }
}

#define TRACE_PCI_NVME_DSM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_DSM) || \
    false)

static inline void _nocheck__trace_pci_nvme_dsm(uint32_t nr, uint32_t attr)
{
    if (trace_event_get_state(TRACE_PCI_NVME_DSM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 41 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_dsm " "nr %"PRIu32" attr 0x%"PRIx32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , nr, attr);
#line 1837 "trace/trace-hw_nvme.h"
        } else {
#line 41 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_dsm " "nr %"PRIu32" attr 0x%"PRIx32"" "\n", nr, attr);
#line 1841 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_dsm(uint32_t nr, uint32_t attr)
{
    if (true) {
        _nocheck__trace_pci_nvme_dsm(nr, attr);
    }
}

#define TRACE_PCI_NVME_DSM_DEALLOCATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_DSM_DEALLOCATE) || \
    false)

static inline void _nocheck__trace_pci_nvme_dsm_deallocate(uint64_t slba, uint32_t nlb)
{
    if (trace_event_get_state(TRACE_PCI_NVME_DSM_DEALLOCATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 42 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_dsm_deallocate " "slba %"PRIu64" nlb %"PRIu32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slba, nlb);
#line 1868 "trace/trace-hw_nvme.h"
        } else {
#line 42 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_dsm_deallocate " "slba %"PRIu64" nlb %"PRIu32"" "\n", slba, nlb);
#line 1872 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_dsm_deallocate(uint64_t slba, uint32_t nlb)
{
    if (true) {
        _nocheck__trace_pci_nvme_dsm_deallocate(slba, nlb);
    }
}

#define TRACE_PCI_NVME_DSM_SINGLE_RANGE_LIMIT_EXCEEDED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_DSM_SINGLE_RANGE_LIMIT_EXCEEDED) || \
    false)

static inline void _nocheck__trace_pci_nvme_dsm_single_range_limit_exceeded(uint32_t nlb, uint32_t dmrsl)
{
    if (trace_event_get_state(TRACE_PCI_NVME_DSM_SINGLE_RANGE_LIMIT_EXCEEDED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 43 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_dsm_single_range_limit_exceeded " "nlb %"PRIu32" dmrsl %"PRIu32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , nlb, dmrsl);
#line 1899 "trace/trace-hw_nvme.h"
        } else {
#line 43 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_dsm_single_range_limit_exceeded " "nlb %"PRIu32" dmrsl %"PRIu32"" "\n", nlb, dmrsl);
#line 1903 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_dsm_single_range_limit_exceeded(uint32_t nlb, uint32_t dmrsl)
{
    if (true) {
        _nocheck__trace_pci_nvme_dsm_single_range_limit_exceeded(nlb, dmrsl);
    }
}

#define TRACE_PCI_NVME_COMPARE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_COMPARE) || \
    false)

static inline void _nocheck__trace_pci_nvme_compare(uint16_t cid, uint32_t nsid, uint64_t slba, uint32_t nlb)
{
    if (trace_event_get_state(TRACE_PCI_NVME_COMPARE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 44 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_compare " "cid %"PRIu16" nsid %"PRIu32" slba 0x%"PRIx64" nlb %"PRIu32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, nsid, slba, nlb);
#line 1930 "trace/trace-hw_nvme.h"
        } else {
#line 44 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_compare " "cid %"PRIu16" nsid %"PRIu32" slba 0x%"PRIx64" nlb %"PRIu32"" "\n", cid, nsid, slba, nlb);
#line 1934 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_compare(uint16_t cid, uint32_t nsid, uint64_t slba, uint32_t nlb)
{
    if (true) {
        _nocheck__trace_pci_nvme_compare(cid, nsid, slba, nlb);
    }
}

#define TRACE_PCI_NVME_COMPARE_DATA_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_COMPARE_DATA_CB) || \
    false)

static inline void _nocheck__trace_pci_nvme_compare_data_cb(uint16_t cid)
{
    if (trace_event_get_state(TRACE_PCI_NVME_COMPARE_DATA_CB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 45 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_compare_data_cb " "cid %"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid);
#line 1961 "trace/trace-hw_nvme.h"
        } else {
#line 45 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_compare_data_cb " "cid %"PRIu16"" "\n", cid);
#line 1965 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_compare_data_cb(uint16_t cid)
{
    if (true) {
        _nocheck__trace_pci_nvme_compare_data_cb(cid);
    }
}

#define TRACE_PCI_NVME_COMPARE_MDATA_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_COMPARE_MDATA_CB) || \
    false)

static inline void _nocheck__trace_pci_nvme_compare_mdata_cb(uint16_t cid)
{
    if (trace_event_get_state(TRACE_PCI_NVME_COMPARE_MDATA_CB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 46 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_compare_mdata_cb " "cid %"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid);
#line 1992 "trace/trace-hw_nvme.h"
        } else {
#line 46 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_compare_mdata_cb " "cid %"PRIu16"" "\n", cid);
#line 1996 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_compare_mdata_cb(uint16_t cid)
{
    if (true) {
        _nocheck__trace_pci_nvme_compare_mdata_cb(cid);
    }
}

#define TRACE_PCI_NVME_AIO_DISCARD_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_AIO_DISCARD_CB) || \
    false)

static inline void _nocheck__trace_pci_nvme_aio_discard_cb(uint16_t cid)
{
    if (trace_event_get_state(TRACE_PCI_NVME_AIO_DISCARD_CB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 47 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_aio_discard_cb " "cid %"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid);
#line 2023 "trace/trace-hw_nvme.h"
        } else {
#line 47 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_aio_discard_cb " "cid %"PRIu16"" "\n", cid);
#line 2027 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_aio_discard_cb(uint16_t cid)
{
    if (true) {
        _nocheck__trace_pci_nvme_aio_discard_cb(cid);
    }
}

#define TRACE_PCI_NVME_AIO_COPY_IN_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_AIO_COPY_IN_CB) || \
    false)

static inline void _nocheck__trace_pci_nvme_aio_copy_in_cb(uint16_t cid)
{
    if (trace_event_get_state(TRACE_PCI_NVME_AIO_COPY_IN_CB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 48 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_aio_copy_in_cb " "cid %"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid);
#line 2054 "trace/trace-hw_nvme.h"
        } else {
#line 48 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_aio_copy_in_cb " "cid %"PRIu16"" "\n", cid);
#line 2058 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_aio_copy_in_cb(uint16_t cid)
{
    if (true) {
        _nocheck__trace_pci_nvme_aio_copy_in_cb(cid);
    }
}

#define TRACE_PCI_NVME_AIO_FLUSH_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_AIO_FLUSH_CB) || \
    false)

static inline void _nocheck__trace_pci_nvme_aio_flush_cb(uint16_t cid, const char * blkname)
{
    if (trace_event_get_state(TRACE_PCI_NVME_AIO_FLUSH_CB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 49 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_aio_flush_cb " "cid %"PRIu16" blk '%s'" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, blkname);
#line 2085 "trace/trace-hw_nvme.h"
        } else {
#line 49 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_aio_flush_cb " "cid %"PRIu16" blk '%s'" "\n", cid, blkname);
#line 2089 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_aio_flush_cb(uint16_t cid, const char * blkname)
{
    if (true) {
        _nocheck__trace_pci_nvme_aio_flush_cb(cid, blkname);
    }
}

#define TRACE_PCI_NVME_CREATE_SQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_CREATE_SQ) || \
    false)

static inline void _nocheck__trace_pci_nvme_create_sq(uint64_t addr, uint16_t sqid, uint16_t cqid, uint16_t qsize, uint16_t qflags)
{
    if (trace_event_get_state(TRACE_PCI_NVME_CREATE_SQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 50 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_create_sq " "create submission queue, addr=0x%"PRIx64", sqid=%"PRIu16", cqid=%"PRIu16", qsize=%"PRIu16", qflags=%"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, sqid, cqid, qsize, qflags);
#line 2116 "trace/trace-hw_nvme.h"
        } else {
#line 50 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_create_sq " "create submission queue, addr=0x%"PRIx64", sqid=%"PRIu16", cqid=%"PRIu16", qsize=%"PRIu16", qflags=%"PRIu16"" "\n", addr, sqid, cqid, qsize, qflags);
#line 2120 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_create_sq(uint64_t addr, uint16_t sqid, uint16_t cqid, uint16_t qsize, uint16_t qflags)
{
    if (true) {
        _nocheck__trace_pci_nvme_create_sq(addr, sqid, cqid, qsize, qflags);
    }
}

#define TRACE_PCI_NVME_CREATE_CQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_CREATE_CQ) || \
    false)

static inline void _nocheck__trace_pci_nvme_create_cq(uint64_t addr, uint16_t cqid, uint16_t vector, uint16_t size, uint16_t qflags, int ien)
{
    if (trace_event_get_state(TRACE_PCI_NVME_CREATE_CQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 51 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_create_cq " "create completion queue, addr=0x%"PRIx64", cqid=%"PRIu16", vector=%"PRIu16", qsize=%"PRIu16", qflags=%"PRIu16", ien=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, cqid, vector, size, qflags, ien);
#line 2147 "trace/trace-hw_nvme.h"
        } else {
#line 51 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_create_cq " "create completion queue, addr=0x%"PRIx64", cqid=%"PRIu16", vector=%"PRIu16", qsize=%"PRIu16", qflags=%"PRIu16", ien=%d" "\n", addr, cqid, vector, size, qflags, ien);
#line 2151 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_create_cq(uint64_t addr, uint16_t cqid, uint16_t vector, uint16_t size, uint16_t qflags, int ien)
{
    if (true) {
        _nocheck__trace_pci_nvme_create_cq(addr, cqid, vector, size, qflags, ien);
    }
}

#define TRACE_PCI_NVME_DEL_SQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_DEL_SQ) || \
    false)

static inline void _nocheck__trace_pci_nvme_del_sq(uint16_t qid)
{
    if (trace_event_get_state(TRACE_PCI_NVME_DEL_SQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 52 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_del_sq " "deleting submission queue sqid=%"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qid);
#line 2178 "trace/trace-hw_nvme.h"
        } else {
#line 52 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_del_sq " "deleting submission queue sqid=%"PRIu16"" "\n", qid);
#line 2182 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_del_sq(uint16_t qid)
{
    if (true) {
        _nocheck__trace_pci_nvme_del_sq(qid);
    }
}

#define TRACE_PCI_NVME_DEL_CQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_DEL_CQ) || \
    false)

static inline void _nocheck__trace_pci_nvme_del_cq(uint16_t cqid)
{
    if (trace_event_get_state(TRACE_PCI_NVME_DEL_CQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 53 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_del_cq " "deleted completion queue, cqid=%"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cqid);
#line 2209 "trace/trace-hw_nvme.h"
        } else {
#line 53 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_del_cq " "deleted completion queue, cqid=%"PRIu16"" "\n", cqid);
#line 2213 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_del_cq(uint16_t cqid)
{
    if (true) {
        _nocheck__trace_pci_nvme_del_cq(cqid);
    }
}

#define TRACE_PCI_NVME_IDENTIFY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_IDENTIFY) || \
    false)

static inline void _nocheck__trace_pci_nvme_identify(uint16_t cid, uint8_t cns, uint16_t ctrlid, uint8_t csi)
{
    if (trace_event_get_state(TRACE_PCI_NVME_IDENTIFY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 54 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_identify " "cid %"PRIu16" cns 0x%"PRIx8" ctrlid %"PRIu16" csi 0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, cns, ctrlid, csi);
#line 2240 "trace/trace-hw_nvme.h"
        } else {
#line 54 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_identify " "cid %"PRIu16" cns 0x%"PRIx8" ctrlid %"PRIu16" csi 0x%"PRIx8"" "\n", cid, cns, ctrlid, csi);
#line 2244 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_identify(uint16_t cid, uint8_t cns, uint16_t ctrlid, uint8_t csi)
{
    if (true) {
        _nocheck__trace_pci_nvme_identify(cid, cns, ctrlid, csi);
    }
}

#define TRACE_PCI_NVME_IDENTIFY_CTRL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_IDENTIFY_CTRL) || \
    false)

static inline void _nocheck__trace_pci_nvme_identify_ctrl(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_IDENTIFY_CTRL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 55 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_identify_ctrl " "identify controller" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2271 "trace/trace-hw_nvme.h"
        } else {
#line 55 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_identify_ctrl " "identify controller" "\n");
#line 2275 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_identify_ctrl(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_identify_ctrl();
    }
}

#define TRACE_PCI_NVME_IDENTIFY_CTRL_CSI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_IDENTIFY_CTRL_CSI) || \
    false)

static inline void _nocheck__trace_pci_nvme_identify_ctrl_csi(uint8_t csi)
{
    if (trace_event_get_state(TRACE_PCI_NVME_IDENTIFY_CTRL_CSI) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 56 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_identify_ctrl_csi " "identify controller, csi=0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , csi);
#line 2302 "trace/trace-hw_nvme.h"
        } else {
#line 56 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_identify_ctrl_csi " "identify controller, csi=0x%"PRIx8"" "\n", csi);
#line 2306 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_identify_ctrl_csi(uint8_t csi)
{
    if (true) {
        _nocheck__trace_pci_nvme_identify_ctrl_csi(csi);
    }
}

#define TRACE_PCI_NVME_IDENTIFY_NS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_IDENTIFY_NS) || \
    false)

static inline void _nocheck__trace_pci_nvme_identify_ns(uint32_t ns)
{
    if (trace_event_get_state(TRACE_PCI_NVME_IDENTIFY_NS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 57 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_identify_ns " "nsid %"PRIu32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ns);
#line 2333 "trace/trace-hw_nvme.h"
        } else {
#line 57 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_identify_ns " "nsid %"PRIu32"" "\n", ns);
#line 2337 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_identify_ns(uint32_t ns)
{
    if (true) {
        _nocheck__trace_pci_nvme_identify_ns(ns);
    }
}

#define TRACE_PCI_NVME_IDENTIFY_CTRL_LIST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_IDENTIFY_CTRL_LIST) || \
    false)

static inline void _nocheck__trace_pci_nvme_identify_ctrl_list(uint8_t cns, uint16_t cntid)
{
    if (trace_event_get_state(TRACE_PCI_NVME_IDENTIFY_CTRL_LIST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 58 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_identify_ctrl_list " "cns 0x%"PRIx8" cntid %"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cns, cntid);
#line 2364 "trace/trace-hw_nvme.h"
        } else {
#line 58 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_identify_ctrl_list " "cns 0x%"PRIx8" cntid %"PRIu16"" "\n", cns, cntid);
#line 2368 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_identify_ctrl_list(uint8_t cns, uint16_t cntid)
{
    if (true) {
        _nocheck__trace_pci_nvme_identify_ctrl_list(cns, cntid);
    }
}

#define TRACE_PCI_NVME_IDENTIFY_NS_CSI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_IDENTIFY_NS_CSI) || \
    false)

static inline void _nocheck__trace_pci_nvme_identify_ns_csi(uint32_t ns, uint8_t csi)
{
    if (trace_event_get_state(TRACE_PCI_NVME_IDENTIFY_NS_CSI) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 59 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_identify_ns_csi " "nsid=%"PRIu32", csi=0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ns, csi);
#line 2395 "trace/trace-hw_nvme.h"
        } else {
#line 59 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_identify_ns_csi " "nsid=%"PRIu32", csi=0x%"PRIx8"" "\n", ns, csi);
#line 2399 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_identify_ns_csi(uint32_t ns, uint8_t csi)
{
    if (true) {
        _nocheck__trace_pci_nvme_identify_ns_csi(ns, csi);
    }
}

#define TRACE_PCI_NVME_IDENTIFY_NSLIST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_IDENTIFY_NSLIST) || \
    false)

static inline void _nocheck__trace_pci_nvme_identify_nslist(uint32_t ns)
{
    if (trace_event_get_state(TRACE_PCI_NVME_IDENTIFY_NSLIST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 60 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_identify_nslist " "nsid %"PRIu32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ns);
#line 2426 "trace/trace-hw_nvme.h"
        } else {
#line 60 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_identify_nslist " "nsid %"PRIu32"" "\n", ns);
#line 2430 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_identify_nslist(uint32_t ns)
{
    if (true) {
        _nocheck__trace_pci_nvme_identify_nslist(ns);
    }
}

#define TRACE_PCI_NVME_IDENTIFY_NSLIST_CSI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_IDENTIFY_NSLIST_CSI) || \
    false)

static inline void _nocheck__trace_pci_nvme_identify_nslist_csi(uint16_t ns, uint8_t csi)
{
    if (trace_event_get_state(TRACE_PCI_NVME_IDENTIFY_NSLIST_CSI) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 61 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_identify_nslist_csi " "nsid=%"PRIu16", csi=0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ns, csi);
#line 2457 "trace/trace-hw_nvme.h"
        } else {
#line 61 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_identify_nslist_csi " "nsid=%"PRIu16", csi=0x%"PRIx8"" "\n", ns, csi);
#line 2461 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_identify_nslist_csi(uint16_t ns, uint8_t csi)
{
    if (true) {
        _nocheck__trace_pci_nvme_identify_nslist_csi(ns, csi);
    }
}

#define TRACE_PCI_NVME_IDENTIFY_CMD_SET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_IDENTIFY_CMD_SET) || \
    false)

static inline void _nocheck__trace_pci_nvme_identify_cmd_set(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_IDENTIFY_CMD_SET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 62 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_identify_cmd_set " "identify i/o command set" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2488 "trace/trace-hw_nvme.h"
        } else {
#line 62 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_identify_cmd_set " "identify i/o command set" "\n");
#line 2492 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_identify_cmd_set(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_identify_cmd_set();
    }
}

#define TRACE_PCI_NVME_IDENTIFY_NS_DESCR_LIST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_IDENTIFY_NS_DESCR_LIST) || \
    false)

static inline void _nocheck__trace_pci_nvme_identify_ns_descr_list(uint32_t ns)
{
    if (trace_event_get_state(TRACE_PCI_NVME_IDENTIFY_NS_DESCR_LIST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 63 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_identify_ns_descr_list " "nsid %"PRIu32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ns);
#line 2519 "trace/trace-hw_nvme.h"
        } else {
#line 63 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_identify_ns_descr_list " "nsid %"PRIu32"" "\n", ns);
#line 2523 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_identify_ns_descr_list(uint32_t ns)
{
    if (true) {
        _nocheck__trace_pci_nvme_identify_ns_descr_list(ns);
    }
}

#define TRACE_PCI_NVME_GET_LOG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_GET_LOG) || \
    false)

static inline void _nocheck__trace_pci_nvme_get_log(uint16_t cid, uint8_t lid, uint8_t lsp, uint8_t rae, uint32_t len, uint64_t off)
{
    if (trace_event_get_state(TRACE_PCI_NVME_GET_LOG) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 64 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_get_log " "cid %"PRIu16" lid 0x%"PRIx8" lsp 0x%"PRIx8" rae 0x%"PRIx8" len %"PRIu32" off %"PRIu64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, lid, lsp, rae, len, off);
#line 2550 "trace/trace-hw_nvme.h"
        } else {
#line 64 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_get_log " "cid %"PRIu16" lid 0x%"PRIx8" lsp 0x%"PRIx8" rae 0x%"PRIx8" len %"PRIu32" off %"PRIu64"" "\n", cid, lid, lsp, rae, len, off);
#line 2554 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_get_log(uint16_t cid, uint8_t lid, uint8_t lsp, uint8_t rae, uint32_t len, uint64_t off)
{
    if (true) {
        _nocheck__trace_pci_nvme_get_log(cid, lid, lsp, rae, len, off);
    }
}

#define TRACE_PCI_NVME_GETFEAT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_GETFEAT) || \
    false)

static inline void _nocheck__trace_pci_nvme_getfeat(uint16_t cid, uint32_t nsid, uint8_t fid, uint8_t sel, uint32_t cdw11)
{
    if (trace_event_get_state(TRACE_PCI_NVME_GETFEAT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 65 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_getfeat " "cid %"PRIu16" nsid 0x%"PRIx32" fid 0x%"PRIx8" sel 0x%"PRIx8" cdw11 0x%"PRIx32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, nsid, fid, sel, cdw11);
#line 2581 "trace/trace-hw_nvme.h"
        } else {
#line 65 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_getfeat " "cid %"PRIu16" nsid 0x%"PRIx32" fid 0x%"PRIx8" sel 0x%"PRIx8" cdw11 0x%"PRIx32"" "\n", cid, nsid, fid, sel, cdw11);
#line 2585 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_getfeat(uint16_t cid, uint32_t nsid, uint8_t fid, uint8_t sel, uint32_t cdw11)
{
    if (true) {
        _nocheck__trace_pci_nvme_getfeat(cid, nsid, fid, sel, cdw11);
    }
}

#define TRACE_PCI_NVME_SETFEAT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_SETFEAT) || \
    false)

static inline void _nocheck__trace_pci_nvme_setfeat(uint16_t cid, uint32_t nsid, uint8_t fid, uint8_t save, uint32_t cdw11)
{
    if (trace_event_get_state(TRACE_PCI_NVME_SETFEAT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 66 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_setfeat " "cid %"PRIu16" nsid 0x%"PRIx32" fid 0x%"PRIx8" save 0x%"PRIx8" cdw11 0x%"PRIx32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, nsid, fid, save, cdw11);
#line 2612 "trace/trace-hw_nvme.h"
        } else {
#line 66 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_setfeat " "cid %"PRIu16" nsid 0x%"PRIx32" fid 0x%"PRIx8" save 0x%"PRIx8" cdw11 0x%"PRIx32"" "\n", cid, nsid, fid, save, cdw11);
#line 2616 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_setfeat(uint16_t cid, uint32_t nsid, uint8_t fid, uint8_t save, uint32_t cdw11)
{
    if (true) {
        _nocheck__trace_pci_nvme_setfeat(cid, nsid, fid, save, cdw11);
    }
}

#define TRACE_PCI_NVME_GETFEAT_VWCACHE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_GETFEAT_VWCACHE) || \
    false)

static inline void _nocheck__trace_pci_nvme_getfeat_vwcache(const char* result)
{
    if (trace_event_get_state(TRACE_PCI_NVME_GETFEAT_VWCACHE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 67 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_getfeat_vwcache " "get feature volatile write cache, result=%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , result);
#line 2643 "trace/trace-hw_nvme.h"
        } else {
#line 67 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_getfeat_vwcache " "get feature volatile write cache, result=%s" "\n", result);
#line 2647 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_getfeat_vwcache(const char* result)
{
    if (true) {
        _nocheck__trace_pci_nvme_getfeat_vwcache(result);
    }
}

#define TRACE_PCI_NVME_GETFEAT_NUMQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_GETFEAT_NUMQ) || \
    false)

static inline void _nocheck__trace_pci_nvme_getfeat_numq(int result)
{
    if (trace_event_get_state(TRACE_PCI_NVME_GETFEAT_NUMQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 68 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_getfeat_numq " "get feature number of queues, result=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , result);
#line 2674 "trace/trace-hw_nvme.h"
        } else {
#line 68 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_getfeat_numq " "get feature number of queues, result=%d" "\n", result);
#line 2678 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_getfeat_numq(int result)
{
    if (true) {
        _nocheck__trace_pci_nvme_getfeat_numq(result);
    }
}

#define TRACE_PCI_NVME_SETFEAT_NUMQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_SETFEAT_NUMQ) || \
    false)

static inline void _nocheck__trace_pci_nvme_setfeat_numq(int reqcq, int reqsq, int gotcq, int gotsq)
{
    if (trace_event_get_state(TRACE_PCI_NVME_SETFEAT_NUMQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 69 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_setfeat_numq " "requested cq_count=%d sq_count=%d, responding with cq_count=%d sq_count=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reqcq, reqsq, gotcq, gotsq);
#line 2705 "trace/trace-hw_nvme.h"
        } else {
#line 69 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_setfeat_numq " "requested cq_count=%d sq_count=%d, responding with cq_count=%d sq_count=%d" "\n", reqcq, reqsq, gotcq, gotsq);
#line 2709 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_setfeat_numq(int reqcq, int reqsq, int gotcq, int gotsq)
{
    if (true) {
        _nocheck__trace_pci_nvme_setfeat_numq(reqcq, reqsq, gotcq, gotsq);
    }
}

#define TRACE_PCI_NVME_SETFEAT_TIMESTAMP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_SETFEAT_TIMESTAMP) || \
    false)

static inline void _nocheck__trace_pci_nvme_setfeat_timestamp(uint64_t ts)
{
    if (trace_event_get_state(TRACE_PCI_NVME_SETFEAT_TIMESTAMP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 70 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_setfeat_timestamp " "set feature timestamp = 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ts);
#line 2736 "trace/trace-hw_nvme.h"
        } else {
#line 70 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_setfeat_timestamp " "set feature timestamp = 0x%"PRIx64"" "\n", ts);
#line 2740 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_setfeat_timestamp(uint64_t ts)
{
    if (true) {
        _nocheck__trace_pci_nvme_setfeat_timestamp(ts);
    }
}

#define TRACE_PCI_NVME_GETFEAT_TIMESTAMP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_GETFEAT_TIMESTAMP) || \
    false)

static inline void _nocheck__trace_pci_nvme_getfeat_timestamp(uint64_t ts)
{
    if (trace_event_get_state(TRACE_PCI_NVME_GETFEAT_TIMESTAMP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 71 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_getfeat_timestamp " "get feature timestamp = 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ts);
#line 2767 "trace/trace-hw_nvme.h"
        } else {
#line 71 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_getfeat_timestamp " "get feature timestamp = 0x%"PRIx64"" "\n", ts);
#line 2771 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_getfeat_timestamp(uint64_t ts)
{
    if (true) {
        _nocheck__trace_pci_nvme_getfeat_timestamp(ts);
    }
}

#define TRACE_PCI_NVME_PROCESS_AERS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_PROCESS_AERS) || \
    false)

static inline void _nocheck__trace_pci_nvme_process_aers(int queued)
{
    if (trace_event_get_state(TRACE_PCI_NVME_PROCESS_AERS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 72 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_process_aers " "queued %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , queued);
#line 2798 "trace/trace-hw_nvme.h"
        } else {
#line 72 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_process_aers " "queued %d" "\n", queued);
#line 2802 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_process_aers(int queued)
{
    if (true) {
        _nocheck__trace_pci_nvme_process_aers(queued);
    }
}

#define TRACE_PCI_NVME_AER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_AER) || \
    false)

static inline void _nocheck__trace_pci_nvme_aer(uint16_t cid)
{
    if (trace_event_get_state(TRACE_PCI_NVME_AER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 73 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_aer " "cid %"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid);
#line 2829 "trace/trace-hw_nvme.h"
        } else {
#line 73 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_aer " "cid %"PRIu16"" "\n", cid);
#line 2833 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_aer(uint16_t cid)
{
    if (true) {
        _nocheck__trace_pci_nvme_aer(cid);
    }
}

#define TRACE_PCI_NVME_AER_AERL_EXCEEDED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_AER_AERL_EXCEEDED) || \
    false)

static inline void _nocheck__trace_pci_nvme_aer_aerl_exceeded(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_AER_AERL_EXCEEDED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 74 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_aer_aerl_exceeded " "aerl exceeded" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2860 "trace/trace-hw_nvme.h"
        } else {
#line 74 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_aer_aerl_exceeded " "aerl exceeded" "\n");
#line 2864 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_aer_aerl_exceeded(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_aer_aerl_exceeded();
    }
}

#define TRACE_PCI_NVME_AER_MASKED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_AER_MASKED) || \
    false)

static inline void _nocheck__trace_pci_nvme_aer_masked(uint8_t type, uint8_t mask)
{
    if (trace_event_get_state(TRACE_PCI_NVME_AER_MASKED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 75 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_aer_masked " "type 0x%"PRIx8" mask 0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, mask);
#line 2891 "trace/trace-hw_nvme.h"
        } else {
#line 75 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_aer_masked " "type 0x%"PRIx8" mask 0x%"PRIx8"" "\n", type, mask);
#line 2895 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_aer_masked(uint8_t type, uint8_t mask)
{
    if (true) {
        _nocheck__trace_pci_nvme_aer_masked(type, mask);
    }
}

#define TRACE_PCI_NVME_AER_POST_CQE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_AER_POST_CQE) || \
    false)

static inline void _nocheck__trace_pci_nvme_aer_post_cqe(uint8_t typ, uint8_t info, uint8_t log_page)
{
    if (trace_event_get_state(TRACE_PCI_NVME_AER_POST_CQE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 76 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_aer_post_cqe " "type 0x%"PRIx8" info 0x%"PRIx8" lid 0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , typ, info, log_page);
#line 2922 "trace/trace-hw_nvme.h"
        } else {
#line 76 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_aer_post_cqe " "type 0x%"PRIx8" info 0x%"PRIx8" lid 0x%"PRIx8"" "\n", typ, info, log_page);
#line 2926 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_aer_post_cqe(uint8_t typ, uint8_t info, uint8_t log_page)
{
    if (true) {
        _nocheck__trace_pci_nvme_aer_post_cqe(typ, info, log_page);
    }
}

#define TRACE_PCI_NVME_NS_ATTACHMENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_NS_ATTACHMENT) || \
    false)

static inline void _nocheck__trace_pci_nvme_ns_attachment(uint16_t cid, uint8_t sel)
{
    if (trace_event_get_state(TRACE_PCI_NVME_NS_ATTACHMENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 77 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ns_attachment " "cid %"PRIu16", sel=0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, sel);
#line 2953 "trace/trace-hw_nvme.h"
        } else {
#line 77 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_ns_attachment " "cid %"PRIu16", sel=0x%"PRIx8"" "\n", cid, sel);
#line 2957 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_ns_attachment(uint16_t cid, uint8_t sel)
{
    if (true) {
        _nocheck__trace_pci_nvme_ns_attachment(cid, sel);
    }
}

#define TRACE_PCI_NVME_NS_ATTACHMENT_ATTACH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_NS_ATTACHMENT_ATTACH) || \
    false)

static inline void _nocheck__trace_pci_nvme_ns_attachment_attach(uint16_t cntlid, uint32_t nsid)
{
    if (trace_event_get_state(TRACE_PCI_NVME_NS_ATTACHMENT_ATTACH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 78 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ns_attachment_attach " "cntlid=0x%"PRIx16", nsid=0x%"PRIx32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cntlid, nsid);
#line 2984 "trace/trace-hw_nvme.h"
        } else {
#line 78 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_ns_attachment_attach " "cntlid=0x%"PRIx16", nsid=0x%"PRIx32"" "\n", cntlid, nsid);
#line 2988 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_ns_attachment_attach(uint16_t cntlid, uint32_t nsid)
{
    if (true) {
        _nocheck__trace_pci_nvme_ns_attachment_attach(cntlid, nsid);
    }
}

#define TRACE_PCI_NVME_ENQUEUE_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ENQUEUE_EVENT) || \
    false)

static inline void _nocheck__trace_pci_nvme_enqueue_event(uint8_t typ, uint8_t info, uint8_t log_page)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ENQUEUE_EVENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 79 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_enqueue_event " "type 0x%"PRIx8" info 0x%"PRIx8" lid 0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , typ, info, log_page);
#line 3015 "trace/trace-hw_nvme.h"
        } else {
#line 79 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_enqueue_event " "type 0x%"PRIx8" info 0x%"PRIx8" lid 0x%"PRIx8"" "\n", typ, info, log_page);
#line 3019 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_enqueue_event(uint8_t typ, uint8_t info, uint8_t log_page)
{
    if (true) {
        _nocheck__trace_pci_nvme_enqueue_event(typ, info, log_page);
    }
}

#define TRACE_PCI_NVME_ENQUEUE_EVENT_NOQUEUE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ENQUEUE_EVENT_NOQUEUE) || \
    false)

static inline void _nocheck__trace_pci_nvme_enqueue_event_noqueue(int queued)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ENQUEUE_EVENT_NOQUEUE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 80 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_enqueue_event_noqueue " "queued %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , queued);
#line 3046 "trace/trace-hw_nvme.h"
        } else {
#line 80 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_enqueue_event_noqueue " "queued %d" "\n", queued);
#line 3050 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_enqueue_event_noqueue(int queued)
{
    if (true) {
        _nocheck__trace_pci_nvme_enqueue_event_noqueue(queued);
    }
}

#define TRACE_PCI_NVME_ENQUEUE_EVENT_MASKED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ENQUEUE_EVENT_MASKED) || \
    false)

static inline void _nocheck__trace_pci_nvme_enqueue_event_masked(uint8_t typ)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ENQUEUE_EVENT_MASKED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 81 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_enqueue_event_masked " "type 0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , typ);
#line 3077 "trace/trace-hw_nvme.h"
        } else {
#line 81 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_enqueue_event_masked " "type 0x%"PRIx8"" "\n", typ);
#line 3081 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_enqueue_event_masked(uint8_t typ)
{
    if (true) {
        _nocheck__trace_pci_nvme_enqueue_event_masked(typ);
    }
}

#define TRACE_PCI_NVME_NO_OUTSTANDING_AERS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_NO_OUTSTANDING_AERS) || \
    false)

static inline void _nocheck__trace_pci_nvme_no_outstanding_aers(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_NO_OUTSTANDING_AERS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 82 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_no_outstanding_aers " "ignoring event; no outstanding AERs" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 3108 "trace/trace-hw_nvme.h"
        } else {
#line 82 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_no_outstanding_aers " "ignoring event; no outstanding AERs" "\n");
#line 3112 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_no_outstanding_aers(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_no_outstanding_aers();
    }
}

#define TRACE_PCI_NVME_ENQUEUE_REQ_COMPLETION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ENQUEUE_REQ_COMPLETION) || \
    false)

static inline void _nocheck__trace_pci_nvme_enqueue_req_completion(uint16_t cid, uint16_t cqid, uint32_t dw0, uint32_t dw1, uint16_t status)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ENQUEUE_REQ_COMPLETION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 83 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_enqueue_req_completion " "cid %"PRIu16" cqid %"PRIu16" dw0 0x%"PRIx32" dw1 0x%"PRIx32" status 0x%"PRIx16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, cqid, dw0, dw1, status);
#line 3139 "trace/trace-hw_nvme.h"
        } else {
#line 83 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_enqueue_req_completion " "cid %"PRIu16" cqid %"PRIu16" dw0 0x%"PRIx32" dw1 0x%"PRIx32" status 0x%"PRIx16"" "\n", cid, cqid, dw0, dw1, status);
#line 3143 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_enqueue_req_completion(uint16_t cid, uint16_t cqid, uint32_t dw0, uint32_t dw1, uint16_t status)
{
    if (true) {
        _nocheck__trace_pci_nvme_enqueue_req_completion(cid, cqid, dw0, dw1, status);
    }
}

#define TRACE_PCI_NVME_MMIO_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MMIO_READ) || \
    false)

static inline void _nocheck__trace_pci_nvme_mmio_read(uint64_t addr, unsigned size)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MMIO_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 84 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_mmio_read " "addr 0x%"PRIx64" size %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, size);
#line 3170 "trace/trace-hw_nvme.h"
        } else {
#line 84 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_mmio_read " "addr 0x%"PRIx64" size %d" "\n", addr, size);
#line 3174 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_mmio_read(uint64_t addr, unsigned size)
{
    if (true) {
        _nocheck__trace_pci_nvme_mmio_read(addr, size);
    }
}

#define TRACE_PCI_NVME_MMIO_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MMIO_WRITE) || \
    false)

static inline void _nocheck__trace_pci_nvme_mmio_write(uint64_t addr, uint64_t data, unsigned size)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MMIO_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 85 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_mmio_write " "addr 0x%"PRIx64" data 0x%"PRIx64" size %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, data, size);
#line 3201 "trace/trace-hw_nvme.h"
        } else {
#line 85 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_mmio_write " "addr 0x%"PRIx64" data 0x%"PRIx64" size %d" "\n", addr, data, size);
#line 3205 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_mmio_write(uint64_t addr, uint64_t data, unsigned size)
{
    if (true) {
        _nocheck__trace_pci_nvme_mmio_write(addr, data, size);
    }
}

#define TRACE_PCI_NVME_MMIO_DOORBELL_CQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MMIO_DOORBELL_CQ) || \
    false)

static inline void _nocheck__trace_pci_nvme_mmio_doorbell_cq(uint16_t cqid, uint16_t new_head)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MMIO_DOORBELL_CQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 86 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_mmio_doorbell_cq " "cqid %"PRIu16" new_head %"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cqid, new_head);
#line 3232 "trace/trace-hw_nvme.h"
        } else {
#line 86 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_mmio_doorbell_cq " "cqid %"PRIu16" new_head %"PRIu16"" "\n", cqid, new_head);
#line 3236 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_mmio_doorbell_cq(uint16_t cqid, uint16_t new_head)
{
    if (true) {
        _nocheck__trace_pci_nvme_mmio_doorbell_cq(cqid, new_head);
    }
}

#define TRACE_PCI_NVME_MMIO_DOORBELL_SQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MMIO_DOORBELL_SQ) || \
    false)

static inline void _nocheck__trace_pci_nvme_mmio_doorbell_sq(uint16_t sqid, uint16_t new_tail)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MMIO_DOORBELL_SQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 87 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_mmio_doorbell_sq " "sqid %"PRIu16" new_tail %"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , sqid, new_tail);
#line 3263 "trace/trace-hw_nvme.h"
        } else {
#line 87 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_mmio_doorbell_sq " "sqid %"PRIu16" new_tail %"PRIu16"" "\n", sqid, new_tail);
#line 3267 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_mmio_doorbell_sq(uint16_t sqid, uint16_t new_tail)
{
    if (true) {
        _nocheck__trace_pci_nvme_mmio_doorbell_sq(sqid, new_tail);
    }
}

#define TRACE_PCI_NVME_MMIO_INTM_SET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MMIO_INTM_SET) || \
    false)

static inline void _nocheck__trace_pci_nvme_mmio_intm_set(uint64_t data, uint64_t new_mask)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MMIO_INTM_SET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 88 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_mmio_intm_set " "wrote MMIO, interrupt mask set, data=0x%"PRIx64", new_mask=0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , data, new_mask);
#line 3294 "trace/trace-hw_nvme.h"
        } else {
#line 88 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_mmio_intm_set " "wrote MMIO, interrupt mask set, data=0x%"PRIx64", new_mask=0x%"PRIx64"" "\n", data, new_mask);
#line 3298 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_mmio_intm_set(uint64_t data, uint64_t new_mask)
{
    if (true) {
        _nocheck__trace_pci_nvme_mmio_intm_set(data, new_mask);
    }
}

#define TRACE_PCI_NVME_MMIO_INTM_CLR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MMIO_INTM_CLR) || \
    false)

static inline void _nocheck__trace_pci_nvme_mmio_intm_clr(uint64_t data, uint64_t new_mask)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MMIO_INTM_CLR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 89 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_mmio_intm_clr " "wrote MMIO, interrupt mask clr, data=0x%"PRIx64", new_mask=0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , data, new_mask);
#line 3325 "trace/trace-hw_nvme.h"
        } else {
#line 89 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_mmio_intm_clr " "wrote MMIO, interrupt mask clr, data=0x%"PRIx64", new_mask=0x%"PRIx64"" "\n", data, new_mask);
#line 3329 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_mmio_intm_clr(uint64_t data, uint64_t new_mask)
{
    if (true) {
        _nocheck__trace_pci_nvme_mmio_intm_clr(data, new_mask);
    }
}

#define TRACE_PCI_NVME_MMIO_CFG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MMIO_CFG) || \
    false)

static inline void _nocheck__trace_pci_nvme_mmio_cfg(uint64_t data)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MMIO_CFG) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 90 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_mmio_cfg " "wrote MMIO, config controller config=0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , data);
#line 3356 "trace/trace-hw_nvme.h"
        } else {
#line 90 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_mmio_cfg " "wrote MMIO, config controller config=0x%"PRIx64"" "\n", data);
#line 3360 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_mmio_cfg(uint64_t data)
{
    if (true) {
        _nocheck__trace_pci_nvme_mmio_cfg(data);
    }
}

#define TRACE_PCI_NVME_MMIO_AQATTR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MMIO_AQATTR) || \
    false)

static inline void _nocheck__trace_pci_nvme_mmio_aqattr(uint64_t data)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MMIO_AQATTR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 91 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_mmio_aqattr " "wrote MMIO, admin queue attributes=0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , data);
#line 3387 "trace/trace-hw_nvme.h"
        } else {
#line 91 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_mmio_aqattr " "wrote MMIO, admin queue attributes=0x%"PRIx64"" "\n", data);
#line 3391 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_mmio_aqattr(uint64_t data)
{
    if (true) {
        _nocheck__trace_pci_nvme_mmio_aqattr(data);
    }
}

#define TRACE_PCI_NVME_MMIO_ASQADDR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MMIO_ASQADDR) || \
    false)

static inline void _nocheck__trace_pci_nvme_mmio_asqaddr(uint64_t data)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MMIO_ASQADDR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 92 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_mmio_asqaddr " "wrote MMIO, admin submission queue address=0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , data);
#line 3418 "trace/trace-hw_nvme.h"
        } else {
#line 92 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_mmio_asqaddr " "wrote MMIO, admin submission queue address=0x%"PRIx64"" "\n", data);
#line 3422 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_mmio_asqaddr(uint64_t data)
{
    if (true) {
        _nocheck__trace_pci_nvme_mmio_asqaddr(data);
    }
}

#define TRACE_PCI_NVME_MMIO_ACQADDR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MMIO_ACQADDR) || \
    false)

static inline void _nocheck__trace_pci_nvme_mmio_acqaddr(uint64_t data)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MMIO_ACQADDR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 93 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_mmio_acqaddr " "wrote MMIO, admin completion queue address=0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , data);
#line 3449 "trace/trace-hw_nvme.h"
        } else {
#line 93 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_mmio_acqaddr " "wrote MMIO, admin completion queue address=0x%"PRIx64"" "\n", data);
#line 3453 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_mmio_acqaddr(uint64_t data)
{
    if (true) {
        _nocheck__trace_pci_nvme_mmio_acqaddr(data);
    }
}

#define TRACE_PCI_NVME_MMIO_ASQADDR_HI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MMIO_ASQADDR_HI) || \
    false)

static inline void _nocheck__trace_pci_nvme_mmio_asqaddr_hi(uint64_t data, uint64_t new_addr)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MMIO_ASQADDR_HI) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 94 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_mmio_asqaddr_hi " "wrote MMIO, admin submission queue high half=0x%"PRIx64", new_address=0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , data, new_addr);
#line 3480 "trace/trace-hw_nvme.h"
        } else {
#line 94 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_mmio_asqaddr_hi " "wrote MMIO, admin submission queue high half=0x%"PRIx64", new_address=0x%"PRIx64"" "\n", data, new_addr);
#line 3484 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_mmio_asqaddr_hi(uint64_t data, uint64_t new_addr)
{
    if (true) {
        _nocheck__trace_pci_nvme_mmio_asqaddr_hi(data, new_addr);
    }
}

#define TRACE_PCI_NVME_MMIO_ACQADDR_HI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MMIO_ACQADDR_HI) || \
    false)

static inline void _nocheck__trace_pci_nvme_mmio_acqaddr_hi(uint64_t data, uint64_t new_addr)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MMIO_ACQADDR_HI) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 95 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_mmio_acqaddr_hi " "wrote MMIO, admin completion queue high half=0x%"PRIx64", new_address=0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , data, new_addr);
#line 3511 "trace/trace-hw_nvme.h"
        } else {
#line 95 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_mmio_acqaddr_hi " "wrote MMIO, admin completion queue high half=0x%"PRIx64", new_address=0x%"PRIx64"" "\n", data, new_addr);
#line 3515 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_mmio_acqaddr_hi(uint64_t data, uint64_t new_addr)
{
    if (true) {
        _nocheck__trace_pci_nvme_mmio_acqaddr_hi(data, new_addr);
    }
}

#define TRACE_PCI_NVME_MMIO_START_SUCCESS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MMIO_START_SUCCESS) || \
    false)

static inline void _nocheck__trace_pci_nvme_mmio_start_success(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MMIO_START_SUCCESS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 96 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_mmio_start_success " "setting controller enable bit succeeded" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 3542 "trace/trace-hw_nvme.h"
        } else {
#line 96 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_mmio_start_success " "setting controller enable bit succeeded" "\n");
#line 3546 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_mmio_start_success(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_mmio_start_success();
    }
}

#define TRACE_PCI_NVME_MMIO_STOPPED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MMIO_STOPPED) || \
    false)

static inline void _nocheck__trace_pci_nvme_mmio_stopped(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MMIO_STOPPED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 97 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_mmio_stopped " "cleared controller enable bit" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 3573 "trace/trace-hw_nvme.h"
        } else {
#line 97 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_mmio_stopped " "cleared controller enable bit" "\n");
#line 3577 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_mmio_stopped(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_mmio_stopped();
    }
}

#define TRACE_PCI_NVME_MMIO_SHUTDOWN_SET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MMIO_SHUTDOWN_SET) || \
    false)

static inline void _nocheck__trace_pci_nvme_mmio_shutdown_set(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MMIO_SHUTDOWN_SET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 98 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_mmio_shutdown_set " "shutdown bit set" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 3604 "trace/trace-hw_nvme.h"
        } else {
#line 98 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_mmio_shutdown_set " "shutdown bit set" "\n");
#line 3608 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_mmio_shutdown_set(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_mmio_shutdown_set();
    }
}

#define TRACE_PCI_NVME_MMIO_SHUTDOWN_CLEARED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MMIO_SHUTDOWN_CLEARED) || \
    false)

static inline void _nocheck__trace_pci_nvme_mmio_shutdown_cleared(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MMIO_SHUTDOWN_CLEARED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 99 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_mmio_shutdown_cleared " "shutdown bit cleared" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 3635 "trace/trace-hw_nvme.h"
        } else {
#line 99 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_mmio_shutdown_cleared " "shutdown bit cleared" "\n");
#line 3639 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_mmio_shutdown_cleared(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_mmio_shutdown_cleared();
    }
}

#define TRACE_PCI_NVME_OPEN_ZONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_OPEN_ZONE) || \
    false)

static inline void _nocheck__trace_pci_nvme_open_zone(uint64_t slba, uint32_t zone_idx, int all)
{
    if (trace_event_get_state(TRACE_PCI_NVME_OPEN_ZONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 100 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_open_zone " "open zone, slba=%"PRIu64", idx=%"PRIu32", all=%"PRIi32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slba, zone_idx, all);
#line 3666 "trace/trace-hw_nvme.h"
        } else {
#line 100 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_open_zone " "open zone, slba=%"PRIu64", idx=%"PRIu32", all=%"PRIi32"" "\n", slba, zone_idx, all);
#line 3670 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_open_zone(uint64_t slba, uint32_t zone_idx, int all)
{
    if (true) {
        _nocheck__trace_pci_nvme_open_zone(slba, zone_idx, all);
    }
}

#define TRACE_PCI_NVME_CLOSE_ZONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_CLOSE_ZONE) || \
    false)

static inline void _nocheck__trace_pci_nvme_close_zone(uint64_t slba, uint32_t zone_idx, int all)
{
    if (trace_event_get_state(TRACE_PCI_NVME_CLOSE_ZONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 101 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_close_zone " "close zone, slba=%"PRIu64", idx=%"PRIu32", all=%"PRIi32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slba, zone_idx, all);
#line 3697 "trace/trace-hw_nvme.h"
        } else {
#line 101 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_close_zone " "close zone, slba=%"PRIu64", idx=%"PRIu32", all=%"PRIi32"" "\n", slba, zone_idx, all);
#line 3701 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_close_zone(uint64_t slba, uint32_t zone_idx, int all)
{
    if (true) {
        _nocheck__trace_pci_nvme_close_zone(slba, zone_idx, all);
    }
}

#define TRACE_PCI_NVME_FINISH_ZONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_FINISH_ZONE) || \
    false)

static inline void _nocheck__trace_pci_nvme_finish_zone(uint64_t slba, uint32_t zone_idx, int all)
{
    if (trace_event_get_state(TRACE_PCI_NVME_FINISH_ZONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 102 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_finish_zone " "finish zone, slba=%"PRIu64", idx=%"PRIu32", all=%"PRIi32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slba, zone_idx, all);
#line 3728 "trace/trace-hw_nvme.h"
        } else {
#line 102 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_finish_zone " "finish zone, slba=%"PRIu64", idx=%"PRIu32", all=%"PRIi32"" "\n", slba, zone_idx, all);
#line 3732 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_finish_zone(uint64_t slba, uint32_t zone_idx, int all)
{
    if (true) {
        _nocheck__trace_pci_nvme_finish_zone(slba, zone_idx, all);
    }
}

#define TRACE_PCI_NVME_RESET_ZONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_RESET_ZONE) || \
    false)

static inline void _nocheck__trace_pci_nvme_reset_zone(uint64_t slba, uint32_t zone_idx, int all)
{
    if (trace_event_get_state(TRACE_PCI_NVME_RESET_ZONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 103 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_reset_zone " "reset zone, slba=%"PRIu64", idx=%"PRIu32", all=%"PRIi32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slba, zone_idx, all);
#line 3759 "trace/trace-hw_nvme.h"
        } else {
#line 103 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_reset_zone " "reset zone, slba=%"PRIu64", idx=%"PRIu32", all=%"PRIi32"" "\n", slba, zone_idx, all);
#line 3763 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_reset_zone(uint64_t slba, uint32_t zone_idx, int all)
{
    if (true) {
        _nocheck__trace_pci_nvme_reset_zone(slba, zone_idx, all);
    }
}

#define TRACE_PCI_NVME_ZNS_ZONE_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ZNS_ZONE_RESET) || \
    false)

static inline void _nocheck__trace_pci_nvme_zns_zone_reset(uint64_t zslba)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ZNS_ZONE_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 104 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_zns_zone_reset " "zslba 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , zslba);
#line 3790 "trace/trace-hw_nvme.h"
        } else {
#line 104 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_zns_zone_reset " "zslba 0x%"PRIx64"" "\n", zslba);
#line 3794 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_zns_zone_reset(uint64_t zslba)
{
    if (true) {
        _nocheck__trace_pci_nvme_zns_zone_reset(zslba);
    }
}

#define TRACE_PCI_NVME_OFFLINE_ZONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_OFFLINE_ZONE) || \
    false)

static inline void _nocheck__trace_pci_nvme_offline_zone(uint64_t slba, uint32_t zone_idx, int all)
{
    if (trace_event_get_state(TRACE_PCI_NVME_OFFLINE_ZONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 105 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_offline_zone " "offline zone, slba=%"PRIu64", idx=%"PRIu32", all=%"PRIi32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slba, zone_idx, all);
#line 3821 "trace/trace-hw_nvme.h"
        } else {
#line 105 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_offline_zone " "offline zone, slba=%"PRIu64", idx=%"PRIu32", all=%"PRIi32"" "\n", slba, zone_idx, all);
#line 3825 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_offline_zone(uint64_t slba, uint32_t zone_idx, int all)
{
    if (true) {
        _nocheck__trace_pci_nvme_offline_zone(slba, zone_idx, all);
    }
}

#define TRACE_PCI_NVME_SET_DESCRIPTOR_EXTENSION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_SET_DESCRIPTOR_EXTENSION) || \
    false)

static inline void _nocheck__trace_pci_nvme_set_descriptor_extension(uint64_t slba, uint32_t zone_idx)
{
    if (trace_event_get_state(TRACE_PCI_NVME_SET_DESCRIPTOR_EXTENSION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 106 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_set_descriptor_extension " "set zone descriptor extension, slba=%"PRIu64", idx=%"PRIu32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slba, zone_idx);
#line 3852 "trace/trace-hw_nvme.h"
        } else {
#line 106 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_set_descriptor_extension " "set zone descriptor extension, slba=%"PRIu64", idx=%"PRIu32"" "\n", slba, zone_idx);
#line 3856 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_set_descriptor_extension(uint64_t slba, uint32_t zone_idx)
{
    if (true) {
        _nocheck__trace_pci_nvme_set_descriptor_extension(slba, zone_idx);
    }
}

#define TRACE_PCI_NVME_ZD_EXTENSION_SET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ZD_EXTENSION_SET) || \
    false)

static inline void _nocheck__trace_pci_nvme_zd_extension_set(uint32_t zone_idx)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ZD_EXTENSION_SET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 107 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_zd_extension_set " "set descriptor extension for zone_idx=%"PRIu32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , zone_idx);
#line 3883 "trace/trace-hw_nvme.h"
        } else {
#line 107 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_zd_extension_set " "set descriptor extension for zone_idx=%"PRIu32"" "\n", zone_idx);
#line 3887 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_zd_extension_set(uint32_t zone_idx)
{
    if (true) {
        _nocheck__trace_pci_nvme_zd_extension_set(zone_idx);
    }
}

#define TRACE_PCI_NVME_CLEAR_NS_CLOSE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_CLEAR_NS_CLOSE) || \
    false)

static inline void _nocheck__trace_pci_nvme_clear_ns_close(uint32_t state, uint64_t slba)
{
    if (trace_event_get_state(TRACE_PCI_NVME_CLEAR_NS_CLOSE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 108 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_clear_ns_close " "zone state=%"PRIu32", slba=%"PRIu64" transitioned to Closed state" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, slba);
#line 3914 "trace/trace-hw_nvme.h"
        } else {
#line 108 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_clear_ns_close " "zone state=%"PRIu32", slba=%"PRIu64" transitioned to Closed state" "\n", state, slba);
#line 3918 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_clear_ns_close(uint32_t state, uint64_t slba)
{
    if (true) {
        _nocheck__trace_pci_nvme_clear_ns_close(state, slba);
    }
}

#define TRACE_PCI_NVME_CLEAR_NS_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_CLEAR_NS_RESET) || \
    false)

static inline void _nocheck__trace_pci_nvme_clear_ns_reset(uint32_t state, uint64_t slba)
{
    if (trace_event_get_state(TRACE_PCI_NVME_CLEAR_NS_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 109 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_clear_ns_reset " "zone state=%"PRIu32", slba=%"PRIu64" transitioned to Empty state" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, slba);
#line 3945 "trace/trace-hw_nvme.h"
        } else {
#line 109 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_clear_ns_reset " "zone state=%"PRIu32", slba=%"PRIu64" transitioned to Empty state" "\n", state, slba);
#line 3949 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_clear_ns_reset(uint32_t state, uint64_t slba)
{
    if (true) {
        _nocheck__trace_pci_nvme_clear_ns_reset(state, slba);
    }
}

#define TRACE_PCI_NVME_ZONED_ZRWA_IMPLICIT_FLUSH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ZONED_ZRWA_IMPLICIT_FLUSH) || \
    false)

static inline void _nocheck__trace_pci_nvme_zoned_zrwa_implicit_flush(uint64_t zslba, uint32_t nlb)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ZONED_ZRWA_IMPLICIT_FLUSH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 110 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_zoned_zrwa_implicit_flush " "zslba 0x%"PRIx64" nlb %"PRIu32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , zslba, nlb);
#line 3976 "trace/trace-hw_nvme.h"
        } else {
#line 110 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_zoned_zrwa_implicit_flush " "zslba 0x%"PRIx64" nlb %"PRIu32"" "\n", zslba, nlb);
#line 3980 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_zoned_zrwa_implicit_flush(uint64_t zslba, uint32_t nlb)
{
    if (true) {
        _nocheck__trace_pci_nvme_zoned_zrwa_implicit_flush(zslba, nlb);
    }
}

#define TRACE_PCI_NVME_ERR_MDTS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_MDTS) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_mdts(size_t len)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_MDTS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 113 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_mdts " "len %zu" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , len);
#line 4007 "trace/trace-hw_nvme.h"
        } else {
#line 113 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_mdts " "len %zu" "\n", len);
#line 4011 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_mdts(size_t len)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_mdts(len);
    }
}

#define TRACE_PCI_NVME_ERR_ZASL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_ZASL) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_zasl(size_t len)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_ZASL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 114 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_zasl " "len %zu" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , len);
#line 4038 "trace/trace-hw_nvme.h"
        } else {
#line 114 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_zasl " "len %zu" "\n", len);
#line 4042 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_zasl(size_t len)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_zasl(len);
    }
}

#define TRACE_PCI_NVME_ERR_REQ_STATUS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_REQ_STATUS) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_req_status(uint16_t cid, uint32_t nsid, uint16_t status, uint8_t opc)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_REQ_STATUS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 115 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_req_status " "cid %"PRIu16" nsid %"PRIu32" status 0x%"PRIx16" opc 0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, nsid, status, opc);
#line 4069 "trace/trace-hw_nvme.h"
        } else {
#line 115 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_req_status " "cid %"PRIu16" nsid %"PRIu32" status 0x%"PRIx16" opc 0x%"PRIx8"" "\n", cid, nsid, status, opc);
#line 4073 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_req_status(uint16_t cid, uint32_t nsid, uint16_t status, uint8_t opc)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_req_status(cid, nsid, status, opc);
    }
}

#define TRACE_PCI_NVME_ERR_ADDR_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_ADDR_READ) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_addr_read(uint64_t addr)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_ADDR_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 116 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_addr_read " "addr 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 4100 "trace/trace-hw_nvme.h"
        } else {
#line 116 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_addr_read " "addr 0x%"PRIx64"" "\n", addr);
#line 4104 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_addr_read(uint64_t addr)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_addr_read(addr);
    }
}

#define TRACE_PCI_NVME_ERR_ADDR_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_ADDR_WRITE) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_addr_write(uint64_t addr)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_ADDR_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 117 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_addr_write " "addr 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 4131 "trace/trace-hw_nvme.h"
        } else {
#line 117 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_addr_write " "addr 0x%"PRIx64"" "\n", addr);
#line 4135 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_addr_write(uint64_t addr)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_addr_write(addr);
    }
}

#define TRACE_PCI_NVME_ERR_CFS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_CFS) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_cfs(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_CFS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 118 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_cfs " "controller fatal status" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 4162 "trace/trace-hw_nvme.h"
        } else {
#line 118 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_cfs " "controller fatal status" "\n");
#line 4166 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_cfs(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_cfs();
    }
}

#define TRACE_PCI_NVME_ERR_AIO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_AIO) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_aio(uint16_t cid, const char * errname, uint16_t status)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_AIO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 119 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_aio " "cid %"PRIu16" err '%s' status 0x%"PRIx16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, errname, status);
#line 4193 "trace/trace-hw_nvme.h"
        } else {
#line 119 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_aio " "cid %"PRIu16" err '%s' status 0x%"PRIx16"" "\n", cid, errname, status);
#line 4197 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_aio(uint16_t cid, const char * errname, uint16_t status)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_aio(cid, errname, status);
    }
}

#define TRACE_PCI_NVME_ERR_COPY_INVALID_FORMAT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_COPY_INVALID_FORMAT) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_copy_invalid_format(uint8_t format)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_COPY_INVALID_FORMAT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 120 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_copy_invalid_format " "format 0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , format);
#line 4224 "trace/trace-hw_nvme.h"
        } else {
#line 120 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_copy_invalid_format " "format 0x%"PRIx8"" "\n", format);
#line 4228 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_copy_invalid_format(uint8_t format)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_copy_invalid_format(format);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_SGLD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_SGLD) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_sgld(uint16_t cid, uint8_t typ)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_SGLD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 121 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_sgld " "cid %"PRIu16" type 0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, typ);
#line 4255 "trace/trace-hw_nvme.h"
        } else {
#line 121 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_invalid_sgld " "cid %"PRIu16" type 0x%"PRIx8"" "\n", cid, typ);
#line 4259 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_sgld(uint16_t cid, uint8_t typ)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_sgld(cid, typ);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_NUM_SGLD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_NUM_SGLD) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_num_sgld(uint16_t cid, uint8_t typ)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_NUM_SGLD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 122 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_num_sgld " "cid %"PRIu16" type 0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, typ);
#line 4286 "trace/trace-hw_nvme.h"
        } else {
#line 122 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_invalid_num_sgld " "cid %"PRIu16" type 0x%"PRIx8"" "\n", cid, typ);
#line 4290 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_num_sgld(uint16_t cid, uint8_t typ)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_num_sgld(cid, typ);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_SGL_EXCESS_LENGTH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_SGL_EXCESS_LENGTH) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_sgl_excess_length(uint32_t residual)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_SGL_EXCESS_LENGTH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 123 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_sgl_excess_length " "residual %"PRIu32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , residual);
#line 4317 "trace/trace-hw_nvme.h"
        } else {
#line 123 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_invalid_sgl_excess_length " "residual %"PRIu32"" "\n", residual);
#line 4321 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_sgl_excess_length(uint32_t residual)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_sgl_excess_length(residual);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_DMA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_DMA) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_dma(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_DMA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 124 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_dma " "PRP/SGL is too small for transfer size" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 4348 "trace/trace-hw_nvme.h"
        } else {
#line 124 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_invalid_dma " "PRP/SGL is too small for transfer size" "\n");
#line 4352 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_dma(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_dma();
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_PRPLIST_ENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_PRPLIST_ENT) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_prplist_ent(uint64_t prplist)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_PRPLIST_ENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 125 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_prplist_ent " "PRP list entry is not page aligned: 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , prplist);
#line 4379 "trace/trace-hw_nvme.h"
        } else {
#line 125 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_invalid_prplist_ent " "PRP list entry is not page aligned: 0x%"PRIx64"" "\n", prplist);
#line 4383 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_prplist_ent(uint64_t prplist)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_prplist_ent(prplist);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_PRP2_ALIGN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_PRP2_ALIGN) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_prp2_align(uint64_t prp2)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_PRP2_ALIGN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 126 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_prp2_align " "PRP2 is not page aligned: 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , prp2);
#line 4410 "trace/trace-hw_nvme.h"
        } else {
#line 126 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_invalid_prp2_align " "PRP2 is not page aligned: 0x%"PRIx64"" "\n", prp2);
#line 4414 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_prp2_align(uint64_t prp2)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_prp2_align(prp2);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_OPC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_OPC) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_opc(uint8_t opc)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_OPC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 127 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_opc " "invalid opcode 0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , opc);
#line 4441 "trace/trace-hw_nvme.h"
        } else {
#line 127 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_invalid_opc " "invalid opcode 0x%"PRIx8"" "\n", opc);
#line 4445 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_opc(uint8_t opc)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_opc(opc);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_ADMIN_OPC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_ADMIN_OPC) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_admin_opc(uint8_t opc)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_ADMIN_OPC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 128 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_admin_opc " "invalid admin opcode 0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , opc);
#line 4472 "trace/trace-hw_nvme.h"
        } else {
#line 128 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_invalid_admin_opc " "invalid admin opcode 0x%"PRIx8"" "\n", opc);
#line 4476 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_admin_opc(uint8_t opc)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_admin_opc(opc);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_LBA_RANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_LBA_RANGE) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_lba_range(uint64_t start, uint64_t len, uint64_t limit)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_LBA_RANGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 129 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_lba_range " "Invalid LBA start=%"PRIu64" len=%"PRIu64" limit=%"PRIu64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , start, len, limit);
#line 4503 "trace/trace-hw_nvme.h"
        } else {
#line 129 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_invalid_lba_range " "Invalid LBA start=%"PRIu64" len=%"PRIu64" limit=%"PRIu64"" "\n", start, len, limit);
#line 4507 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_lba_range(uint64_t start, uint64_t len, uint64_t limit)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_lba_range(start, len, limit);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_LOG_PAGE_OFFSET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_LOG_PAGE_OFFSET) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_log_page_offset(uint64_t ofs, uint64_t size)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_LOG_PAGE_OFFSET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 130 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_log_page_offset " "must be <= %"PRIu64", got %"PRIu64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ofs, size);
#line 4534 "trace/trace-hw_nvme.h"
        } else {
#line 130 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_invalid_log_page_offset " "must be <= %"PRIu64", got %"PRIu64"" "\n", ofs, size);
#line 4538 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_log_page_offset(uint64_t ofs, uint64_t size)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_log_page_offset(ofs, size);
    }
}

#define TRACE_PCI_NVME_ERR_CMB_INVALID_CBA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_CMB_INVALID_CBA) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_cmb_invalid_cba(uint64_t cmbmsc)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_CMB_INVALID_CBA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 131 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_cmb_invalid_cba " "cmbmsc 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmbmsc);
#line 4565 "trace/trace-hw_nvme.h"
        } else {
#line 131 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_cmb_invalid_cba " "cmbmsc 0x%"PRIx64"" "\n", cmbmsc);
#line 4569 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_cmb_invalid_cba(uint64_t cmbmsc)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_cmb_invalid_cba(cmbmsc);
    }
}

#define TRACE_PCI_NVME_ERR_CMB_NOT_ENABLED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_CMB_NOT_ENABLED) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_cmb_not_enabled(uint64_t cmbmsc)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_CMB_NOT_ENABLED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 132 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_cmb_not_enabled " "cmbmsc 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmbmsc);
#line 4596 "trace/trace-hw_nvme.h"
        } else {
#line 132 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_cmb_not_enabled " "cmbmsc 0x%"PRIx64"" "\n", cmbmsc);
#line 4600 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_cmb_not_enabled(uint64_t cmbmsc)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_cmb_not_enabled(cmbmsc);
    }
}

#define TRACE_PCI_NVME_ERR_UNALIGNED_ZONE_CMD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_UNALIGNED_ZONE_CMD) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_unaligned_zone_cmd(uint8_t action, uint64_t slba, uint64_t zslba)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_UNALIGNED_ZONE_CMD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 133 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_unaligned_zone_cmd " "unaligned zone op 0x%"PRIx32", got slba=%"PRIu64", zslba=%"PRIu64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , action, slba, zslba);
#line 4627 "trace/trace-hw_nvme.h"
        } else {
#line 133 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_unaligned_zone_cmd " "unaligned zone op 0x%"PRIx32", got slba=%"PRIu64", zslba=%"PRIu64"" "\n", action, slba, zslba);
#line 4631 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_unaligned_zone_cmd(uint8_t action, uint64_t slba, uint64_t zslba)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_unaligned_zone_cmd(action, slba, zslba);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_ZONE_STATE_TRANSITION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_ZONE_STATE_TRANSITION) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_zone_state_transition(uint8_t action, uint64_t slba, uint8_t attrs)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_ZONE_STATE_TRANSITION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 134 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_zone_state_transition " "action=0x%"PRIx8", slba=%"PRIu64", attrs=0x%"PRIx32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , action, slba, attrs);
#line 4658 "trace/trace-hw_nvme.h"
        } else {
#line 134 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_invalid_zone_state_transition " "action=0x%"PRIx8", slba=%"PRIu64", attrs=0x%"PRIx32"" "\n", action, slba, attrs);
#line 4662 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_zone_state_transition(uint8_t action, uint64_t slba, uint8_t attrs)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_zone_state_transition(action, slba, attrs);
    }
}

#define TRACE_PCI_NVME_ERR_WRITE_NOT_AT_WP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_WRITE_NOT_AT_WP) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_write_not_at_wp(uint64_t slba, uint64_t zone, uint64_t wp)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_WRITE_NOT_AT_WP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 135 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_write_not_at_wp " "writing at slba=%"PRIu64", zone=%"PRIu64", but wp=%"PRIu64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slba, zone, wp);
#line 4689 "trace/trace-hw_nvme.h"
        } else {
#line 135 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_write_not_at_wp " "writing at slba=%"PRIu64", zone=%"PRIu64", but wp=%"PRIu64"" "\n", slba, zone, wp);
#line 4693 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_write_not_at_wp(uint64_t slba, uint64_t zone, uint64_t wp)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_write_not_at_wp(slba, zone, wp);
    }
}

#define TRACE_PCI_NVME_ERR_APPEND_NOT_AT_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_APPEND_NOT_AT_START) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_append_not_at_start(uint64_t slba, uint64_t zone)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_APPEND_NOT_AT_START) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 136 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_append_not_at_start " "appending at slba=%"PRIu64", but zone=%"PRIu64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slba, zone);
#line 4720 "trace/trace-hw_nvme.h"
        } else {
#line 136 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_append_not_at_start " "appending at slba=%"PRIu64", but zone=%"PRIu64"" "\n", slba, zone);
#line 4724 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_append_not_at_start(uint64_t slba, uint64_t zone)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_append_not_at_start(slba, zone);
    }
}

#define TRACE_PCI_NVME_ERR_ZONE_IS_FULL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_ZONE_IS_FULL) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_zone_is_full(uint64_t zslba)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_ZONE_IS_FULL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 137 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_zone_is_full " "zslba 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , zslba);
#line 4751 "trace/trace-hw_nvme.h"
        } else {
#line 137 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_zone_is_full " "zslba 0x%"PRIx64"" "\n", zslba);
#line 4755 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_zone_is_full(uint64_t zslba)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_zone_is_full(zslba);
    }
}

#define TRACE_PCI_NVME_ERR_ZONE_IS_READ_ONLY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_ZONE_IS_READ_ONLY) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_zone_is_read_only(uint64_t zslba)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_ZONE_IS_READ_ONLY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 138 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_zone_is_read_only " "zslba 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , zslba);
#line 4782 "trace/trace-hw_nvme.h"
        } else {
#line 138 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_zone_is_read_only " "zslba 0x%"PRIx64"" "\n", zslba);
#line 4786 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_zone_is_read_only(uint64_t zslba)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_zone_is_read_only(zslba);
    }
}

#define TRACE_PCI_NVME_ERR_ZONE_IS_OFFLINE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_ZONE_IS_OFFLINE) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_zone_is_offline(uint64_t zslba)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_ZONE_IS_OFFLINE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 139 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_zone_is_offline " "zslba 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , zslba);
#line 4813 "trace/trace-hw_nvme.h"
        } else {
#line 139 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_zone_is_offline " "zslba 0x%"PRIx64"" "\n", zslba);
#line 4817 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_zone_is_offline(uint64_t zslba)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_zone_is_offline(zslba);
    }
}

#define TRACE_PCI_NVME_ERR_ZONE_BOUNDARY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_ZONE_BOUNDARY) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_zone_boundary(uint64_t slba, uint32_t nlb, uint64_t zcap)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_ZONE_BOUNDARY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 140 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_zone_boundary " "lba 0x%"PRIx64" nlb %"PRIu32" zcap 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slba, nlb, zcap);
#line 4844 "trace/trace-hw_nvme.h"
        } else {
#line 140 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_zone_boundary " "lba 0x%"PRIx64" nlb %"PRIu32" zcap 0x%"PRIx64"" "\n", slba, nlb, zcap);
#line 4848 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_zone_boundary(uint64_t slba, uint32_t nlb, uint64_t zcap)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_zone_boundary(slba, nlb, zcap);
    }
}

#define TRACE_PCI_NVME_ERR_ZONE_INVALID_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_ZONE_INVALID_WRITE) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_zone_invalid_write(uint64_t slba, uint64_t wp)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_ZONE_INVALID_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 141 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_zone_invalid_write " "lba 0x%"PRIx64" wp 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slba, wp);
#line 4875 "trace/trace-hw_nvme.h"
        } else {
#line 141 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_zone_invalid_write " "lba 0x%"PRIx64" wp 0x%"PRIx64"" "\n", slba, wp);
#line 4879 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_zone_invalid_write(uint64_t slba, uint64_t wp)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_zone_invalid_write(slba, wp);
    }
}

#define TRACE_PCI_NVME_ERR_ZONE_WRITE_NOT_OK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_ZONE_WRITE_NOT_OK) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_zone_write_not_ok(uint64_t slba, uint32_t nlb, uint16_t status)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_ZONE_WRITE_NOT_OK) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 142 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_zone_write_not_ok " "slba=%"PRIu64", nlb=%"PRIu32", status=0x%"PRIx16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slba, nlb, status);
#line 4906 "trace/trace-hw_nvme.h"
        } else {
#line 142 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_zone_write_not_ok " "slba=%"PRIu64", nlb=%"PRIu32", status=0x%"PRIx16"" "\n", slba, nlb, status);
#line 4910 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_zone_write_not_ok(uint64_t slba, uint32_t nlb, uint16_t status)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_zone_write_not_ok(slba, nlb, status);
    }
}

#define TRACE_PCI_NVME_ERR_ZONE_READ_NOT_OK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_ZONE_READ_NOT_OK) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_zone_read_not_ok(uint64_t slba, uint32_t nlb, uint16_t status)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_ZONE_READ_NOT_OK) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 143 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_zone_read_not_ok " "slba=%"PRIu64", nlb=%"PRIu32", status=0x%"PRIx16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slba, nlb, status);
#line 4937 "trace/trace-hw_nvme.h"
        } else {
#line 143 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_zone_read_not_ok " "slba=%"PRIu64", nlb=%"PRIu32", status=0x%"PRIx16"" "\n", slba, nlb, status);
#line 4941 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_zone_read_not_ok(uint64_t slba, uint32_t nlb, uint16_t status)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_zone_read_not_ok(slba, nlb, status);
    }
}

#define TRACE_PCI_NVME_ERR_INSUFF_ACTIVE_RES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INSUFF_ACTIVE_RES) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_insuff_active_res(uint32_t max_active)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INSUFF_ACTIVE_RES) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 144 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_insuff_active_res " "max_active=%"PRIu32" zone limit exceeded" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , max_active);
#line 4968 "trace/trace-hw_nvme.h"
        } else {
#line 144 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_insuff_active_res " "max_active=%"PRIu32" zone limit exceeded" "\n", max_active);
#line 4972 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_insuff_active_res(uint32_t max_active)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_insuff_active_res(max_active);
    }
}

#define TRACE_PCI_NVME_ERR_INSUFF_OPEN_RES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INSUFF_OPEN_RES) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_insuff_open_res(uint32_t max_open)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INSUFF_OPEN_RES) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 145 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_insuff_open_res " "max_open=%"PRIu32" zone limit exceeded" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , max_open);
#line 4999 "trace/trace-hw_nvme.h"
        } else {
#line 145 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_insuff_open_res " "max_open=%"PRIu32" zone limit exceeded" "\n", max_open);
#line 5003 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_insuff_open_res(uint32_t max_open)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_insuff_open_res(max_open);
    }
}

#define TRACE_PCI_NVME_ERR_ZD_EXTENSION_MAP_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_ZD_EXTENSION_MAP_ERROR) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_zd_extension_map_error(uint32_t zone_idx)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_ZD_EXTENSION_MAP_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 146 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_zd_extension_map_error " "can't map descriptor extension for zone_idx=%"PRIu32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , zone_idx);
#line 5030 "trace/trace-hw_nvme.h"
        } else {
#line 146 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_zd_extension_map_error " "can't map descriptor extension for zone_idx=%"PRIu32"" "\n", zone_idx);
#line 5034 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_zd_extension_map_error(uint32_t zone_idx)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_zd_extension_map_error(zone_idx);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_IOCSCI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_IOCSCI) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_iocsci(uint32_t idx)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_IOCSCI) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 147 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_iocsci " "unsupported command set combination index %"PRIu32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , idx);
#line 5061 "trace/trace-hw_nvme.h"
        } else {
#line 147 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_invalid_iocsci " "unsupported command set combination index %"PRIu32"" "\n", idx);
#line 5065 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_iocsci(uint32_t idx)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_iocsci(idx);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_DEL_SQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_DEL_SQ) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_del_sq(uint16_t qid)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_DEL_SQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 148 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_del_sq " "invalid submission queue deletion, sid=%"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qid);
#line 5092 "trace/trace-hw_nvme.h"
        } else {
#line 148 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_invalid_del_sq " "invalid submission queue deletion, sid=%"PRIu16"" "\n", qid);
#line 5096 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_del_sq(uint16_t qid)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_del_sq(qid);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_CQID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_CQID) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_create_sq_cqid(uint16_t cqid)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_CQID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 149 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_create_sq_cqid " "failed creating submission queue, invalid cqid=%"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cqid);
#line 5123 "trace/trace-hw_nvme.h"
        } else {
#line 149 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_invalid_create_sq_cqid " "failed creating submission queue, invalid cqid=%"PRIu16"" "\n", cqid);
#line 5127 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_create_sq_cqid(uint16_t cqid)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_create_sq_cqid(cqid);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_SQID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_SQID) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_create_sq_sqid(uint16_t sqid)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_SQID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 150 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_create_sq_sqid " "failed creating submission queue, invalid sqid=%"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , sqid);
#line 5154 "trace/trace-hw_nvme.h"
        } else {
#line 150 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_invalid_create_sq_sqid " "failed creating submission queue, invalid sqid=%"PRIu16"" "\n", sqid);
#line 5158 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_create_sq_sqid(uint16_t sqid)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_create_sq_sqid(sqid);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_SIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_SIZE) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_create_sq_size(uint16_t qsize)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_SIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 151 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_create_sq_size " "failed creating submission queue, invalid qsize=%"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qsize);
#line 5185 "trace/trace-hw_nvme.h"
        } else {
#line 151 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_invalid_create_sq_size " "failed creating submission queue, invalid qsize=%"PRIu16"" "\n", qsize);
#line 5189 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_create_sq_size(uint16_t qsize)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_create_sq_size(qsize);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_ADDR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_ADDR) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_create_sq_addr(uint64_t addr)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_ADDR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 152 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_create_sq_addr " "failed creating submission queue, addr=0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 5216 "trace/trace-hw_nvme.h"
        } else {
#line 152 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_invalid_create_sq_addr " "failed creating submission queue, addr=0x%"PRIx64"" "\n", addr);
#line 5220 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_create_sq_addr(uint64_t addr)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_create_sq_addr(addr);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_QFLAGS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_QFLAGS) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_create_sq_qflags(uint16_t qflags)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_QFLAGS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 153 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_create_sq_qflags " "failed creating submission queue, qflags=%"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qflags);
#line 5247 "trace/trace-hw_nvme.h"
        } else {
#line 153 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_invalid_create_sq_qflags " "failed creating submission queue, qflags=%"PRIu16"" "\n", qflags);
#line 5251 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_create_sq_qflags(uint16_t qflags)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_create_sq_qflags(qflags);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_DEL_CQ_CQID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_DEL_CQ_CQID) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_del_cq_cqid(uint16_t cqid)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_DEL_CQ_CQID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 154 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_del_cq_cqid " "failed deleting completion queue, cqid=%"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cqid);
#line 5278 "trace/trace-hw_nvme.h"
        } else {
#line 154 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_invalid_del_cq_cqid " "failed deleting completion queue, cqid=%"PRIu16"" "\n", cqid);
#line 5282 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_del_cq_cqid(uint16_t cqid)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_del_cq_cqid(cqid);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_DEL_CQ_NOTEMPTY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_DEL_CQ_NOTEMPTY) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_del_cq_notempty(uint16_t cqid)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_DEL_CQ_NOTEMPTY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 155 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_del_cq_notempty " "failed deleting completion queue, it is not empty, cqid=%"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cqid);
#line 5309 "trace/trace-hw_nvme.h"
        } else {
#line 155 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_invalid_del_cq_notempty " "failed deleting completion queue, it is not empty, cqid=%"PRIu16"" "\n", cqid);
#line 5313 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_del_cq_notempty(uint16_t cqid)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_del_cq_notempty(cqid);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_CQID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_CQID) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_create_cq_cqid(uint16_t cqid)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_CQID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 156 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_create_cq_cqid " "failed creating completion queue, cqid=%"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cqid);
#line 5340 "trace/trace-hw_nvme.h"
        } else {
#line 156 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_invalid_create_cq_cqid " "failed creating completion queue, cqid=%"PRIu16"" "\n", cqid);
#line 5344 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_create_cq_cqid(uint16_t cqid)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_create_cq_cqid(cqid);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_SIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_SIZE) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_create_cq_size(uint16_t size)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_SIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 157 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_create_cq_size " "failed creating completion queue, size=%"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , size);
#line 5371 "trace/trace-hw_nvme.h"
        } else {
#line 157 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_invalid_create_cq_size " "failed creating completion queue, size=%"PRIu16"" "\n", size);
#line 5375 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_create_cq_size(uint16_t size)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_create_cq_size(size);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_ADDR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_ADDR) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_create_cq_addr(uint64_t addr)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_ADDR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 158 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_create_cq_addr " "failed creating completion queue, addr=0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 5402 "trace/trace-hw_nvme.h"
        } else {
#line 158 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_invalid_create_cq_addr " "failed creating completion queue, addr=0x%"PRIx64"" "\n", addr);
#line 5406 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_create_cq_addr(uint64_t addr)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_create_cq_addr(addr);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_VECTOR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_VECTOR) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_create_cq_vector(uint16_t vector)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_VECTOR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 159 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_create_cq_vector " "failed creating completion queue, vector=%"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vector);
#line 5433 "trace/trace-hw_nvme.h"
        } else {
#line 159 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_invalid_create_cq_vector " "failed creating completion queue, vector=%"PRIu16"" "\n", vector);
#line 5437 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_create_cq_vector(uint16_t vector)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_create_cq_vector(vector);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_QFLAGS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_QFLAGS) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_create_cq_qflags(uint16_t qflags)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_QFLAGS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 160 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_create_cq_qflags " "failed creating completion queue, qflags=%"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qflags);
#line 5464 "trace/trace-hw_nvme.h"
        } else {
#line 160 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_invalid_create_cq_qflags " "failed creating completion queue, qflags=%"PRIu16"" "\n", qflags);
#line 5468 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_create_cq_qflags(uint16_t qflags)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_create_cq_qflags(qflags);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_IDENTIFY_CNS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_IDENTIFY_CNS) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_identify_cns(uint16_t cns)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_IDENTIFY_CNS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 161 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_identify_cns " "identify, invalid cns=0x%"PRIx16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cns);
#line 5495 "trace/trace-hw_nvme.h"
        } else {
#line 161 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_invalid_identify_cns " "identify, invalid cns=0x%"PRIx16"" "\n", cns);
#line 5499 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_identify_cns(uint16_t cns)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_identify_cns(cns);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_GETFEAT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_GETFEAT) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_getfeat(int dw10)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_GETFEAT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 162 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_getfeat " "invalid get features, dw10=0x%"PRIx32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dw10);
#line 5526 "trace/trace-hw_nvme.h"
        } else {
#line 162 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_invalid_getfeat " "invalid get features, dw10=0x%"PRIx32"" "\n", dw10);
#line 5530 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_getfeat(int dw10)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_getfeat(dw10);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_SETFEAT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_SETFEAT) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_setfeat(uint32_t dw10)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_SETFEAT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 163 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_setfeat " "invalid set features, dw10=0x%"PRIx32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dw10);
#line 5557 "trace/trace-hw_nvme.h"
        } else {
#line 163 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_invalid_setfeat " "invalid set features, dw10=0x%"PRIx32"" "\n", dw10);
#line 5561 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_setfeat(uint32_t dw10)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_setfeat(dw10);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_LOG_PAGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_LOG_PAGE) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_log_page(uint16_t cid, uint16_t lid)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_LOG_PAGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 164 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_log_page " "cid %"PRIu16" lid 0x%"PRIx16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, lid);
#line 5588 "trace/trace-hw_nvme.h"
        } else {
#line 164 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_invalid_log_page " "cid %"PRIu16" lid 0x%"PRIx16"" "\n", cid, lid);
#line 5592 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_log_page(uint16_t cid, uint16_t lid)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_log_page(cid, lid);
    }
}

#define TRACE_PCI_NVME_ERR_STARTFAIL_CQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_STARTFAIL_CQ) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_startfail_cq(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_STARTFAIL_CQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 165 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_startfail_cq " "nvme_start_ctrl failed because there are non-admin completion queues" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 5619 "trace/trace-hw_nvme.h"
        } else {
#line 165 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_startfail_cq " "nvme_start_ctrl failed because there are non-admin completion queues" "\n");
#line 5623 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_startfail_cq(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_startfail_cq();
    }
}

#define TRACE_PCI_NVME_ERR_STARTFAIL_SQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_STARTFAIL_SQ) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_startfail_sq(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_STARTFAIL_SQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 166 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_startfail_sq " "nvme_start_ctrl failed because there are non-admin submission queues" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 5650 "trace/trace-hw_nvme.h"
        } else {
#line 166 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_startfail_sq " "nvme_start_ctrl failed because there are non-admin submission queues" "\n");
#line 5654 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_startfail_sq(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_startfail_sq();
    }
}

#define TRACE_PCI_NVME_ERR_STARTFAIL_ASQ_MISALIGNED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_STARTFAIL_ASQ_MISALIGNED) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_startfail_asq_misaligned(uint64_t addr)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_STARTFAIL_ASQ_MISALIGNED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 167 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_startfail_asq_misaligned " "nvme_start_ctrl failed because the admin submission queue address is misaligned: 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 5681 "trace/trace-hw_nvme.h"
        } else {
#line 167 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_startfail_asq_misaligned " "nvme_start_ctrl failed because the admin submission queue address is misaligned: 0x%"PRIx64"" "\n", addr);
#line 5685 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_startfail_asq_misaligned(uint64_t addr)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_startfail_asq_misaligned(addr);
    }
}

#define TRACE_PCI_NVME_ERR_STARTFAIL_ACQ_MISALIGNED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_STARTFAIL_ACQ_MISALIGNED) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_startfail_acq_misaligned(uint64_t addr)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_STARTFAIL_ACQ_MISALIGNED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 168 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_startfail_acq_misaligned " "nvme_start_ctrl failed because the admin completion queue address is misaligned: 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 5712 "trace/trace-hw_nvme.h"
        } else {
#line 168 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_startfail_acq_misaligned " "nvme_start_ctrl failed because the admin completion queue address is misaligned: 0x%"PRIx64"" "\n", addr);
#line 5716 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_startfail_acq_misaligned(uint64_t addr)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_startfail_acq_misaligned(addr);
    }
}

#define TRACE_PCI_NVME_ERR_STARTFAIL_PAGE_TOO_SMALL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_STARTFAIL_PAGE_TOO_SMALL) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_startfail_page_too_small(uint8_t log2ps, uint8_t maxlog2ps)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_STARTFAIL_PAGE_TOO_SMALL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 169 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_startfail_page_too_small " "nvme_start_ctrl failed because the page size is too small: log2size=%u, min=%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , log2ps, maxlog2ps);
#line 5743 "trace/trace-hw_nvme.h"
        } else {
#line 169 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_startfail_page_too_small " "nvme_start_ctrl failed because the page size is too small: log2size=%u, min=%u" "\n", log2ps, maxlog2ps);
#line 5747 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_startfail_page_too_small(uint8_t log2ps, uint8_t maxlog2ps)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_startfail_page_too_small(log2ps, maxlog2ps);
    }
}

#define TRACE_PCI_NVME_ERR_STARTFAIL_PAGE_TOO_LARGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_STARTFAIL_PAGE_TOO_LARGE) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_startfail_page_too_large(uint8_t log2ps, uint8_t maxlog2ps)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_STARTFAIL_PAGE_TOO_LARGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 170 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_startfail_page_too_large " "nvme_start_ctrl failed because the page size is too large: log2size=%u, max=%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , log2ps, maxlog2ps);
#line 5774 "trace/trace-hw_nvme.h"
        } else {
#line 170 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_startfail_page_too_large " "nvme_start_ctrl failed because the page size is too large: log2size=%u, max=%u" "\n", log2ps, maxlog2ps);
#line 5778 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_startfail_page_too_large(uint8_t log2ps, uint8_t maxlog2ps)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_startfail_page_too_large(log2ps, maxlog2ps);
    }
}

#define TRACE_PCI_NVME_ERR_STARTFAIL_CQENT_TOO_SMALL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_STARTFAIL_CQENT_TOO_SMALL) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_startfail_cqent_too_small(uint8_t log2ps, uint8_t maxlog2ps)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_STARTFAIL_CQENT_TOO_SMALL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 171 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_startfail_cqent_too_small " "nvme_start_ctrl failed because the completion queue entry size is too small: log2size=%u, min=%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , log2ps, maxlog2ps);
#line 5805 "trace/trace-hw_nvme.h"
        } else {
#line 171 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_startfail_cqent_too_small " "nvme_start_ctrl failed because the completion queue entry size is too small: log2size=%u, min=%u" "\n", log2ps, maxlog2ps);
#line 5809 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_startfail_cqent_too_small(uint8_t log2ps, uint8_t maxlog2ps)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_startfail_cqent_too_small(log2ps, maxlog2ps);
    }
}

#define TRACE_PCI_NVME_ERR_STARTFAIL_CQENT_TOO_LARGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_STARTFAIL_CQENT_TOO_LARGE) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_startfail_cqent_too_large(uint8_t log2ps, uint8_t maxlog2ps)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_STARTFAIL_CQENT_TOO_LARGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 172 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_startfail_cqent_too_large " "nvme_start_ctrl failed because the completion queue entry size is too large: log2size=%u, max=%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , log2ps, maxlog2ps);
#line 5836 "trace/trace-hw_nvme.h"
        } else {
#line 172 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_startfail_cqent_too_large " "nvme_start_ctrl failed because the completion queue entry size is too large: log2size=%u, max=%u" "\n", log2ps, maxlog2ps);
#line 5840 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_startfail_cqent_too_large(uint8_t log2ps, uint8_t maxlog2ps)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_startfail_cqent_too_large(log2ps, maxlog2ps);
    }
}

#define TRACE_PCI_NVME_ERR_STARTFAIL_SQENT_TOO_SMALL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_STARTFAIL_SQENT_TOO_SMALL) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_startfail_sqent_too_small(uint8_t log2ps, uint8_t maxlog2ps)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_STARTFAIL_SQENT_TOO_SMALL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 173 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_startfail_sqent_too_small " "nvme_start_ctrl failed because the submission queue entry size is too small: log2size=%u, min=%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , log2ps, maxlog2ps);
#line 5867 "trace/trace-hw_nvme.h"
        } else {
#line 173 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_startfail_sqent_too_small " "nvme_start_ctrl failed because the submission queue entry size is too small: log2size=%u, min=%u" "\n", log2ps, maxlog2ps);
#line 5871 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_startfail_sqent_too_small(uint8_t log2ps, uint8_t maxlog2ps)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_startfail_sqent_too_small(log2ps, maxlog2ps);
    }
}

#define TRACE_PCI_NVME_ERR_STARTFAIL_SQENT_TOO_LARGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_STARTFAIL_SQENT_TOO_LARGE) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_startfail_sqent_too_large(uint8_t log2ps, uint8_t maxlog2ps)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_STARTFAIL_SQENT_TOO_LARGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 174 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_startfail_sqent_too_large " "nvme_start_ctrl failed because the submission queue entry size is too large: log2size=%u, max=%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , log2ps, maxlog2ps);
#line 5898 "trace/trace-hw_nvme.h"
        } else {
#line 174 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_startfail_sqent_too_large " "nvme_start_ctrl failed because the submission queue entry size is too large: log2size=%u, max=%u" "\n", log2ps, maxlog2ps);
#line 5902 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_startfail_sqent_too_large(uint8_t log2ps, uint8_t maxlog2ps)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_startfail_sqent_too_large(log2ps, maxlog2ps);
    }
}

#define TRACE_PCI_NVME_ERR_STARTFAIL_CSS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_STARTFAIL_CSS) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_startfail_css(uint8_t css)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_STARTFAIL_CSS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 175 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_startfail_css " "nvme_start_ctrl failed because invalid command set selected:%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , css);
#line 5929 "trace/trace-hw_nvme.h"
        } else {
#line 175 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_startfail_css " "nvme_start_ctrl failed because invalid command set selected:%u" "\n", css);
#line 5933 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_startfail_css(uint8_t css)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_startfail_css(css);
    }
}

#define TRACE_PCI_NVME_ERR_STARTFAIL_ASQENT_SZ_ZERO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_STARTFAIL_ASQENT_SZ_ZERO) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_startfail_asqent_sz_zero(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_STARTFAIL_ASQENT_SZ_ZERO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 176 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_startfail_asqent_sz_zero " "nvme_start_ctrl failed because the admin submission queue size is zero" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 5960 "trace/trace-hw_nvme.h"
        } else {
#line 176 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_startfail_asqent_sz_zero " "nvme_start_ctrl failed because the admin submission queue size is zero" "\n");
#line 5964 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_startfail_asqent_sz_zero(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_startfail_asqent_sz_zero();
    }
}

#define TRACE_PCI_NVME_ERR_STARTFAIL_ACQENT_SZ_ZERO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_STARTFAIL_ACQENT_SZ_ZERO) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_startfail_acqent_sz_zero(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_STARTFAIL_ACQENT_SZ_ZERO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 177 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_startfail_acqent_sz_zero " "nvme_start_ctrl failed because the admin completion queue size is zero" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 5991 "trace/trace-hw_nvme.h"
        } else {
#line 177 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_startfail_acqent_sz_zero " "nvme_start_ctrl failed because the admin completion queue size is zero" "\n");
#line 5995 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_startfail_acqent_sz_zero(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_startfail_acqent_sz_zero();
    }
}

#define TRACE_PCI_NVME_ERR_STARTFAIL_ZASL_TOO_SMALL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_STARTFAIL_ZASL_TOO_SMALL) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_startfail_zasl_too_small(uint32_t zasl, uint32_t pagesz)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_STARTFAIL_ZASL_TOO_SMALL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 178 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_startfail_zasl_too_small " "nvme_start_ctrl failed because zone append size limit %"PRIu32" is too small, needs to be >= %"PRIu32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , zasl, pagesz);
#line 6022 "trace/trace-hw_nvme.h"
        } else {
#line 178 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_startfail_zasl_too_small " "nvme_start_ctrl failed because zone append size limit %"PRIu32" is too small, needs to be >= %"PRIu32"" "\n", zasl, pagesz);
#line 6026 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_startfail_zasl_too_small(uint32_t zasl, uint32_t pagesz)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_startfail_zasl_too_small(zasl, pagesz);
    }
}

#define TRACE_PCI_NVME_ERR_STARTFAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_STARTFAIL) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_startfail(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_STARTFAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 179 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_startfail " "setting controller enable bit failed" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 6053 "trace/trace-hw_nvme.h"
        } else {
#line 179 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_startfail " "setting controller enable bit failed" "\n");
#line 6057 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_startfail(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_startfail();
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_MGMT_ACTION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_MGMT_ACTION) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_mgmt_action(uint8_t action)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_MGMT_ACTION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 180 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_mgmt_action " "action=0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , action);
#line 6084 "trace/trace-hw_nvme.h"
        } else {
#line 180 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_err_invalid_mgmt_action " "action=0x%"PRIx8"" "\n", action);
#line 6088 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_mgmt_action(uint8_t action)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_mgmt_action(action);
    }
}

#define TRACE_PCI_NVME_UB_MMIOWR_MISALIGNED32_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_MMIOWR_MISALIGNED32) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_mmiowr_misaligned32(uint64_t offset)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_MMIOWR_MISALIGNED32) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 183 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_mmiowr_misaligned32 " "MMIO write not 32-bit aligned, offset=0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset);
#line 6115 "trace/trace-hw_nvme.h"
        } else {
#line 183 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_ub_mmiowr_misaligned32 " "MMIO write not 32-bit aligned, offset=0x%"PRIx64"" "\n", offset);
#line 6119 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_ub_mmiowr_misaligned32(uint64_t offset)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_mmiowr_misaligned32(offset);
    }
}

#define TRACE_PCI_NVME_UB_MMIOWR_TOOSMALL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_MMIOWR_TOOSMALL) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_mmiowr_toosmall(uint64_t offset, unsigned size)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_MMIOWR_TOOSMALL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 184 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_mmiowr_toosmall " "MMIO write smaller than 32 bits, offset=0x%"PRIx64", size=%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, size);
#line 6146 "trace/trace-hw_nvme.h"
        } else {
#line 184 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_ub_mmiowr_toosmall " "MMIO write smaller than 32 bits, offset=0x%"PRIx64", size=%u" "\n", offset, size);
#line 6150 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_ub_mmiowr_toosmall(uint64_t offset, unsigned size)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_mmiowr_toosmall(offset, size);
    }
}

#define TRACE_PCI_NVME_UB_MMIOWR_INTMASK_WITH_MSIX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_MMIOWR_INTMASK_WITH_MSIX) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_mmiowr_intmask_with_msix(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_MMIOWR_INTMASK_WITH_MSIX) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 185 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_mmiowr_intmask_with_msix " "undefined access to interrupt mask set when MSI-X is enabled" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 6177 "trace/trace-hw_nvme.h"
        } else {
#line 185 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_ub_mmiowr_intmask_with_msix " "undefined access to interrupt mask set when MSI-X is enabled" "\n");
#line 6181 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_ub_mmiowr_intmask_with_msix(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_mmiowr_intmask_with_msix();
    }
}

#define TRACE_PCI_NVME_UB_MMIOWR_RO_CSTS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_MMIOWR_RO_CSTS) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_mmiowr_ro_csts(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_MMIOWR_RO_CSTS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 186 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_mmiowr_ro_csts " "attempted to set a read only bit of controller status" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 6208 "trace/trace-hw_nvme.h"
        } else {
#line 186 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_ub_mmiowr_ro_csts " "attempted to set a read only bit of controller status" "\n");
#line 6212 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_ub_mmiowr_ro_csts(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_mmiowr_ro_csts();
    }
}

#define TRACE_PCI_NVME_UB_MMIOWR_SSRESET_W1C_UNSUPPORTED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_MMIOWR_SSRESET_W1C_UNSUPPORTED) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_mmiowr_ssreset_w1c_unsupported(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_MMIOWR_SSRESET_W1C_UNSUPPORTED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 187 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_mmiowr_ssreset_w1c_unsupported " "attempted to W1C CSTS.NSSRO but CAP.NSSRS is zero (not supported)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 6239 "trace/trace-hw_nvme.h"
        } else {
#line 187 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_ub_mmiowr_ssreset_w1c_unsupported " "attempted to W1C CSTS.NSSRO but CAP.NSSRS is zero (not supported)" "\n");
#line 6243 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_ub_mmiowr_ssreset_w1c_unsupported(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_mmiowr_ssreset_w1c_unsupported();
    }
}

#define TRACE_PCI_NVME_UB_MMIOWR_SSRESET_UNSUPPORTED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_MMIOWR_SSRESET_UNSUPPORTED) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_mmiowr_ssreset_unsupported(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_MMIOWR_SSRESET_UNSUPPORTED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 188 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_mmiowr_ssreset_unsupported " "attempted NVM subsystem reset but CAP.NSSRS is zero (not supported)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 6270 "trace/trace-hw_nvme.h"
        } else {
#line 188 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_ub_mmiowr_ssreset_unsupported " "attempted NVM subsystem reset but CAP.NSSRS is zero (not supported)" "\n");
#line 6274 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_ub_mmiowr_ssreset_unsupported(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_mmiowr_ssreset_unsupported();
    }
}

#define TRACE_PCI_NVME_UB_MMIOWR_CMBLOC_RESERVED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_MMIOWR_CMBLOC_RESERVED) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_mmiowr_cmbloc_reserved(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_MMIOWR_CMBLOC_RESERVED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 189 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_mmiowr_cmbloc_reserved " "invalid write to reserved CMBLOC when CMBSZ is zero, ignored" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 6301 "trace/trace-hw_nvme.h"
        } else {
#line 189 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_ub_mmiowr_cmbloc_reserved " "invalid write to reserved CMBLOC when CMBSZ is zero, ignored" "\n");
#line 6305 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_ub_mmiowr_cmbloc_reserved(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_mmiowr_cmbloc_reserved();
    }
}

#define TRACE_PCI_NVME_UB_MMIOWR_CMBSZ_READONLY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_MMIOWR_CMBSZ_READONLY) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_mmiowr_cmbsz_readonly(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_MMIOWR_CMBSZ_READONLY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 190 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_mmiowr_cmbsz_readonly " "invalid write to read only CMBSZ, ignored" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 6332 "trace/trace-hw_nvme.h"
        } else {
#line 190 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_ub_mmiowr_cmbsz_readonly " "invalid write to read only CMBSZ, ignored" "\n");
#line 6336 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_ub_mmiowr_cmbsz_readonly(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_mmiowr_cmbsz_readonly();
    }
}

#define TRACE_PCI_NVME_UB_MMIOWR_PMRCAP_READONLY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_MMIOWR_PMRCAP_READONLY) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_mmiowr_pmrcap_readonly(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_MMIOWR_PMRCAP_READONLY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 191 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_mmiowr_pmrcap_readonly " "invalid write to read only PMRCAP, ignored" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 6363 "trace/trace-hw_nvme.h"
        } else {
#line 191 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_ub_mmiowr_pmrcap_readonly " "invalid write to read only PMRCAP, ignored" "\n");
#line 6367 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_ub_mmiowr_pmrcap_readonly(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_mmiowr_pmrcap_readonly();
    }
}

#define TRACE_PCI_NVME_UB_MMIOWR_PMRSTS_READONLY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_MMIOWR_PMRSTS_READONLY) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_mmiowr_pmrsts_readonly(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_MMIOWR_PMRSTS_READONLY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 192 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_mmiowr_pmrsts_readonly " "invalid write to read only PMRSTS, ignored" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 6394 "trace/trace-hw_nvme.h"
        } else {
#line 192 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_ub_mmiowr_pmrsts_readonly " "invalid write to read only PMRSTS, ignored" "\n");
#line 6398 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_ub_mmiowr_pmrsts_readonly(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_mmiowr_pmrsts_readonly();
    }
}

#define TRACE_PCI_NVME_UB_MMIOWR_PMREBS_READONLY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_MMIOWR_PMREBS_READONLY) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_mmiowr_pmrebs_readonly(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_MMIOWR_PMREBS_READONLY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 193 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_mmiowr_pmrebs_readonly " "invalid write to read only PMREBS, ignored" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 6425 "trace/trace-hw_nvme.h"
        } else {
#line 193 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_ub_mmiowr_pmrebs_readonly " "invalid write to read only PMREBS, ignored" "\n");
#line 6429 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_ub_mmiowr_pmrebs_readonly(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_mmiowr_pmrebs_readonly();
    }
}

#define TRACE_PCI_NVME_UB_MMIOWR_PMRSWTP_READONLY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_MMIOWR_PMRSWTP_READONLY) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_mmiowr_pmrswtp_readonly(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_MMIOWR_PMRSWTP_READONLY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 194 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_mmiowr_pmrswtp_readonly " "invalid write to read only PMRSWTP, ignored" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 6456 "trace/trace-hw_nvme.h"
        } else {
#line 194 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_ub_mmiowr_pmrswtp_readonly " "invalid write to read only PMRSWTP, ignored" "\n");
#line 6460 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_ub_mmiowr_pmrswtp_readonly(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_mmiowr_pmrswtp_readonly();
    }
}

#define TRACE_PCI_NVME_UB_MMIOWR_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_MMIOWR_INVALID) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_mmiowr_invalid(uint64_t offset, uint64_t data)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_MMIOWR_INVALID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 195 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_mmiowr_invalid " "invalid MMIO write, offset=0x%"PRIx64", data=0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, data);
#line 6487 "trace/trace-hw_nvme.h"
        } else {
#line 195 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_ub_mmiowr_invalid " "invalid MMIO write, offset=0x%"PRIx64", data=0x%"PRIx64"" "\n", offset, data);
#line 6491 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_ub_mmiowr_invalid(uint64_t offset, uint64_t data)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_mmiowr_invalid(offset, data);
    }
}

#define TRACE_PCI_NVME_UB_MMIORD_MISALIGNED32_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_MMIORD_MISALIGNED32) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_mmiord_misaligned32(uint64_t offset)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_MMIORD_MISALIGNED32) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 196 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_mmiord_misaligned32 " "MMIO read not 32-bit aligned, offset=0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset);
#line 6518 "trace/trace-hw_nvme.h"
        } else {
#line 196 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_ub_mmiord_misaligned32 " "MMIO read not 32-bit aligned, offset=0x%"PRIx64"" "\n", offset);
#line 6522 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_ub_mmiord_misaligned32(uint64_t offset)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_mmiord_misaligned32(offset);
    }
}

#define TRACE_PCI_NVME_UB_MMIORD_TOOSMALL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_MMIORD_TOOSMALL) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_mmiord_toosmall(uint64_t offset)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_MMIORD_TOOSMALL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 197 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_mmiord_toosmall " "MMIO read smaller than 32-bits, offset=0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset);
#line 6549 "trace/trace-hw_nvme.h"
        } else {
#line 197 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_ub_mmiord_toosmall " "MMIO read smaller than 32-bits, offset=0x%"PRIx64"" "\n", offset);
#line 6553 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_ub_mmiord_toosmall(uint64_t offset)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_mmiord_toosmall(offset);
    }
}

#define TRACE_PCI_NVME_UB_MMIORD_INVALID_OFS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_MMIORD_INVALID_OFS) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_mmiord_invalid_ofs(uint64_t offset)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_MMIORD_INVALID_OFS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 198 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_mmiord_invalid_ofs " "MMIO read beyond last register, offset=0x%"PRIx64", returning 0" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset);
#line 6580 "trace/trace-hw_nvme.h"
        } else {
#line 198 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_ub_mmiord_invalid_ofs " "MMIO read beyond last register, offset=0x%"PRIx64", returning 0" "\n", offset);
#line 6584 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_ub_mmiord_invalid_ofs(uint64_t offset)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_mmiord_invalid_ofs(offset);
    }
}

#define TRACE_PCI_NVME_UB_DB_WR_MISALIGNED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_DB_WR_MISALIGNED) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_db_wr_misaligned(uint64_t offset)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_DB_WR_MISALIGNED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 199 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_db_wr_misaligned " "doorbell write not 32-bit aligned, offset=0x%"PRIx64", ignoring" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset);
#line 6611 "trace/trace-hw_nvme.h"
        } else {
#line 199 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_ub_db_wr_misaligned " "doorbell write not 32-bit aligned, offset=0x%"PRIx64", ignoring" "\n", offset);
#line 6615 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_ub_db_wr_misaligned(uint64_t offset)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_db_wr_misaligned(offset);
    }
}

#define TRACE_PCI_NVME_UB_DB_WR_INVALID_CQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_DB_WR_INVALID_CQ) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_db_wr_invalid_cq(uint32_t qid)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_DB_WR_INVALID_CQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 200 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_db_wr_invalid_cq " "completion queue doorbell write for nonexistent queue, cqid=%"PRIu32", ignoring" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qid);
#line 6642 "trace/trace-hw_nvme.h"
        } else {
#line 200 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_ub_db_wr_invalid_cq " "completion queue doorbell write for nonexistent queue, cqid=%"PRIu32", ignoring" "\n", qid);
#line 6646 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_ub_db_wr_invalid_cq(uint32_t qid)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_db_wr_invalid_cq(qid);
    }
}

#define TRACE_PCI_NVME_UB_DB_WR_INVALID_CQHEAD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_DB_WR_INVALID_CQHEAD) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_db_wr_invalid_cqhead(uint32_t qid, uint16_t new_head)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_DB_WR_INVALID_CQHEAD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 201 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_db_wr_invalid_cqhead " "completion queue doorbell write value beyond queue size, cqid=%"PRIu32", new_head=%"PRIu16", ignoring" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qid, new_head);
#line 6673 "trace/trace-hw_nvme.h"
        } else {
#line 201 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_ub_db_wr_invalid_cqhead " "completion queue doorbell write value beyond queue size, cqid=%"PRIu32", new_head=%"PRIu16", ignoring" "\n", qid, new_head);
#line 6677 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_ub_db_wr_invalid_cqhead(uint32_t qid, uint16_t new_head)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_db_wr_invalid_cqhead(qid, new_head);
    }
}

#define TRACE_PCI_NVME_UB_DB_WR_INVALID_SQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_DB_WR_INVALID_SQ) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_db_wr_invalid_sq(uint32_t qid)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_DB_WR_INVALID_SQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 202 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_db_wr_invalid_sq " "submission queue doorbell write for nonexistent queue, sqid=%"PRIu32", ignoring" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qid);
#line 6704 "trace/trace-hw_nvme.h"
        } else {
#line 202 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_ub_db_wr_invalid_sq " "submission queue doorbell write for nonexistent queue, sqid=%"PRIu32", ignoring" "\n", qid);
#line 6708 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_ub_db_wr_invalid_sq(uint32_t qid)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_db_wr_invalid_sq(qid);
    }
}

#define TRACE_PCI_NVME_UB_DB_WR_INVALID_SQTAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_DB_WR_INVALID_SQTAIL) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_db_wr_invalid_sqtail(uint32_t qid, uint16_t new_tail)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_DB_WR_INVALID_SQTAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 203 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_db_wr_invalid_sqtail " "submission queue doorbell write value beyond queue size, sqid=%"PRIu32", new_head=%"PRIu16", ignoring" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qid, new_tail);
#line 6735 "trace/trace-hw_nvme.h"
        } else {
#line 203 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_ub_db_wr_invalid_sqtail " "submission queue doorbell write value beyond queue size, sqid=%"PRIu32", new_head=%"PRIu16", ignoring" "\n", qid, new_tail);
#line 6739 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_ub_db_wr_invalid_sqtail(uint32_t qid, uint16_t new_tail)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_db_wr_invalid_sqtail(qid, new_tail);
    }
}

#define TRACE_PCI_NVME_UB_UNKNOWN_CSS_VALUE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_UNKNOWN_CSS_VALUE) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_unknown_css_value(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_UNKNOWN_CSS_VALUE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 204 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_unknown_css_value " "unknown value in cc.css field" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 6766 "trace/trace-hw_nvme.h"
        } else {
#line 204 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_ub_unknown_css_value " "unknown value in cc.css field" "\n");
#line 6770 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_ub_unknown_css_value(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_unknown_css_value();
    }
}

#define TRACE_PCI_NVME_UB_TOO_MANY_MAPPINGS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_TOO_MANY_MAPPINGS) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_too_many_mappings(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_TOO_MANY_MAPPINGS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 205 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_too_many_mappings " "too many prp/sgl mappings" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 6797 "trace/trace-hw_nvme.h"
        } else {
#line 205 "/home/inhoinno/FEMU/hw/nvme/trace-events"
            qemu_log("pci_nvme_ub_too_many_mappings " "too many prp/sgl mappings" "\n");
#line 6801 "trace/trace-hw_nvme.h"
        }
    }
}

static inline void trace_pci_nvme_ub_too_many_mappings(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_too_many_mappings();
    }
}
#endif /* TRACE_HW_NVME_GENERATED_TRACERS_H */
