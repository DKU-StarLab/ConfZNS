/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_IDE_GENERATED_TRACERS_H
#define TRACE_HW_IDE_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_IDE_IOPORT_READ_EVENT;
extern TraceEvent _TRACE_IDE_IOPORT_WRITE_EVENT;
extern TraceEvent _TRACE_IDE_STATUS_READ_EVENT;
extern TraceEvent _TRACE_IDE_CTRL_WRITE_EVENT;
extern TraceEvent _TRACE_IDE_DATA_READW_EVENT;
extern TraceEvent _TRACE_IDE_DATA_WRITEW_EVENT;
extern TraceEvent _TRACE_IDE_DATA_READL_EVENT;
extern TraceEvent _TRACE_IDE_DATA_WRITEL_EVENT;
extern TraceEvent _TRACE_IDE_EXEC_CMD_EVENT;
extern TraceEvent _TRACE_IDE_CANCEL_DMA_SYNC_BUFFERED_EVENT;
extern TraceEvent _TRACE_IDE_CANCEL_DMA_SYNC_REMAINING_EVENT;
extern TraceEvent _TRACE_IDE_SECTOR_READ_EVENT;
extern TraceEvent _TRACE_IDE_SECTOR_WRITE_EVENT;
extern TraceEvent _TRACE_IDE_RESET_EVENT;
extern TraceEvent _TRACE_IDE_BUS_RESET_AIO_EVENT;
extern TraceEvent _TRACE_IDE_DMA_CB_EVENT;
extern TraceEvent _TRACE_BMDMA_READ_CMD646_EVENT;
extern TraceEvent _TRACE_BMDMA_WRITE_CMD646_EVENT;
extern TraceEvent _TRACE_BMDMA_RESET_EVENT;
extern TraceEvent _TRACE_BMDMA_CMD_WRITEB_EVENT;
extern TraceEvent _TRACE_BMDMA_ADDR_READ_EVENT;
extern TraceEvent _TRACE_BMDMA_ADDR_WRITE_EVENT;
extern TraceEvent _TRACE_BMDMA_READ_EVENT;
extern TraceEvent _TRACE_BMDMA_WRITE_EVENT;
extern TraceEvent _TRACE_SII3112_READ_EVENT;
extern TraceEvent _TRACE_SII3112_WRITE_EVENT;
extern TraceEvent _TRACE_SII3112_SET_IRQ_EVENT;
extern TraceEvent _TRACE_BMDMA_READ_VIA_EVENT;
extern TraceEvent _TRACE_BMDMA_WRITE_VIA_EVENT;
extern TraceEvent _TRACE_CD_READ_SECTOR_SYNC_EVENT;
extern TraceEvent _TRACE_CD_READ_SECTOR_CB_EVENT;
extern TraceEvent _TRACE_CD_READ_SECTOR_EVENT;
extern TraceEvent _TRACE_IDE_ATAPI_CMD_ERROR_EVENT;
extern TraceEvent _TRACE_IDE_ATAPI_CMD_REPLY_END_EVENT;
extern TraceEvent _TRACE_IDE_ATAPI_CMD_REPLY_END_EOT_EVENT;
extern TraceEvent _TRACE_IDE_ATAPI_CMD_REPLY_END_BCL_EVENT;
extern TraceEvent _TRACE_IDE_ATAPI_CMD_REPLY_END_NEW_EVENT;
extern TraceEvent _TRACE_IDE_ATAPI_CMD_CHECK_STATUS_EVENT;
extern TraceEvent _TRACE_IDE_ATAPI_CMD_READ_EVENT;
extern TraceEvent _TRACE_IDE_ATAPI_CMD_EVENT;
extern TraceEvent _TRACE_IDE_ATAPI_CMD_READ_DMA_CB_AIO_EVENT;
extern TraceEvent _TRACE_IDE_ATAPI_CMD_PACKET_EVENT;
extern TraceEvent _TRACE_AHCI_PORT_READ_EVENT;
extern TraceEvent _TRACE_AHCI_PORT_READ_DEFAULT_EVENT;
extern TraceEvent _TRACE_AHCI_IRQ_RAISE_EVENT;
extern TraceEvent _TRACE_AHCI_IRQ_LOWER_EVENT;
extern TraceEvent _TRACE_AHCI_CHECK_IRQ_EVENT;
extern TraceEvent _TRACE_AHCI_TRIGGER_IRQ_EVENT;
extern TraceEvent _TRACE_AHCI_PORT_WRITE_EVENT;
extern TraceEvent _TRACE_AHCI_PORT_WRITE_UNIMPL_EVENT;
extern TraceEvent _TRACE_AHCI_MEM_READ_32_EVENT;
extern TraceEvent _TRACE_AHCI_MEM_READ_32_DEFAULT_EVENT;
extern TraceEvent _TRACE_AHCI_MEM_READ_32_HOST_EVENT;
extern TraceEvent _TRACE_AHCI_MEM_READ_32_HOST_DEFAULT_EVENT;
extern TraceEvent _TRACE_AHCI_MEM_READ_EVENT;
extern TraceEvent _TRACE_AHCI_MEM_WRITE_EVENT;
extern TraceEvent _TRACE_AHCI_MEM_WRITE_HOST_UNIMPL_EVENT;
extern TraceEvent _TRACE_AHCI_MEM_WRITE_HOST_EVENT;
extern TraceEvent _TRACE_AHCI_MEM_WRITE_UNIMPL_EVENT;
extern TraceEvent _TRACE_AHCI_SET_SIGNATURE_EVENT;
extern TraceEvent _TRACE_AHCI_RESET_PORT_EVENT;
extern TraceEvent _TRACE_AHCI_UNMAP_FIS_ADDRESS_NULL_EVENT;
extern TraceEvent _TRACE_AHCI_UNMAP_CLB_ADDRESS_NULL_EVENT;
extern TraceEvent _TRACE_AHCI_POPULATE_SGLIST_EVENT;
extern TraceEvent _TRACE_AHCI_POPULATE_SGLIST_NO_PRDTL_EVENT;
extern TraceEvent _TRACE_AHCI_POPULATE_SGLIST_NO_MAP_EVENT;
extern TraceEvent _TRACE_AHCI_POPULATE_SGLIST_SHORT_MAP_EVENT;
extern TraceEvent _TRACE_AHCI_POPULATE_SGLIST_BAD_OFFSET_EVENT;
extern TraceEvent _TRACE_NCQ_FINISH_EVENT;
extern TraceEvent _TRACE_EXECUTE_NCQ_COMMAND_READ_EVENT;
extern TraceEvent _TRACE_EXECUTE_NCQ_COMMAND_UNSUP_EVENT;
extern TraceEvent _TRACE_PROCESS_NCQ_COMMAND_MISMATCH_EVENT;
extern TraceEvent _TRACE_PROCESS_NCQ_COMMAND_AUX_EVENT;
extern TraceEvent _TRACE_PROCESS_NCQ_COMMAND_PRIOICC_EVENT;
extern TraceEvent _TRACE_PROCESS_NCQ_COMMAND_FUA_EVENT;
extern TraceEvent _TRACE_PROCESS_NCQ_COMMAND_RARC_EVENT;
extern TraceEvent _TRACE_PROCESS_NCQ_COMMAND_LARGE_EVENT;
extern TraceEvent _TRACE_PROCESS_NCQ_COMMAND_EVENT;
extern TraceEvent _TRACE_HANDLE_REG_H2D_FIS_PMP_EVENT;
extern TraceEvent _TRACE_HANDLE_REG_H2D_FIS_RES_EVENT;
extern TraceEvent _TRACE_HANDLE_CMD_BUSY_EVENT;
extern TraceEvent _TRACE_HANDLE_CMD_NOLIST_EVENT;
extern TraceEvent _TRACE_HANDLE_CMD_BADPORT_EVENT;
extern TraceEvent _TRACE_HANDLE_CMD_BADFIS_EVENT;
extern TraceEvent _TRACE_HANDLE_CMD_BADMAP_EVENT;
extern TraceEvent _TRACE_HANDLE_CMD_UNHANDLED_FIS_EVENT;
extern TraceEvent _TRACE_AHCI_PIO_TRANSFER_EVENT;
extern TraceEvent _TRACE_AHCI_START_DMA_EVENT;
extern TraceEvent _TRACE_AHCI_DMA_PREPARE_BUF_EVENT;
extern TraceEvent _TRACE_AHCI_DMA_PREPARE_BUF_FAIL_EVENT;
extern TraceEvent _TRACE_AHCI_DMA_RW_BUF_EVENT;
extern TraceEvent _TRACE_AHCI_CMD_DONE_EVENT;
extern TraceEvent _TRACE_AHCI_RESET_EVENT;
extern TraceEvent _TRACE_HANDLE_REG_H2D_FIS_DUMP_EVENT;
extern TraceEvent _TRACE_HANDLE_CMD_FIS_DUMP_EVENT;
extern TraceEvent _TRACE_ALLWINNER_AHCI_MEM_READ_EVENT;
extern TraceEvent _TRACE_ALLWINNER_AHCI_MEM_WRITE_EVENT;
extern uint16_t _TRACE_IDE_IOPORT_READ_DSTATE;
extern uint16_t _TRACE_IDE_IOPORT_WRITE_DSTATE;
extern uint16_t _TRACE_IDE_STATUS_READ_DSTATE;
extern uint16_t _TRACE_IDE_CTRL_WRITE_DSTATE;
extern uint16_t _TRACE_IDE_DATA_READW_DSTATE;
extern uint16_t _TRACE_IDE_DATA_WRITEW_DSTATE;
extern uint16_t _TRACE_IDE_DATA_READL_DSTATE;
extern uint16_t _TRACE_IDE_DATA_WRITEL_DSTATE;
extern uint16_t _TRACE_IDE_EXEC_CMD_DSTATE;
extern uint16_t _TRACE_IDE_CANCEL_DMA_SYNC_BUFFERED_DSTATE;
extern uint16_t _TRACE_IDE_CANCEL_DMA_SYNC_REMAINING_DSTATE;
extern uint16_t _TRACE_IDE_SECTOR_READ_DSTATE;
extern uint16_t _TRACE_IDE_SECTOR_WRITE_DSTATE;
extern uint16_t _TRACE_IDE_RESET_DSTATE;
extern uint16_t _TRACE_IDE_BUS_RESET_AIO_DSTATE;
extern uint16_t _TRACE_IDE_DMA_CB_DSTATE;
extern uint16_t _TRACE_BMDMA_READ_CMD646_DSTATE;
extern uint16_t _TRACE_BMDMA_WRITE_CMD646_DSTATE;
extern uint16_t _TRACE_BMDMA_RESET_DSTATE;
extern uint16_t _TRACE_BMDMA_CMD_WRITEB_DSTATE;
extern uint16_t _TRACE_BMDMA_ADDR_READ_DSTATE;
extern uint16_t _TRACE_BMDMA_ADDR_WRITE_DSTATE;
extern uint16_t _TRACE_BMDMA_READ_DSTATE;
extern uint16_t _TRACE_BMDMA_WRITE_DSTATE;
extern uint16_t _TRACE_SII3112_READ_DSTATE;
extern uint16_t _TRACE_SII3112_WRITE_DSTATE;
extern uint16_t _TRACE_SII3112_SET_IRQ_DSTATE;
extern uint16_t _TRACE_BMDMA_READ_VIA_DSTATE;
extern uint16_t _TRACE_BMDMA_WRITE_VIA_DSTATE;
extern uint16_t _TRACE_CD_READ_SECTOR_SYNC_DSTATE;
extern uint16_t _TRACE_CD_READ_SECTOR_CB_DSTATE;
extern uint16_t _TRACE_CD_READ_SECTOR_DSTATE;
extern uint16_t _TRACE_IDE_ATAPI_CMD_ERROR_DSTATE;
extern uint16_t _TRACE_IDE_ATAPI_CMD_REPLY_END_DSTATE;
extern uint16_t _TRACE_IDE_ATAPI_CMD_REPLY_END_EOT_DSTATE;
extern uint16_t _TRACE_IDE_ATAPI_CMD_REPLY_END_BCL_DSTATE;
extern uint16_t _TRACE_IDE_ATAPI_CMD_REPLY_END_NEW_DSTATE;
extern uint16_t _TRACE_IDE_ATAPI_CMD_CHECK_STATUS_DSTATE;
extern uint16_t _TRACE_IDE_ATAPI_CMD_READ_DSTATE;
extern uint16_t _TRACE_IDE_ATAPI_CMD_DSTATE;
extern uint16_t _TRACE_IDE_ATAPI_CMD_READ_DMA_CB_AIO_DSTATE;
extern uint16_t _TRACE_IDE_ATAPI_CMD_PACKET_DSTATE;
extern uint16_t _TRACE_AHCI_PORT_READ_DSTATE;
extern uint16_t _TRACE_AHCI_PORT_READ_DEFAULT_DSTATE;
extern uint16_t _TRACE_AHCI_IRQ_RAISE_DSTATE;
extern uint16_t _TRACE_AHCI_IRQ_LOWER_DSTATE;
extern uint16_t _TRACE_AHCI_CHECK_IRQ_DSTATE;
extern uint16_t _TRACE_AHCI_TRIGGER_IRQ_DSTATE;
extern uint16_t _TRACE_AHCI_PORT_WRITE_DSTATE;
extern uint16_t _TRACE_AHCI_PORT_WRITE_UNIMPL_DSTATE;
extern uint16_t _TRACE_AHCI_MEM_READ_32_DSTATE;
extern uint16_t _TRACE_AHCI_MEM_READ_32_DEFAULT_DSTATE;
extern uint16_t _TRACE_AHCI_MEM_READ_32_HOST_DSTATE;
extern uint16_t _TRACE_AHCI_MEM_READ_32_HOST_DEFAULT_DSTATE;
extern uint16_t _TRACE_AHCI_MEM_READ_DSTATE;
extern uint16_t _TRACE_AHCI_MEM_WRITE_DSTATE;
extern uint16_t _TRACE_AHCI_MEM_WRITE_HOST_UNIMPL_DSTATE;
extern uint16_t _TRACE_AHCI_MEM_WRITE_HOST_DSTATE;
extern uint16_t _TRACE_AHCI_MEM_WRITE_UNIMPL_DSTATE;
extern uint16_t _TRACE_AHCI_SET_SIGNATURE_DSTATE;
extern uint16_t _TRACE_AHCI_RESET_PORT_DSTATE;
extern uint16_t _TRACE_AHCI_UNMAP_FIS_ADDRESS_NULL_DSTATE;
extern uint16_t _TRACE_AHCI_UNMAP_CLB_ADDRESS_NULL_DSTATE;
extern uint16_t _TRACE_AHCI_POPULATE_SGLIST_DSTATE;
extern uint16_t _TRACE_AHCI_POPULATE_SGLIST_NO_PRDTL_DSTATE;
extern uint16_t _TRACE_AHCI_POPULATE_SGLIST_NO_MAP_DSTATE;
extern uint16_t _TRACE_AHCI_POPULATE_SGLIST_SHORT_MAP_DSTATE;
extern uint16_t _TRACE_AHCI_POPULATE_SGLIST_BAD_OFFSET_DSTATE;
extern uint16_t _TRACE_NCQ_FINISH_DSTATE;
extern uint16_t _TRACE_EXECUTE_NCQ_COMMAND_READ_DSTATE;
extern uint16_t _TRACE_EXECUTE_NCQ_COMMAND_UNSUP_DSTATE;
extern uint16_t _TRACE_PROCESS_NCQ_COMMAND_MISMATCH_DSTATE;
extern uint16_t _TRACE_PROCESS_NCQ_COMMAND_AUX_DSTATE;
extern uint16_t _TRACE_PROCESS_NCQ_COMMAND_PRIOICC_DSTATE;
extern uint16_t _TRACE_PROCESS_NCQ_COMMAND_FUA_DSTATE;
extern uint16_t _TRACE_PROCESS_NCQ_COMMAND_RARC_DSTATE;
extern uint16_t _TRACE_PROCESS_NCQ_COMMAND_LARGE_DSTATE;
extern uint16_t _TRACE_PROCESS_NCQ_COMMAND_DSTATE;
extern uint16_t _TRACE_HANDLE_REG_H2D_FIS_PMP_DSTATE;
extern uint16_t _TRACE_HANDLE_REG_H2D_FIS_RES_DSTATE;
extern uint16_t _TRACE_HANDLE_CMD_BUSY_DSTATE;
extern uint16_t _TRACE_HANDLE_CMD_NOLIST_DSTATE;
extern uint16_t _TRACE_HANDLE_CMD_BADPORT_DSTATE;
extern uint16_t _TRACE_HANDLE_CMD_BADFIS_DSTATE;
extern uint16_t _TRACE_HANDLE_CMD_BADMAP_DSTATE;
extern uint16_t _TRACE_HANDLE_CMD_UNHANDLED_FIS_DSTATE;
extern uint16_t _TRACE_AHCI_PIO_TRANSFER_DSTATE;
extern uint16_t _TRACE_AHCI_START_DMA_DSTATE;
extern uint16_t _TRACE_AHCI_DMA_PREPARE_BUF_DSTATE;
extern uint16_t _TRACE_AHCI_DMA_PREPARE_BUF_FAIL_DSTATE;
extern uint16_t _TRACE_AHCI_DMA_RW_BUF_DSTATE;
extern uint16_t _TRACE_AHCI_CMD_DONE_DSTATE;
extern uint16_t _TRACE_AHCI_RESET_DSTATE;
extern uint16_t _TRACE_HANDLE_REG_H2D_FIS_DUMP_DSTATE;
extern uint16_t _TRACE_HANDLE_CMD_FIS_DUMP_DSTATE;
extern uint16_t _TRACE_ALLWINNER_AHCI_MEM_READ_DSTATE;
extern uint16_t _TRACE_ALLWINNER_AHCI_MEM_WRITE_DSTATE;
#define TRACE_IDE_IOPORT_READ_ENABLED 1
#define TRACE_IDE_IOPORT_WRITE_ENABLED 1
#define TRACE_IDE_STATUS_READ_ENABLED 1
#define TRACE_IDE_CTRL_WRITE_ENABLED 1
#define TRACE_IDE_DATA_READW_ENABLED 1
#define TRACE_IDE_DATA_WRITEW_ENABLED 1
#define TRACE_IDE_DATA_READL_ENABLED 1
#define TRACE_IDE_DATA_WRITEL_ENABLED 1
#define TRACE_IDE_EXEC_CMD_ENABLED 1
#define TRACE_IDE_CANCEL_DMA_SYNC_BUFFERED_ENABLED 1
#define TRACE_IDE_CANCEL_DMA_SYNC_REMAINING_ENABLED 1
#define TRACE_IDE_SECTOR_READ_ENABLED 1
#define TRACE_IDE_SECTOR_WRITE_ENABLED 1
#define TRACE_IDE_RESET_ENABLED 1
#define TRACE_IDE_BUS_RESET_AIO_ENABLED 1
#define TRACE_IDE_DMA_CB_ENABLED 1
#define TRACE_BMDMA_READ_CMD646_ENABLED 1
#define TRACE_BMDMA_WRITE_CMD646_ENABLED 1
#define TRACE_BMDMA_RESET_ENABLED 1
#define TRACE_BMDMA_CMD_WRITEB_ENABLED 1
#define TRACE_BMDMA_ADDR_READ_ENABLED 1
#define TRACE_BMDMA_ADDR_WRITE_ENABLED 1
#define TRACE_BMDMA_READ_ENABLED 1
#define TRACE_BMDMA_WRITE_ENABLED 1
#define TRACE_SII3112_READ_ENABLED 1
#define TRACE_SII3112_WRITE_ENABLED 1
#define TRACE_SII3112_SET_IRQ_ENABLED 1
#define TRACE_BMDMA_READ_VIA_ENABLED 1
#define TRACE_BMDMA_WRITE_VIA_ENABLED 1
#define TRACE_CD_READ_SECTOR_SYNC_ENABLED 1
#define TRACE_CD_READ_SECTOR_CB_ENABLED 1
#define TRACE_CD_READ_SECTOR_ENABLED 1
#define TRACE_IDE_ATAPI_CMD_ERROR_ENABLED 1
#define TRACE_IDE_ATAPI_CMD_REPLY_END_ENABLED 1
#define TRACE_IDE_ATAPI_CMD_REPLY_END_EOT_ENABLED 1
#define TRACE_IDE_ATAPI_CMD_REPLY_END_BCL_ENABLED 1
#define TRACE_IDE_ATAPI_CMD_REPLY_END_NEW_ENABLED 1
#define TRACE_IDE_ATAPI_CMD_CHECK_STATUS_ENABLED 1
#define TRACE_IDE_ATAPI_CMD_READ_ENABLED 1
#define TRACE_IDE_ATAPI_CMD_ENABLED 1
#define TRACE_IDE_ATAPI_CMD_READ_DMA_CB_AIO_ENABLED 1
#define TRACE_IDE_ATAPI_CMD_PACKET_ENABLED 1
#define TRACE_AHCI_PORT_READ_ENABLED 1
#define TRACE_AHCI_PORT_READ_DEFAULT_ENABLED 1
#define TRACE_AHCI_IRQ_RAISE_ENABLED 1
#define TRACE_AHCI_IRQ_LOWER_ENABLED 1
#define TRACE_AHCI_CHECK_IRQ_ENABLED 1
#define TRACE_AHCI_TRIGGER_IRQ_ENABLED 1
#define TRACE_AHCI_PORT_WRITE_ENABLED 1
#define TRACE_AHCI_PORT_WRITE_UNIMPL_ENABLED 1
#define TRACE_AHCI_MEM_READ_32_ENABLED 1
#define TRACE_AHCI_MEM_READ_32_DEFAULT_ENABLED 1
#define TRACE_AHCI_MEM_READ_32_HOST_ENABLED 1
#define TRACE_AHCI_MEM_READ_32_HOST_DEFAULT_ENABLED 1
#define TRACE_AHCI_MEM_READ_ENABLED 1
#define TRACE_AHCI_MEM_WRITE_ENABLED 1
#define TRACE_AHCI_MEM_WRITE_HOST_UNIMPL_ENABLED 1
#define TRACE_AHCI_MEM_WRITE_HOST_ENABLED 1
#define TRACE_AHCI_MEM_WRITE_UNIMPL_ENABLED 1
#define TRACE_AHCI_SET_SIGNATURE_ENABLED 1
#define TRACE_AHCI_RESET_PORT_ENABLED 1
#define TRACE_AHCI_UNMAP_FIS_ADDRESS_NULL_ENABLED 1
#define TRACE_AHCI_UNMAP_CLB_ADDRESS_NULL_ENABLED 1
#define TRACE_AHCI_POPULATE_SGLIST_ENABLED 1
#define TRACE_AHCI_POPULATE_SGLIST_NO_PRDTL_ENABLED 1
#define TRACE_AHCI_POPULATE_SGLIST_NO_MAP_ENABLED 1
#define TRACE_AHCI_POPULATE_SGLIST_SHORT_MAP_ENABLED 1
#define TRACE_AHCI_POPULATE_SGLIST_BAD_OFFSET_ENABLED 1
#define TRACE_NCQ_FINISH_ENABLED 1
#define TRACE_EXECUTE_NCQ_COMMAND_READ_ENABLED 1
#define TRACE_EXECUTE_NCQ_COMMAND_UNSUP_ENABLED 1
#define TRACE_PROCESS_NCQ_COMMAND_MISMATCH_ENABLED 1
#define TRACE_PROCESS_NCQ_COMMAND_AUX_ENABLED 1
#define TRACE_PROCESS_NCQ_COMMAND_PRIOICC_ENABLED 1
#define TRACE_PROCESS_NCQ_COMMAND_FUA_ENABLED 1
#define TRACE_PROCESS_NCQ_COMMAND_RARC_ENABLED 1
#define TRACE_PROCESS_NCQ_COMMAND_LARGE_ENABLED 1
#define TRACE_PROCESS_NCQ_COMMAND_ENABLED 1
#define TRACE_HANDLE_REG_H2D_FIS_PMP_ENABLED 1
#define TRACE_HANDLE_REG_H2D_FIS_RES_ENABLED 1
#define TRACE_HANDLE_CMD_BUSY_ENABLED 1
#define TRACE_HANDLE_CMD_NOLIST_ENABLED 1
#define TRACE_HANDLE_CMD_BADPORT_ENABLED 1
#define TRACE_HANDLE_CMD_BADFIS_ENABLED 1
#define TRACE_HANDLE_CMD_BADMAP_ENABLED 1
#define TRACE_HANDLE_CMD_UNHANDLED_FIS_ENABLED 1
#define TRACE_AHCI_PIO_TRANSFER_ENABLED 1
#define TRACE_AHCI_START_DMA_ENABLED 1
#define TRACE_AHCI_DMA_PREPARE_BUF_ENABLED 1
#define TRACE_AHCI_DMA_PREPARE_BUF_FAIL_ENABLED 1
#define TRACE_AHCI_DMA_RW_BUF_ENABLED 1
#define TRACE_AHCI_CMD_DONE_ENABLED 1
#define TRACE_AHCI_RESET_ENABLED 1
#define TRACE_HANDLE_REG_H2D_FIS_DUMP_ENABLED 1
#define TRACE_HANDLE_CMD_FIS_DUMP_ENABLED 1
#define TRACE_ALLWINNER_AHCI_MEM_READ_ENABLED 1
#define TRACE_ALLWINNER_AHCI_MEM_WRITE_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_IDE_IOPORT_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_IOPORT_READ) || \
    false)

static inline void _nocheck__trace_ide_ioport_read(uint32_t addr, const char * reg, uint32_t val, void * bus, void * s)
{
    if (trace_event_get_state(TRACE_IDE_IOPORT_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 5 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ide_ioport_read " "IDE PIO rd @ 0x%"PRIx32" (%s); val 0x%02"PRIx32"; bus %p IDEState %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, reg, val, bus, s);
#line 319 "trace/trace-hw_ide.h"
        } else {
#line 5 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ide_ioport_read " "IDE PIO rd @ 0x%"PRIx32" (%s); val 0x%02"PRIx32"; bus %p IDEState %p" "\n", addr, reg, val, bus, s);
#line 323 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ide_ioport_read(uint32_t addr, const char * reg, uint32_t val, void * bus, void * s)
{
    if (true) {
        _nocheck__trace_ide_ioport_read(addr, reg, val, bus, s);
    }
}

#define TRACE_IDE_IOPORT_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_IOPORT_WRITE) || \
    false)

static inline void _nocheck__trace_ide_ioport_write(uint32_t addr, const char * reg, uint32_t val, void * bus, void * s)
{
    if (trace_event_get_state(TRACE_IDE_IOPORT_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 6 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ide_ioport_write " "IDE PIO wr @ 0x%"PRIx32" (%s); val 0x%02"PRIx32"; bus %p IDEState %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, reg, val, bus, s);
#line 350 "trace/trace-hw_ide.h"
        } else {
#line 6 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ide_ioport_write " "IDE PIO wr @ 0x%"PRIx32" (%s); val 0x%02"PRIx32"; bus %p IDEState %p" "\n", addr, reg, val, bus, s);
#line 354 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ide_ioport_write(uint32_t addr, const char * reg, uint32_t val, void * bus, void * s)
{
    if (true) {
        _nocheck__trace_ide_ioport_write(addr, reg, val, bus, s);
    }
}

#define TRACE_IDE_STATUS_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_STATUS_READ) || \
    false)

static inline void _nocheck__trace_ide_status_read(uint32_t addr, uint32_t val, void * bus, void * s)
{
    if (trace_event_get_state(TRACE_IDE_STATUS_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 7 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ide_status_read " "IDE PIO rd @ 0x%"PRIx32" (Alt Status); val 0x%02"PRIx32"; bus %p; IDEState %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val, bus, s);
#line 381 "trace/trace-hw_ide.h"
        } else {
#line 7 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ide_status_read " "IDE PIO rd @ 0x%"PRIx32" (Alt Status); val 0x%02"PRIx32"; bus %p; IDEState %p" "\n", addr, val, bus, s);
#line 385 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ide_status_read(uint32_t addr, uint32_t val, void * bus, void * s)
{
    if (true) {
        _nocheck__trace_ide_status_read(addr, val, bus, s);
    }
}

#define TRACE_IDE_CTRL_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_CTRL_WRITE) || \
    false)

static inline void _nocheck__trace_ide_ctrl_write(uint32_t addr, uint32_t val, void * bus)
{
    if (trace_event_get_state(TRACE_IDE_CTRL_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 8 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ide_ctrl_write " "IDE PIO wr @ 0x%"PRIx32" (Device Control); val 0x%02"PRIx32"; bus %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val, bus);
#line 412 "trace/trace-hw_ide.h"
        } else {
#line 8 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ide_ctrl_write " "IDE PIO wr @ 0x%"PRIx32" (Device Control); val 0x%02"PRIx32"; bus %p" "\n", addr, val, bus);
#line 416 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ide_ctrl_write(uint32_t addr, uint32_t val, void * bus)
{
    if (true) {
        _nocheck__trace_ide_ctrl_write(addr, val, bus);
    }
}

#define TRACE_IDE_DATA_READW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_DATA_READW) || \
    false)

static inline void _nocheck__trace_ide_data_readw(uint32_t addr, uint32_t val, void * bus, void * s)
{
    if (trace_event_get_state(TRACE_IDE_DATA_READW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 10 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ide_data_readw " "IDE PIO rd @ 0x%"PRIx32" (Data: Word); val 0x%04"PRIx32"; bus %p; IDEState %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val, bus, s);
#line 443 "trace/trace-hw_ide.h"
        } else {
#line 10 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ide_data_readw " "IDE PIO rd @ 0x%"PRIx32" (Data: Word); val 0x%04"PRIx32"; bus %p; IDEState %p" "\n", addr, val, bus, s);
#line 447 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ide_data_readw(uint32_t addr, uint32_t val, void * bus, void * s)
{
    if (true) {
        _nocheck__trace_ide_data_readw(addr, val, bus, s);
    }
}

#define TRACE_IDE_DATA_WRITEW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_DATA_WRITEW) || \
    false)

static inline void _nocheck__trace_ide_data_writew(uint32_t addr, uint32_t val, void * bus, void * s)
{
    if (trace_event_get_state(TRACE_IDE_DATA_WRITEW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 11 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ide_data_writew " "IDE PIO wr @ 0x%"PRIx32" (Data: Word); val 0x%04"PRIx32"; bus %p; IDEState %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val, bus, s);
#line 474 "trace/trace-hw_ide.h"
        } else {
#line 11 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ide_data_writew " "IDE PIO wr @ 0x%"PRIx32" (Data: Word); val 0x%04"PRIx32"; bus %p; IDEState %p" "\n", addr, val, bus, s);
#line 478 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ide_data_writew(uint32_t addr, uint32_t val, void * bus, void * s)
{
    if (true) {
        _nocheck__trace_ide_data_writew(addr, val, bus, s);
    }
}

#define TRACE_IDE_DATA_READL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_DATA_READL) || \
    false)

static inline void _nocheck__trace_ide_data_readl(uint32_t addr, uint32_t val, void * bus, void * s)
{
    if (trace_event_get_state(TRACE_IDE_DATA_READL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 12 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ide_data_readl " "IDE PIO rd @ 0x%"PRIx32" (Data: Long); val 0x%08"PRIx32"; bus %p; IDEState %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val, bus, s);
#line 505 "trace/trace-hw_ide.h"
        } else {
#line 12 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ide_data_readl " "IDE PIO rd @ 0x%"PRIx32" (Data: Long); val 0x%08"PRIx32"; bus %p; IDEState %p" "\n", addr, val, bus, s);
#line 509 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ide_data_readl(uint32_t addr, uint32_t val, void * bus, void * s)
{
    if (true) {
        _nocheck__trace_ide_data_readl(addr, val, bus, s);
    }
}

#define TRACE_IDE_DATA_WRITEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_DATA_WRITEL) || \
    false)

static inline void _nocheck__trace_ide_data_writel(uint32_t addr, uint32_t val, void * bus, void * s)
{
    if (trace_event_get_state(TRACE_IDE_DATA_WRITEL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 13 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ide_data_writel " "IDE PIO wr @ 0x%"PRIx32" (Data: Long); val 0x%08"PRIx32"; bus %p; IDEState %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val, bus, s);
#line 536 "trace/trace-hw_ide.h"
        } else {
#line 13 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ide_data_writel " "IDE PIO wr @ 0x%"PRIx32" (Data: Long); val 0x%08"PRIx32"; bus %p; IDEState %p" "\n", addr, val, bus, s);
#line 540 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ide_data_writel(uint32_t addr, uint32_t val, void * bus, void * s)
{
    if (true) {
        _nocheck__trace_ide_data_writel(addr, val, bus, s);
    }
}

#define TRACE_IDE_EXEC_CMD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_EXEC_CMD) || \
    false)

static inline void _nocheck__trace_ide_exec_cmd(void * bus, void * state, uint32_t cmd)
{
    if (trace_event_get_state(TRACE_IDE_EXEC_CMD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 15 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ide_exec_cmd " "IDE exec cmd: bus %p; state %p; cmd 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bus, state, cmd);
#line 567 "trace/trace-hw_ide.h"
        } else {
#line 15 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ide_exec_cmd " "IDE exec cmd: bus %p; state %p; cmd 0x%02x" "\n", bus, state, cmd);
#line 571 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ide_exec_cmd(void * bus, void * state, uint32_t cmd)
{
    if (true) {
        _nocheck__trace_ide_exec_cmd(bus, state, cmd);
    }
}

#define TRACE_IDE_CANCEL_DMA_SYNC_BUFFERED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_CANCEL_DMA_SYNC_BUFFERED) || \
    false)

static inline void _nocheck__trace_ide_cancel_dma_sync_buffered(void * fn, void * req)
{
    if (trace_event_get_state(TRACE_IDE_CANCEL_DMA_SYNC_BUFFERED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 16 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ide_cancel_dma_sync_buffered " "invoking cb %p of buffered request %p with -ECANCELED" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , fn, req);
#line 598 "trace/trace-hw_ide.h"
        } else {
#line 16 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ide_cancel_dma_sync_buffered " "invoking cb %p of buffered request %p with -ECANCELED" "\n", fn, req);
#line 602 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ide_cancel_dma_sync_buffered(void * fn, void * req)
{
    if (true) {
        _nocheck__trace_ide_cancel_dma_sync_buffered(fn, req);
    }
}

#define TRACE_IDE_CANCEL_DMA_SYNC_REMAINING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_CANCEL_DMA_SYNC_REMAINING) || \
    false)

static inline void _nocheck__trace_ide_cancel_dma_sync_remaining(void)
{
    if (trace_event_get_state(TRACE_IDE_CANCEL_DMA_SYNC_REMAINING) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 17 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ide_cancel_dma_sync_remaining " "draining all remaining requests" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 629 "trace/trace-hw_ide.h"
        } else {
#line 17 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ide_cancel_dma_sync_remaining " "draining all remaining requests" "\n");
#line 633 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ide_cancel_dma_sync_remaining(void)
{
    if (true) {
        _nocheck__trace_ide_cancel_dma_sync_remaining();
    }
}

#define TRACE_IDE_SECTOR_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_SECTOR_READ) || \
    false)

static inline void _nocheck__trace_ide_sector_read(int64_t sector_num, int nsectors)
{
    if (trace_event_get_state(TRACE_IDE_SECTOR_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 18 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ide_sector_read " "sector=%"PRId64" nsectors=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , sector_num, nsectors);
#line 660 "trace/trace-hw_ide.h"
        } else {
#line 18 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ide_sector_read " "sector=%"PRId64" nsectors=%d" "\n", sector_num, nsectors);
#line 664 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ide_sector_read(int64_t sector_num, int nsectors)
{
    if (true) {
        _nocheck__trace_ide_sector_read(sector_num, nsectors);
    }
}

#define TRACE_IDE_SECTOR_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_SECTOR_WRITE) || \
    false)

static inline void _nocheck__trace_ide_sector_write(int64_t sector_num, int nsectors)
{
    if (trace_event_get_state(TRACE_IDE_SECTOR_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 19 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ide_sector_write " "sector=%"PRId64" nsectors=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , sector_num, nsectors);
#line 691 "trace/trace-hw_ide.h"
        } else {
#line 19 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ide_sector_write " "sector=%"PRId64" nsectors=%d" "\n", sector_num, nsectors);
#line 695 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ide_sector_write(int64_t sector_num, int nsectors)
{
    if (true) {
        _nocheck__trace_ide_sector_write(sector_num, nsectors);
    }
}

#define TRACE_IDE_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_RESET) || \
    false)

static inline void _nocheck__trace_ide_reset(void * s)
{
    if (trace_event_get_state(TRACE_IDE_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 20 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ide_reset " "IDEstate %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s);
#line 722 "trace/trace-hw_ide.h"
        } else {
#line 20 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ide_reset " "IDEstate %p" "\n", s);
#line 726 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ide_reset(void * s)
{
    if (true) {
        _nocheck__trace_ide_reset(s);
    }
}

#define TRACE_IDE_BUS_RESET_AIO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_BUS_RESET_AIO) || \
    false)

static inline void _nocheck__trace_ide_bus_reset_aio(void)
{
    if (trace_event_get_state(TRACE_IDE_BUS_RESET_AIO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 21 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ide_bus_reset_aio " "aio_cancel" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 753 "trace/trace-hw_ide.h"
        } else {
#line 21 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ide_bus_reset_aio " "aio_cancel" "\n");
#line 757 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ide_bus_reset_aio(void)
{
    if (true) {
        _nocheck__trace_ide_bus_reset_aio();
    }
}

#define TRACE_IDE_DMA_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_DMA_CB) || \
    false)

static inline void _nocheck__trace_ide_dma_cb(void * s, int64_t sector_num, int n, const char * dma)
{
    if (trace_event_get_state(TRACE_IDE_DMA_CB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 22 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ide_dma_cb " "IDEState %p; sector_num=%"PRId64" n=%d cmd=%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, sector_num, n, dma);
#line 784 "trace/trace-hw_ide.h"
        } else {
#line 22 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ide_dma_cb " "IDEState %p; sector_num=%"PRId64" n=%d cmd=%s" "\n", s, sector_num, n, dma);
#line 788 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ide_dma_cb(void * s, int64_t sector_num, int n, const char * dma)
{
    if (true) {
        _nocheck__trace_ide_dma_cb(s, sector_num, n, dma);
    }
}

#define TRACE_BMDMA_READ_CMD646_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BMDMA_READ_CMD646) || \
    false)

static inline void _nocheck__trace_bmdma_read_cmd646(uint64_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_BMDMA_READ_CMD646) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 27 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:bmdma_read_cmd646 " "bmdma: readb 0x%"PRIx64" : 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 815 "trace/trace-hw_ide.h"
        } else {
#line 27 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("bmdma_read_cmd646 " "bmdma: readb 0x%"PRIx64" : 0x%02x" "\n", addr, val);
#line 819 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_bmdma_read_cmd646(uint64_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_bmdma_read_cmd646(addr, val);
    }
}

#define TRACE_BMDMA_WRITE_CMD646_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BMDMA_WRITE_CMD646) || \
    false)

static inline void _nocheck__trace_bmdma_write_cmd646(uint64_t addr, uint64_t val)
{
    if (trace_event_get_state(TRACE_BMDMA_WRITE_CMD646) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 28 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:bmdma_write_cmd646 " "bmdma: writeb 0x%"PRIx64" : 0x%02"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 846 "trace/trace-hw_ide.h"
        } else {
#line 28 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("bmdma_write_cmd646 " "bmdma: writeb 0x%"PRIx64" : 0x%02"PRIx64 "\n", addr, val);
#line 850 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_bmdma_write_cmd646(uint64_t addr, uint64_t val)
{
    if (true) {
        _nocheck__trace_bmdma_write_cmd646(addr, val);
    }
}

#define TRACE_BMDMA_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BMDMA_RESET) || \
    false)

static inline void _nocheck__trace_bmdma_reset(void)
{
    if (trace_event_get_state(TRACE_BMDMA_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 31 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:bmdma_reset " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 877 "trace/trace-hw_ide.h"
        } else {
#line 31 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("bmdma_reset " "" "\n");
#line 881 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_bmdma_reset(void)
{
    if (true) {
        _nocheck__trace_bmdma_reset();
    }
}

#define TRACE_BMDMA_CMD_WRITEB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BMDMA_CMD_WRITEB) || \
    false)

static inline void _nocheck__trace_bmdma_cmd_writeb(uint32_t val)
{
    if (trace_event_get_state(TRACE_BMDMA_CMD_WRITEB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 32 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:bmdma_cmd_writeb " "val: 0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 908 "trace/trace-hw_ide.h"
        } else {
#line 32 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("bmdma_cmd_writeb " "val: 0x%08x" "\n", val);
#line 912 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_bmdma_cmd_writeb(uint32_t val)
{
    if (true) {
        _nocheck__trace_bmdma_cmd_writeb(val);
    }
}

#define TRACE_BMDMA_ADDR_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BMDMA_ADDR_READ) || \
    false)

static inline void _nocheck__trace_bmdma_addr_read(uint64_t data)
{
    if (trace_event_get_state(TRACE_BMDMA_ADDR_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 33 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:bmdma_addr_read " "data: 0x%016"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , data);
#line 939 "trace/trace-hw_ide.h"
        } else {
#line 33 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("bmdma_addr_read " "data: 0x%016"PRIx64 "\n", data);
#line 943 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_bmdma_addr_read(uint64_t data)
{
    if (true) {
        _nocheck__trace_bmdma_addr_read(data);
    }
}

#define TRACE_BMDMA_ADDR_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BMDMA_ADDR_WRITE) || \
    false)

static inline void _nocheck__trace_bmdma_addr_write(uint64_t data)
{
    if (trace_event_get_state(TRACE_BMDMA_ADDR_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 34 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:bmdma_addr_write " "data: 0x%016"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , data);
#line 970 "trace/trace-hw_ide.h"
        } else {
#line 34 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("bmdma_addr_write " "data: 0x%016"PRIx64 "\n", data);
#line 974 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_bmdma_addr_write(uint64_t data)
{
    if (true) {
        _nocheck__trace_bmdma_addr_write(data);
    }
}

#define TRACE_BMDMA_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BMDMA_READ) || \
    false)

static inline void _nocheck__trace_bmdma_read(uint64_t addr, uint8_t val)
{
    if (trace_event_get_state(TRACE_BMDMA_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 37 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:bmdma_read " "bmdma: readb 0x%"PRIx64" : 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 1001 "trace/trace-hw_ide.h"
        } else {
#line 37 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("bmdma_read " "bmdma: readb 0x%"PRIx64" : 0x%02x" "\n", addr, val);
#line 1005 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_bmdma_read(uint64_t addr, uint8_t val)
{
    if (true) {
        _nocheck__trace_bmdma_read(addr, val);
    }
}

#define TRACE_BMDMA_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BMDMA_WRITE) || \
    false)

static inline void _nocheck__trace_bmdma_write(uint64_t addr, uint64_t val)
{
    if (trace_event_get_state(TRACE_BMDMA_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 38 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:bmdma_write " "bmdma: writeb 0x%"PRIx64" : 0x%02"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 1032 "trace/trace-hw_ide.h"
        } else {
#line 38 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("bmdma_write " "bmdma: writeb 0x%"PRIx64" : 0x%02"PRIx64 "\n", addr, val);
#line 1036 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_bmdma_write(uint64_t addr, uint64_t val)
{
    if (true) {
        _nocheck__trace_bmdma_write(addr, val);
    }
}

#define TRACE_SII3112_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SII3112_READ) || \
    false)

static inline void _nocheck__trace_sii3112_read(int size, uint64_t addr, uint64_t val)
{
    if (trace_event_get_state(TRACE_SII3112_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 41 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:sii3112_read " "bmdma: read (size %d) 0x%"PRIx64" : 0x%02"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , size, addr, val);
#line 1063 "trace/trace-hw_ide.h"
        } else {
#line 41 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("sii3112_read " "bmdma: read (size %d) 0x%"PRIx64" : 0x%02"PRIx64 "\n", size, addr, val);
#line 1067 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_sii3112_read(int size, uint64_t addr, uint64_t val)
{
    if (true) {
        _nocheck__trace_sii3112_read(size, addr, val);
    }
}

#define TRACE_SII3112_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SII3112_WRITE) || \
    false)

static inline void _nocheck__trace_sii3112_write(int size, uint64_t addr, uint64_t val)
{
    if (trace_event_get_state(TRACE_SII3112_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 42 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:sii3112_write " "bmdma: write (size %d) 0x%"PRIx64" : 0x%02"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , size, addr, val);
#line 1094 "trace/trace-hw_ide.h"
        } else {
#line 42 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("sii3112_write " "bmdma: write (size %d) 0x%"PRIx64" : 0x%02"PRIx64 "\n", size, addr, val);
#line 1098 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_sii3112_write(int size, uint64_t addr, uint64_t val)
{
    if (true) {
        _nocheck__trace_sii3112_write(size, addr, val);
    }
}

#define TRACE_SII3112_SET_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SII3112_SET_IRQ) || \
    false)

static inline void _nocheck__trace_sii3112_set_irq(int channel, int level)
{
    if (trace_event_get_state(TRACE_SII3112_SET_IRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 43 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:sii3112_set_irq " "channel %d level %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, level);
#line 1125 "trace/trace-hw_ide.h"
        } else {
#line 43 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("sii3112_set_irq " "channel %d level %d" "\n", channel, level);
#line 1129 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_sii3112_set_irq(int channel, int level)
{
    if (true) {
        _nocheck__trace_sii3112_set_irq(channel, level);
    }
}

#define TRACE_BMDMA_READ_VIA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BMDMA_READ_VIA) || \
    false)

static inline void _nocheck__trace_bmdma_read_via(uint64_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_BMDMA_READ_VIA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 46 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:bmdma_read_via " "bmdma: readb 0x%"PRIx64" : 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 1156 "trace/trace-hw_ide.h"
        } else {
#line 46 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("bmdma_read_via " "bmdma: readb 0x%"PRIx64" : 0x%02x" "\n", addr, val);
#line 1160 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_bmdma_read_via(uint64_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_bmdma_read_via(addr, val);
    }
}

#define TRACE_BMDMA_WRITE_VIA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_BMDMA_WRITE_VIA) || \
    false)

static inline void _nocheck__trace_bmdma_write_via(uint64_t addr, uint64_t val)
{
    if (trace_event_get_state(TRACE_BMDMA_WRITE_VIA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 47 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:bmdma_write_via " "bmdma: writeb 0x%"PRIx64" : 0x%02"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 1187 "trace/trace-hw_ide.h"
        } else {
#line 47 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("bmdma_write_via " "bmdma: writeb 0x%"PRIx64" : 0x%02"PRIx64 "\n", addr, val);
#line 1191 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_bmdma_write_via(uint64_t addr, uint64_t val)
{
    if (true) {
        _nocheck__trace_bmdma_write_via(addr, val);
    }
}

#define TRACE_CD_READ_SECTOR_SYNC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CD_READ_SECTOR_SYNC) || \
    false)

static inline void _nocheck__trace_cd_read_sector_sync(int lba)
{
    if (trace_event_get_state(TRACE_CD_READ_SECTOR_SYNC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 50 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:cd_read_sector_sync " "lba=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , lba);
#line 1218 "trace/trace-hw_ide.h"
        } else {
#line 50 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("cd_read_sector_sync " "lba=%d" "\n", lba);
#line 1222 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_cd_read_sector_sync(int lba)
{
    if (true) {
        _nocheck__trace_cd_read_sector_sync(lba);
    }
}

#define TRACE_CD_READ_SECTOR_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CD_READ_SECTOR_CB) || \
    false)

static inline void _nocheck__trace_cd_read_sector_cb(int lba, int ret)
{
    if (trace_event_get_state(TRACE_CD_READ_SECTOR_CB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 51 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:cd_read_sector_cb " "lba=%d ret=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , lba, ret);
#line 1249 "trace/trace-hw_ide.h"
        } else {
#line 51 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("cd_read_sector_cb " "lba=%d ret=%d" "\n", lba, ret);
#line 1253 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_cd_read_sector_cb(int lba, int ret)
{
    if (true) {
        _nocheck__trace_cd_read_sector_cb(lba, ret);
    }
}

#define TRACE_CD_READ_SECTOR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CD_READ_SECTOR) || \
    false)

static inline void _nocheck__trace_cd_read_sector(int lba)
{
    if (trace_event_get_state(TRACE_CD_READ_SECTOR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 52 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:cd_read_sector " "lba=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , lba);
#line 1280 "trace/trace-hw_ide.h"
        } else {
#line 52 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("cd_read_sector " "lba=%d" "\n", lba);
#line 1284 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_cd_read_sector(int lba)
{
    if (true) {
        _nocheck__trace_cd_read_sector(lba);
    }
}

#define TRACE_IDE_ATAPI_CMD_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_ATAPI_CMD_ERROR) || \
    false)

static inline void _nocheck__trace_ide_atapi_cmd_error(void * s, int sense_key, int asc)
{
    if (trace_event_get_state(TRACE_IDE_ATAPI_CMD_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 53 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ide_atapi_cmd_error " "IDEState: %p; sense=0x%x asc=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, sense_key, asc);
#line 1311 "trace/trace-hw_ide.h"
        } else {
#line 53 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ide_atapi_cmd_error " "IDEState: %p; sense=0x%x asc=0x%x" "\n", s, sense_key, asc);
#line 1315 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ide_atapi_cmd_error(void * s, int sense_key, int asc)
{
    if (true) {
        _nocheck__trace_ide_atapi_cmd_error(s, sense_key, asc);
    }
}

#define TRACE_IDE_ATAPI_CMD_REPLY_END_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_ATAPI_CMD_REPLY_END) || \
    false)

static inline void _nocheck__trace_ide_atapi_cmd_reply_end(void * s, int tx_size, int elem_tx_size, int32_t index)
{
    if (trace_event_get_state(TRACE_IDE_ATAPI_CMD_REPLY_END) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 54 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ide_atapi_cmd_reply_end " "IDEState %p; reply: tx_size=%d elem_tx_size=%d index=%"PRId32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, tx_size, elem_tx_size, index);
#line 1342 "trace/trace-hw_ide.h"
        } else {
#line 54 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ide_atapi_cmd_reply_end " "IDEState %p; reply: tx_size=%d elem_tx_size=%d index=%"PRId32 "\n", s, tx_size, elem_tx_size, index);
#line 1346 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ide_atapi_cmd_reply_end(void * s, int tx_size, int elem_tx_size, int32_t index)
{
    if (true) {
        _nocheck__trace_ide_atapi_cmd_reply_end(s, tx_size, elem_tx_size, index);
    }
}

#define TRACE_IDE_ATAPI_CMD_REPLY_END_EOT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_ATAPI_CMD_REPLY_END_EOT) || \
    false)

static inline void _nocheck__trace_ide_atapi_cmd_reply_end_eot(void * s, int status)
{
    if (trace_event_get_state(TRACE_IDE_ATAPI_CMD_REPLY_END_EOT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 55 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ide_atapi_cmd_reply_end_eot " "IDEState: %p; end of transfer, status=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, status);
#line 1373 "trace/trace-hw_ide.h"
        } else {
#line 55 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ide_atapi_cmd_reply_end_eot " "IDEState: %p; end of transfer, status=0x%x" "\n", s, status);
#line 1377 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ide_atapi_cmd_reply_end_eot(void * s, int status)
{
    if (true) {
        _nocheck__trace_ide_atapi_cmd_reply_end_eot(s, status);
    }
}

#define TRACE_IDE_ATAPI_CMD_REPLY_END_BCL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_ATAPI_CMD_REPLY_END_BCL) || \
    false)

static inline void _nocheck__trace_ide_atapi_cmd_reply_end_bcl(void * s, int bcl)
{
    if (trace_event_get_state(TRACE_IDE_ATAPI_CMD_REPLY_END_BCL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 56 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ide_atapi_cmd_reply_end_bcl " "IDEState: %p; byte_count_limit=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, bcl);
#line 1404 "trace/trace-hw_ide.h"
        } else {
#line 56 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ide_atapi_cmd_reply_end_bcl " "IDEState: %p; byte_count_limit=%d" "\n", s, bcl);
#line 1408 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ide_atapi_cmd_reply_end_bcl(void * s, int bcl)
{
    if (true) {
        _nocheck__trace_ide_atapi_cmd_reply_end_bcl(s, bcl);
    }
}

#define TRACE_IDE_ATAPI_CMD_REPLY_END_NEW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_ATAPI_CMD_REPLY_END_NEW) || \
    false)

static inline void _nocheck__trace_ide_atapi_cmd_reply_end_new(void * s, int status)
{
    if (trace_event_get_state(TRACE_IDE_ATAPI_CMD_REPLY_END_NEW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 57 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ide_atapi_cmd_reply_end_new " "IDEState: %p; new transfer started, status=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, status);
#line 1435 "trace/trace-hw_ide.h"
        } else {
#line 57 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ide_atapi_cmd_reply_end_new " "IDEState: %p; new transfer started, status=0x%x" "\n", s, status);
#line 1439 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ide_atapi_cmd_reply_end_new(void * s, int status)
{
    if (true) {
        _nocheck__trace_ide_atapi_cmd_reply_end_new(s, status);
    }
}

#define TRACE_IDE_ATAPI_CMD_CHECK_STATUS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_ATAPI_CMD_CHECK_STATUS) || \
    false)

static inline void _nocheck__trace_ide_atapi_cmd_check_status(void * s)
{
    if (trace_event_get_state(TRACE_IDE_ATAPI_CMD_CHECK_STATUS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 58 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ide_atapi_cmd_check_status " "IDEState: %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s);
#line 1466 "trace/trace-hw_ide.h"
        } else {
#line 58 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ide_atapi_cmd_check_status " "IDEState: %p" "\n", s);
#line 1470 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ide_atapi_cmd_check_status(void * s)
{
    if (true) {
        _nocheck__trace_ide_atapi_cmd_check_status(s);
    }
}

#define TRACE_IDE_ATAPI_CMD_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_ATAPI_CMD_READ) || \
    false)

static inline void _nocheck__trace_ide_atapi_cmd_read(void * s, const char * method, int lba, int nb_sectors)
{
    if (trace_event_get_state(TRACE_IDE_ATAPI_CMD_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 59 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ide_atapi_cmd_read " "IDEState: %p; read %s: LBA=%d nb_sectors=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, method, lba, nb_sectors);
#line 1497 "trace/trace-hw_ide.h"
        } else {
#line 59 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ide_atapi_cmd_read " "IDEState: %p; read %s: LBA=%d nb_sectors=%d" "\n", s, method, lba, nb_sectors);
#line 1501 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ide_atapi_cmd_read(void * s, const char * method, int lba, int nb_sectors)
{
    if (true) {
        _nocheck__trace_ide_atapi_cmd_read(s, method, lba, nb_sectors);
    }
}

#define TRACE_IDE_ATAPI_CMD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_ATAPI_CMD) || \
    false)

static inline void _nocheck__trace_ide_atapi_cmd(void * s, uint8_t cmd)
{
    if (trace_event_get_state(TRACE_IDE_ATAPI_CMD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 60 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ide_atapi_cmd " "IDEState: %p; cmd: 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, cmd);
#line 1528 "trace/trace-hw_ide.h"
        } else {
#line 60 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ide_atapi_cmd " "IDEState: %p; cmd: 0x%02x" "\n", s, cmd);
#line 1532 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ide_atapi_cmd(void * s, uint8_t cmd)
{
    if (true) {
        _nocheck__trace_ide_atapi_cmd(s, cmd);
    }
}

#define TRACE_IDE_ATAPI_CMD_READ_DMA_CB_AIO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_ATAPI_CMD_READ_DMA_CB_AIO) || \
    false)

static inline void _nocheck__trace_ide_atapi_cmd_read_dma_cb_aio(void * s, int lba, int n)
{
    if (trace_event_get_state(TRACE_IDE_ATAPI_CMD_READ_DMA_CB_AIO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 61 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ide_atapi_cmd_read_dma_cb_aio " "IDEState: %p; aio read: lba=%d n=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, lba, n);
#line 1559 "trace/trace-hw_ide.h"
        } else {
#line 61 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ide_atapi_cmd_read_dma_cb_aio " "IDEState: %p; aio read: lba=%d n=%d" "\n", s, lba, n);
#line 1563 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ide_atapi_cmd_read_dma_cb_aio(void * s, int lba, int n)
{
    if (true) {
        _nocheck__trace_ide_atapi_cmd_read_dma_cb_aio(s, lba, n);
    }
}

#define TRACE_IDE_ATAPI_CMD_PACKET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_IDE_ATAPI_CMD_PACKET) || \
    false)

static inline void _nocheck__trace_ide_atapi_cmd_packet(void * s, uint16_t limit, const char * packet)
{
    if (trace_event_get_state(TRACE_IDE_ATAPI_CMD_PACKET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 63 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ide_atapi_cmd_packet " "IDEState: %p; limit=0x%x packet: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, limit, packet);
#line 1590 "trace/trace-hw_ide.h"
        } else {
#line 63 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ide_atapi_cmd_packet " "IDEState: %p; limit=0x%x packet: %s" "\n", s, limit, packet);
#line 1594 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ide_atapi_cmd_packet(void * s, uint16_t limit, const char * packet)
{
    if (true) {
        _nocheck__trace_ide_atapi_cmd_packet(s, limit, packet);
    }
}

#define TRACE_AHCI_PORT_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_PORT_READ) || \
    false)

static inline void _nocheck__trace_ahci_port_read(void * s, int port, const char * reg, int offset, uint32_t ret)
{
    if (trace_event_get_state(TRACE_AHCI_PORT_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 66 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ahci_port_read " "ahci(%p)[%d]: port read [reg:%s] @ 0x%x: 0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port, reg, offset, ret);
#line 1621 "trace/trace-hw_ide.h"
        } else {
#line 66 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ahci_port_read " "ahci(%p)[%d]: port read [reg:%s] @ 0x%x: 0x%08x" "\n", s, port, reg, offset, ret);
#line 1625 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ahci_port_read(void * s, int port, const char * reg, int offset, uint32_t ret)
{
    if (true) {
        _nocheck__trace_ahci_port_read(s, port, reg, offset, ret);
    }
}

#define TRACE_AHCI_PORT_READ_DEFAULT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_PORT_READ_DEFAULT) || \
    false)

static inline void _nocheck__trace_ahci_port_read_default(void * s, int port, const char * reg, int offset)
{
    if (trace_event_get_state(TRACE_AHCI_PORT_READ_DEFAULT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 67 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ahci_port_read_default " "ahci(%p)[%d]: unimplemented port read [reg:%s] @ 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port, reg, offset);
#line 1652 "trace/trace-hw_ide.h"
        } else {
#line 67 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ahci_port_read_default " "ahci(%p)[%d]: unimplemented port read [reg:%s] @ 0x%x" "\n", s, port, reg, offset);
#line 1656 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ahci_port_read_default(void * s, int port, const char * reg, int offset)
{
    if (true) {
        _nocheck__trace_ahci_port_read_default(s, port, reg, offset);
    }
}

#define TRACE_AHCI_IRQ_RAISE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_IRQ_RAISE) || \
    false)

static inline void _nocheck__trace_ahci_irq_raise(void * s)
{
    if (trace_event_get_state(TRACE_AHCI_IRQ_RAISE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 68 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ahci_irq_raise " "ahci(%p): raise irq" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s);
#line 1683 "trace/trace-hw_ide.h"
        } else {
#line 68 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ahci_irq_raise " "ahci(%p): raise irq" "\n", s);
#line 1687 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ahci_irq_raise(void * s)
{
    if (true) {
        _nocheck__trace_ahci_irq_raise(s);
    }
}

#define TRACE_AHCI_IRQ_LOWER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_IRQ_LOWER) || \
    false)

static inline void _nocheck__trace_ahci_irq_lower(void * s)
{
    if (trace_event_get_state(TRACE_AHCI_IRQ_LOWER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 69 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ahci_irq_lower " "ahci(%p): lower irq" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s);
#line 1714 "trace/trace-hw_ide.h"
        } else {
#line 69 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ahci_irq_lower " "ahci(%p): lower irq" "\n", s);
#line 1718 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ahci_irq_lower(void * s)
{
    if (true) {
        _nocheck__trace_ahci_irq_lower(s);
    }
}

#define TRACE_AHCI_CHECK_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_CHECK_IRQ) || \
    false)

static inline void _nocheck__trace_ahci_check_irq(void * s, uint32_t old, uint32_t new)
{
    if (trace_event_get_state(TRACE_AHCI_CHECK_IRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 70 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ahci_check_irq " "ahci(%p): check irq 0x%08x --> 0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, old, new);
#line 1745 "trace/trace-hw_ide.h"
        } else {
#line 70 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ahci_check_irq " "ahci(%p): check irq 0x%08x --> 0x%08x" "\n", s, old, new);
#line 1749 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ahci_check_irq(void * s, uint32_t old, uint32_t new)
{
    if (true) {
        _nocheck__trace_ahci_check_irq(s, old, new);
    }
}

#define TRACE_AHCI_TRIGGER_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_TRIGGER_IRQ) || \
    false)

static inline void _nocheck__trace_ahci_trigger_irq(void * s, int port, const char * name, uint32_t val, uint32_t old, uint32_t new, uint32_t effective)
{
    if (trace_event_get_state(TRACE_AHCI_TRIGGER_IRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 71 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ahci_trigger_irq " "ahci(%p)[%d]: trigger irq +%s (0x%08x); irqstat: 0x%08x --> 0x%08x; effective: 0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port, name, val, old, new, effective);
#line 1776 "trace/trace-hw_ide.h"
        } else {
#line 71 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ahci_trigger_irq " "ahci(%p)[%d]: trigger irq +%s (0x%08x); irqstat: 0x%08x --> 0x%08x; effective: 0x%08x" "\n", s, port, name, val, old, new, effective);
#line 1780 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ahci_trigger_irq(void * s, int port, const char * name, uint32_t val, uint32_t old, uint32_t new, uint32_t effective)
{
    if (true) {
        _nocheck__trace_ahci_trigger_irq(s, port, name, val, old, new, effective);
    }
}

#define TRACE_AHCI_PORT_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_PORT_WRITE) || \
    false)

static inline void _nocheck__trace_ahci_port_write(void * s, int port, const char * reg, int offset, uint32_t val)
{
    if (trace_event_get_state(TRACE_AHCI_PORT_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 72 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ahci_port_write " "ahci(%p)[%d]: port write [reg:%s] @ 0x%x: 0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port, reg, offset, val);
#line 1807 "trace/trace-hw_ide.h"
        } else {
#line 72 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ahci_port_write " "ahci(%p)[%d]: port write [reg:%s] @ 0x%x: 0x%08x" "\n", s, port, reg, offset, val);
#line 1811 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ahci_port_write(void * s, int port, const char * reg, int offset, uint32_t val)
{
    if (true) {
        _nocheck__trace_ahci_port_write(s, port, reg, offset, val);
    }
}

#define TRACE_AHCI_PORT_WRITE_UNIMPL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_PORT_WRITE_UNIMPL) || \
    false)

static inline void _nocheck__trace_ahci_port_write_unimpl(void * s, int port, const char * reg, int offset, uint32_t val)
{
    if (trace_event_get_state(TRACE_AHCI_PORT_WRITE_UNIMPL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 73 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ahci_port_write_unimpl " "ahci(%p)[%d]: unimplemented port write [reg:%s] @ 0x%x: 0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port, reg, offset, val);
#line 1838 "trace/trace-hw_ide.h"
        } else {
#line 73 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ahci_port_write_unimpl " "ahci(%p)[%d]: unimplemented port write [reg:%s] @ 0x%x: 0x%08x" "\n", s, port, reg, offset, val);
#line 1842 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ahci_port_write_unimpl(void * s, int port, const char * reg, int offset, uint32_t val)
{
    if (true) {
        _nocheck__trace_ahci_port_write_unimpl(s, port, reg, offset, val);
    }
}

#define TRACE_AHCI_MEM_READ_32_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_MEM_READ_32) || \
    false)

static inline void _nocheck__trace_ahci_mem_read_32(void * s, uint64_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_AHCI_MEM_READ_32) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 74 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ahci_mem_read_32 " "ahci(%p): mem read @ 0x%"PRIx64": 0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, addr, val);
#line 1869 "trace/trace-hw_ide.h"
        } else {
#line 74 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ahci_mem_read_32 " "ahci(%p): mem read @ 0x%"PRIx64": 0x%08x" "\n", s, addr, val);
#line 1873 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ahci_mem_read_32(void * s, uint64_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_ahci_mem_read_32(s, addr, val);
    }
}

#define TRACE_AHCI_MEM_READ_32_DEFAULT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_MEM_READ_32_DEFAULT) || \
    false)

static inline void _nocheck__trace_ahci_mem_read_32_default(void * s, uint64_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_AHCI_MEM_READ_32_DEFAULT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 75 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ahci_mem_read_32_default " "ahci(%p): mem read @ 0x%"PRIx64": 0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, addr, val);
#line 1900 "trace/trace-hw_ide.h"
        } else {
#line 75 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ahci_mem_read_32_default " "ahci(%p): mem read @ 0x%"PRIx64": 0x%08x" "\n", s, addr, val);
#line 1904 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ahci_mem_read_32_default(void * s, uint64_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_ahci_mem_read_32_default(s, addr, val);
    }
}

#define TRACE_AHCI_MEM_READ_32_HOST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_MEM_READ_32_HOST) || \
    false)

static inline void _nocheck__trace_ahci_mem_read_32_host(void * s, const char * reg, uint64_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_AHCI_MEM_READ_32_HOST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 76 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ahci_mem_read_32_host " "ahci(%p): mem read [reg:%s] @ 0x%"PRIx64": 0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, reg, addr, val);
#line 1931 "trace/trace-hw_ide.h"
        } else {
#line 76 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ahci_mem_read_32_host " "ahci(%p): mem read [reg:%s] @ 0x%"PRIx64": 0x%08x" "\n", s, reg, addr, val);
#line 1935 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ahci_mem_read_32_host(void * s, const char * reg, uint64_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_ahci_mem_read_32_host(s, reg, addr, val);
    }
}

#define TRACE_AHCI_MEM_READ_32_HOST_DEFAULT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_MEM_READ_32_HOST_DEFAULT) || \
    false)

static inline void _nocheck__trace_ahci_mem_read_32_host_default(void * s, const char * reg, uint64_t addr)
{
    if (trace_event_get_state(TRACE_AHCI_MEM_READ_32_HOST_DEFAULT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 77 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ahci_mem_read_32_host_default " "ahci(%p): unimplemented mem read [reg:%s] @ 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, reg, addr);
#line 1962 "trace/trace-hw_ide.h"
        } else {
#line 77 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ahci_mem_read_32_host_default " "ahci(%p): unimplemented mem read [reg:%s] @ 0x%"PRIx64 "\n", s, reg, addr);
#line 1966 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ahci_mem_read_32_host_default(void * s, const char * reg, uint64_t addr)
{
    if (true) {
        _nocheck__trace_ahci_mem_read_32_host_default(s, reg, addr);
    }
}

#define TRACE_AHCI_MEM_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_MEM_READ) || \
    false)

static inline void _nocheck__trace_ahci_mem_read(void * s, unsigned size, uint64_t addr, uint64_t val)
{
    if (trace_event_get_state(TRACE_AHCI_MEM_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 78 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ahci_mem_read " "ahci(%p): read%u @ 0x%"PRIx64": 0x%016"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, size, addr, val);
#line 1993 "trace/trace-hw_ide.h"
        } else {
#line 78 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ahci_mem_read " "ahci(%p): read%u @ 0x%"PRIx64": 0x%016"PRIx64 "\n", s, size, addr, val);
#line 1997 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ahci_mem_read(void * s, unsigned size, uint64_t addr, uint64_t val)
{
    if (true) {
        _nocheck__trace_ahci_mem_read(s, size, addr, val);
    }
}

#define TRACE_AHCI_MEM_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_MEM_WRITE) || \
    false)

static inline void _nocheck__trace_ahci_mem_write(void * s, unsigned size, uint64_t addr, uint64_t val)
{
    if (trace_event_get_state(TRACE_AHCI_MEM_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 79 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ahci_mem_write " "ahci(%p): write%u @ 0x%"PRIx64": 0x%016"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, size, addr, val);
#line 2024 "trace/trace-hw_ide.h"
        } else {
#line 79 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ahci_mem_write " "ahci(%p): write%u @ 0x%"PRIx64": 0x%016"PRIx64 "\n", s, size, addr, val);
#line 2028 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ahci_mem_write(void * s, unsigned size, uint64_t addr, uint64_t val)
{
    if (true) {
        _nocheck__trace_ahci_mem_write(s, size, addr, val);
    }
}

#define TRACE_AHCI_MEM_WRITE_HOST_UNIMPL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_MEM_WRITE_HOST_UNIMPL) || \
    false)

static inline void _nocheck__trace_ahci_mem_write_host_unimpl(void * s, unsigned size, const char * reg, uint64_t addr)
{
    if (trace_event_get_state(TRACE_AHCI_MEM_WRITE_HOST_UNIMPL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 80 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ahci_mem_write_host_unimpl " "ahci(%p) unimplemented write%u [reg:%s] @ 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, size, reg, addr);
#line 2055 "trace/trace-hw_ide.h"
        } else {
#line 80 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ahci_mem_write_host_unimpl " "ahci(%p) unimplemented write%u [reg:%s] @ 0x%"PRIx64 "\n", s, size, reg, addr);
#line 2059 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ahci_mem_write_host_unimpl(void * s, unsigned size, const char * reg, uint64_t addr)
{
    if (true) {
        _nocheck__trace_ahci_mem_write_host_unimpl(s, size, reg, addr);
    }
}

#define TRACE_AHCI_MEM_WRITE_HOST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_MEM_WRITE_HOST) || \
    false)

static inline void _nocheck__trace_ahci_mem_write_host(void * s, unsigned size, const char * reg, uint64_t addr, uint64_t val)
{
    if (trace_event_get_state(TRACE_AHCI_MEM_WRITE_HOST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 81 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ahci_mem_write_host " "ahci(%p) write%u [reg:%s] @ 0x%"PRIx64": 0x%016"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, size, reg, addr, val);
#line 2086 "trace/trace-hw_ide.h"
        } else {
#line 81 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ahci_mem_write_host " "ahci(%p) write%u [reg:%s] @ 0x%"PRIx64": 0x%016"PRIx64 "\n", s, size, reg, addr, val);
#line 2090 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ahci_mem_write_host(void * s, unsigned size, const char * reg, uint64_t addr, uint64_t val)
{
    if (true) {
        _nocheck__trace_ahci_mem_write_host(s, size, reg, addr, val);
    }
}

#define TRACE_AHCI_MEM_WRITE_UNIMPL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_MEM_WRITE_UNIMPL) || \
    false)

static inline void _nocheck__trace_ahci_mem_write_unimpl(void * s, unsigned size, uint64_t addr, uint64_t val)
{
    if (trace_event_get_state(TRACE_AHCI_MEM_WRITE_UNIMPL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 82 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ahci_mem_write_unimpl " "ahci(%p): write%u to unknown register 0x%"PRIx64": 0x%016"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, size, addr, val);
#line 2117 "trace/trace-hw_ide.h"
        } else {
#line 82 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ahci_mem_write_unimpl " "ahci(%p): write%u to unknown register 0x%"PRIx64": 0x%016"PRIx64 "\n", s, size, addr, val);
#line 2121 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ahci_mem_write_unimpl(void * s, unsigned size, uint64_t addr, uint64_t val)
{
    if (true) {
        _nocheck__trace_ahci_mem_write_unimpl(s, size, addr, val);
    }
}

#define TRACE_AHCI_SET_SIGNATURE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_SET_SIGNATURE) || \
    false)

static inline void _nocheck__trace_ahci_set_signature(void * s, int port, uint8_t nsector, uint8_t sector, uint8_t lcyl, uint8_t hcyl, uint32_t sig)
{
    if (trace_event_get_state(TRACE_AHCI_SET_SIGNATURE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 83 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ahci_set_signature " "ahci(%p)[%d]: set signature sector:0x%02x nsector:0x%02x lcyl:0x%02x hcyl:0x%02x (cumulatively: 0x%08x)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port, nsector, sector, lcyl, hcyl, sig);
#line 2148 "trace/trace-hw_ide.h"
        } else {
#line 83 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ahci_set_signature " "ahci(%p)[%d]: set signature sector:0x%02x nsector:0x%02x lcyl:0x%02x hcyl:0x%02x (cumulatively: 0x%08x)" "\n", s, port, nsector, sector, lcyl, hcyl, sig);
#line 2152 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ahci_set_signature(void * s, int port, uint8_t nsector, uint8_t sector, uint8_t lcyl, uint8_t hcyl, uint32_t sig)
{
    if (true) {
        _nocheck__trace_ahci_set_signature(s, port, nsector, sector, lcyl, hcyl, sig);
    }
}

#define TRACE_AHCI_RESET_PORT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_RESET_PORT) || \
    false)

static inline void _nocheck__trace_ahci_reset_port(void * s, int port)
{
    if (trace_event_get_state(TRACE_AHCI_RESET_PORT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 84 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ahci_reset_port " "ahci(%p)[%d]: reset port" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port);
#line 2179 "trace/trace-hw_ide.h"
        } else {
#line 84 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ahci_reset_port " "ahci(%p)[%d]: reset port" "\n", s, port);
#line 2183 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ahci_reset_port(void * s, int port)
{
    if (true) {
        _nocheck__trace_ahci_reset_port(s, port);
    }
}

#define TRACE_AHCI_UNMAP_FIS_ADDRESS_NULL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_UNMAP_FIS_ADDRESS_NULL) || \
    false)

static inline void _nocheck__trace_ahci_unmap_fis_address_null(void * s, int port)
{
    if (trace_event_get_state(TRACE_AHCI_UNMAP_FIS_ADDRESS_NULL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 85 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ahci_unmap_fis_address_null " "ahci(%p)[%d]: Attempt to unmap NULL FIS address" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port);
#line 2210 "trace/trace-hw_ide.h"
        } else {
#line 85 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ahci_unmap_fis_address_null " "ahci(%p)[%d]: Attempt to unmap NULL FIS address" "\n", s, port);
#line 2214 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ahci_unmap_fis_address_null(void * s, int port)
{
    if (true) {
        _nocheck__trace_ahci_unmap_fis_address_null(s, port);
    }
}

#define TRACE_AHCI_UNMAP_CLB_ADDRESS_NULL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_UNMAP_CLB_ADDRESS_NULL) || \
    false)

static inline void _nocheck__trace_ahci_unmap_clb_address_null(void * s, int port)
{
    if (trace_event_get_state(TRACE_AHCI_UNMAP_CLB_ADDRESS_NULL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 86 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ahci_unmap_clb_address_null " "ahci(%p)[%d]: Attempt to unmap NULL CLB address" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port);
#line 2241 "trace/trace-hw_ide.h"
        } else {
#line 86 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ahci_unmap_clb_address_null " "ahci(%p)[%d]: Attempt to unmap NULL CLB address" "\n", s, port);
#line 2245 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ahci_unmap_clb_address_null(void * s, int port)
{
    if (true) {
        _nocheck__trace_ahci_unmap_clb_address_null(s, port);
    }
}

#define TRACE_AHCI_POPULATE_SGLIST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_POPULATE_SGLIST) || \
    false)

static inline void _nocheck__trace_ahci_populate_sglist(void * s, int port)
{
    if (trace_event_get_state(TRACE_AHCI_POPULATE_SGLIST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 87 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ahci_populate_sglist " "ahci(%p)[%d]" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port);
#line 2272 "trace/trace-hw_ide.h"
        } else {
#line 87 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ahci_populate_sglist " "ahci(%p)[%d]" "\n", s, port);
#line 2276 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ahci_populate_sglist(void * s, int port)
{
    if (true) {
        _nocheck__trace_ahci_populate_sglist(s, port);
    }
}

#define TRACE_AHCI_POPULATE_SGLIST_NO_PRDTL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_POPULATE_SGLIST_NO_PRDTL) || \
    false)

static inline void _nocheck__trace_ahci_populate_sglist_no_prdtl(void * s, int port, uint16_t opts)
{
    if (trace_event_get_state(TRACE_AHCI_POPULATE_SGLIST_NO_PRDTL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 88 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ahci_populate_sglist_no_prdtl " "ahci(%p)[%d]: no sg list given by guest: 0x%04x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port, opts);
#line 2303 "trace/trace-hw_ide.h"
        } else {
#line 88 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ahci_populate_sglist_no_prdtl " "ahci(%p)[%d]: no sg list given by guest: 0x%04x" "\n", s, port, opts);
#line 2307 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ahci_populate_sglist_no_prdtl(void * s, int port, uint16_t opts)
{
    if (true) {
        _nocheck__trace_ahci_populate_sglist_no_prdtl(s, port, opts);
    }
}

#define TRACE_AHCI_POPULATE_SGLIST_NO_MAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_POPULATE_SGLIST_NO_MAP) || \
    false)

static inline void _nocheck__trace_ahci_populate_sglist_no_map(void * s, int port)
{
    if (trace_event_get_state(TRACE_AHCI_POPULATE_SGLIST_NO_MAP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 89 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ahci_populate_sglist_no_map " "ahci(%p)[%d]: DMA mapping failed" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port);
#line 2334 "trace/trace-hw_ide.h"
        } else {
#line 89 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ahci_populate_sglist_no_map " "ahci(%p)[%d]: DMA mapping failed" "\n", s, port);
#line 2338 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ahci_populate_sglist_no_map(void * s, int port)
{
    if (true) {
        _nocheck__trace_ahci_populate_sglist_no_map(s, port);
    }
}

#define TRACE_AHCI_POPULATE_SGLIST_SHORT_MAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_POPULATE_SGLIST_SHORT_MAP) || \
    false)

static inline void _nocheck__trace_ahci_populate_sglist_short_map(void * s, int port)
{
    if (trace_event_get_state(TRACE_AHCI_POPULATE_SGLIST_SHORT_MAP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 90 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ahci_populate_sglist_short_map " "ahci(%p)[%d]: mapped less than expected" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port);
#line 2365 "trace/trace-hw_ide.h"
        } else {
#line 90 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ahci_populate_sglist_short_map " "ahci(%p)[%d]: mapped less than expected" "\n", s, port);
#line 2369 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ahci_populate_sglist_short_map(void * s, int port)
{
    if (true) {
        _nocheck__trace_ahci_populate_sglist_short_map(s, port);
    }
}

#define TRACE_AHCI_POPULATE_SGLIST_BAD_OFFSET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_POPULATE_SGLIST_BAD_OFFSET) || \
    false)

static inline void _nocheck__trace_ahci_populate_sglist_bad_offset(void * s, int port, int off_idx, int64_t off_pos)
{
    if (trace_event_get_state(TRACE_AHCI_POPULATE_SGLIST_BAD_OFFSET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 91 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ahci_populate_sglist_bad_offset " "ahci(%p)[%d]: Incorrect offset! off_idx: %d, off_pos: %"PRId64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port, off_idx, off_pos);
#line 2396 "trace/trace-hw_ide.h"
        } else {
#line 91 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ahci_populate_sglist_bad_offset " "ahci(%p)[%d]: Incorrect offset! off_idx: %d, off_pos: %"PRId64 "\n", s, port, off_idx, off_pos);
#line 2400 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ahci_populate_sglist_bad_offset(void * s, int port, int off_idx, int64_t off_pos)
{
    if (true) {
        _nocheck__trace_ahci_populate_sglist_bad_offset(s, port, off_idx, off_pos);
    }
}

#define TRACE_NCQ_FINISH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NCQ_FINISH) || \
    false)

static inline void _nocheck__trace_ncq_finish(void * s, int port, uint8_t tag)
{
    if (trace_event_get_state(TRACE_NCQ_FINISH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 92 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ncq_finish " "ahci(%p)[%d][tag:%d]: NCQ transfer finished" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port, tag);
#line 2427 "trace/trace-hw_ide.h"
        } else {
#line 92 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ncq_finish " "ahci(%p)[%d][tag:%d]: NCQ transfer finished" "\n", s, port, tag);
#line 2431 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ncq_finish(void * s, int port, uint8_t tag)
{
    if (true) {
        _nocheck__trace_ncq_finish(s, port, tag);
    }
}

#define TRACE_EXECUTE_NCQ_COMMAND_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXECUTE_NCQ_COMMAND_READ) || \
    false)

static inline void _nocheck__trace_execute_ncq_command_read(void * s, int port, uint8_t tag, int count, int64_t lba)
{
    if (trace_event_get_state(TRACE_EXECUTE_NCQ_COMMAND_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 93 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:execute_ncq_command_read " "ahci(%p)[%d][tag:%d]: NCQ reading %d sectors from LBA %"PRId64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port, tag, count, lba);
#line 2458 "trace/trace-hw_ide.h"
        } else {
#line 93 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("execute_ncq_command_read " "ahci(%p)[%d][tag:%d]: NCQ reading %d sectors from LBA %"PRId64 "\n", s, port, tag, count, lba);
#line 2462 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_execute_ncq_command_read(void * s, int port, uint8_t tag, int count, int64_t lba)
{
    if (true) {
        _nocheck__trace_execute_ncq_command_read(s, port, tag, count, lba);
    }
}

#define TRACE_EXECUTE_NCQ_COMMAND_UNSUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXECUTE_NCQ_COMMAND_UNSUP) || \
    false)

static inline void _nocheck__trace_execute_ncq_command_unsup(void * s, int port, uint8_t tag, uint8_t cmd)
{
    if (trace_event_get_state(TRACE_EXECUTE_NCQ_COMMAND_UNSUP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 94 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:execute_ncq_command_unsup " "ahci(%p)[%d][tag:%d]: error: unsupported NCQ command (0x%02x) received" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port, tag, cmd);
#line 2489 "trace/trace-hw_ide.h"
        } else {
#line 94 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("execute_ncq_command_unsup " "ahci(%p)[%d][tag:%d]: error: unsupported NCQ command (0x%02x) received" "\n", s, port, tag, cmd);
#line 2493 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_execute_ncq_command_unsup(void * s, int port, uint8_t tag, uint8_t cmd)
{
    if (true) {
        _nocheck__trace_execute_ncq_command_unsup(s, port, tag, cmd);
    }
}

#define TRACE_PROCESS_NCQ_COMMAND_MISMATCH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PROCESS_NCQ_COMMAND_MISMATCH) || \
    false)

static inline void _nocheck__trace_process_ncq_command_mismatch(void * s, int port, uint8_t tag, uint8_t slot)
{
    if (trace_event_get_state(TRACE_PROCESS_NCQ_COMMAND_MISMATCH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 95 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:process_ncq_command_mismatch " "ahci(%p)[%d][tag:%d]: Warning: NCQ slot (%d) did not match the given tag" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port, tag, slot);
#line 2520 "trace/trace-hw_ide.h"
        } else {
#line 95 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("process_ncq_command_mismatch " "ahci(%p)[%d][tag:%d]: Warning: NCQ slot (%d) did not match the given tag" "\n", s, port, tag, slot);
#line 2524 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_process_ncq_command_mismatch(void * s, int port, uint8_t tag, uint8_t slot)
{
    if (true) {
        _nocheck__trace_process_ncq_command_mismatch(s, port, tag, slot);
    }
}

#define TRACE_PROCESS_NCQ_COMMAND_AUX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PROCESS_NCQ_COMMAND_AUX) || \
    false)

static inline void _nocheck__trace_process_ncq_command_aux(void * s, int port, uint8_t tag)
{
    if (trace_event_get_state(TRACE_PROCESS_NCQ_COMMAND_AUX) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 96 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:process_ncq_command_aux " "ahci(%p)[%d][tag:%d]: Warn: Attempt to use NCQ auxiliary fields" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port, tag);
#line 2551 "trace/trace-hw_ide.h"
        } else {
#line 96 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("process_ncq_command_aux " "ahci(%p)[%d][tag:%d]: Warn: Attempt to use NCQ auxiliary fields" "\n", s, port, tag);
#line 2555 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_process_ncq_command_aux(void * s, int port, uint8_t tag)
{
    if (true) {
        _nocheck__trace_process_ncq_command_aux(s, port, tag);
    }
}

#define TRACE_PROCESS_NCQ_COMMAND_PRIOICC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PROCESS_NCQ_COMMAND_PRIOICC) || \
    false)

static inline void _nocheck__trace_process_ncq_command_prioicc(void * s, int port, uint8_t tag)
{
    if (trace_event_get_state(TRACE_PROCESS_NCQ_COMMAND_PRIOICC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 97 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:process_ncq_command_prioicc " "ahci(%p)[%d][tag:%d]: Warn: Unsupported attempt to use PRIO/ICC fields" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port, tag);
#line 2582 "trace/trace-hw_ide.h"
        } else {
#line 97 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("process_ncq_command_prioicc " "ahci(%p)[%d][tag:%d]: Warn: Unsupported attempt to use PRIO/ICC fields" "\n", s, port, tag);
#line 2586 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_process_ncq_command_prioicc(void * s, int port, uint8_t tag)
{
    if (true) {
        _nocheck__trace_process_ncq_command_prioicc(s, port, tag);
    }
}

#define TRACE_PROCESS_NCQ_COMMAND_FUA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PROCESS_NCQ_COMMAND_FUA) || \
    false)

static inline void _nocheck__trace_process_ncq_command_fua(void * s, int port, uint8_t tag)
{
    if (trace_event_get_state(TRACE_PROCESS_NCQ_COMMAND_FUA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 98 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:process_ncq_command_fua " "ahci(%p)[%d][tag:%d]: Warn: Unsupported attempt to use Force Unit Access" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port, tag);
#line 2613 "trace/trace-hw_ide.h"
        } else {
#line 98 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("process_ncq_command_fua " "ahci(%p)[%d][tag:%d]: Warn: Unsupported attempt to use Force Unit Access" "\n", s, port, tag);
#line 2617 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_process_ncq_command_fua(void * s, int port, uint8_t tag)
{
    if (true) {
        _nocheck__trace_process_ncq_command_fua(s, port, tag);
    }
}

#define TRACE_PROCESS_NCQ_COMMAND_RARC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PROCESS_NCQ_COMMAND_RARC) || \
    false)

static inline void _nocheck__trace_process_ncq_command_rarc(void * s, int port, uint8_t tag)
{
    if (trace_event_get_state(TRACE_PROCESS_NCQ_COMMAND_RARC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 99 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:process_ncq_command_rarc " "ahci(%p)[%d][tag:%d]: Warn: Unsupported attempt to use Rebuild Assist" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port, tag);
#line 2644 "trace/trace-hw_ide.h"
        } else {
#line 99 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("process_ncq_command_rarc " "ahci(%p)[%d][tag:%d]: Warn: Unsupported attempt to use Rebuild Assist" "\n", s, port, tag);
#line 2648 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_process_ncq_command_rarc(void * s, int port, uint8_t tag)
{
    if (true) {
        _nocheck__trace_process_ncq_command_rarc(s, port, tag);
    }
}

#define TRACE_PROCESS_NCQ_COMMAND_LARGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PROCESS_NCQ_COMMAND_LARGE) || \
    false)

static inline void _nocheck__trace_process_ncq_command_large(void * s, int port, uint8_t tag, size_t prdtl, size_t size)
{
    if (trace_event_get_state(TRACE_PROCESS_NCQ_COMMAND_LARGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 100 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:process_ncq_command_large " "ahci(%p)[%d][tag:%d]: Warn: PRDTL (0x%zx) does not match requested size (0x%zx)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port, tag, prdtl, size);
#line 2675 "trace/trace-hw_ide.h"
        } else {
#line 100 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("process_ncq_command_large " "ahci(%p)[%d][tag:%d]: Warn: PRDTL (0x%zx) does not match requested size (0x%zx)" "\n", s, port, tag, prdtl, size);
#line 2679 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_process_ncq_command_large(void * s, int port, uint8_t tag, size_t prdtl, size_t size)
{
    if (true) {
        _nocheck__trace_process_ncq_command_large(s, port, tag, prdtl, size);
    }
}

#define TRACE_PROCESS_NCQ_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PROCESS_NCQ_COMMAND) || \
    false)

static inline void _nocheck__trace_process_ncq_command(void * s, int port, uint8_t tag, uint8_t cmd, uint64_t lba, uint64_t end)
{
    if (trace_event_get_state(TRACE_PROCESS_NCQ_COMMAND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 101 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:process_ncq_command " "ahci(%p)[%d][tag:%d]: NCQ op 0x%02x on sectors [%"PRId64",%"PRId64"]" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port, tag, cmd, lba, end);
#line 2706 "trace/trace-hw_ide.h"
        } else {
#line 101 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("process_ncq_command " "ahci(%p)[%d][tag:%d]: NCQ op 0x%02x on sectors [%"PRId64",%"PRId64"]" "\n", s, port, tag, cmd, lba, end);
#line 2710 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_process_ncq_command(void * s, int port, uint8_t tag, uint8_t cmd, uint64_t lba, uint64_t end)
{
    if (true) {
        _nocheck__trace_process_ncq_command(s, port, tag, cmd, lba, end);
    }
}

#define TRACE_HANDLE_REG_H2D_FIS_PMP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HANDLE_REG_H2D_FIS_PMP) || \
    false)

static inline void _nocheck__trace_handle_reg_h2d_fis_pmp(void * s, int port, char b0, char b1, char b2)
{
    if (trace_event_get_state(TRACE_HANDLE_REG_H2D_FIS_PMP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 102 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:handle_reg_h2d_fis_pmp " "ahci(%p)[%d]: Port Multiplier not supported, FIS: 0x%02x-%02x-%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port, b0, b1, b2);
#line 2737 "trace/trace-hw_ide.h"
        } else {
#line 102 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("handle_reg_h2d_fis_pmp " "ahci(%p)[%d]: Port Multiplier not supported, FIS: 0x%02x-%02x-%02x" "\n", s, port, b0, b1, b2);
#line 2741 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_handle_reg_h2d_fis_pmp(void * s, int port, char b0, char b1, char b2)
{
    if (true) {
        _nocheck__trace_handle_reg_h2d_fis_pmp(s, port, b0, b1, b2);
    }
}

#define TRACE_HANDLE_REG_H2D_FIS_RES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HANDLE_REG_H2D_FIS_RES) || \
    false)

static inline void _nocheck__trace_handle_reg_h2d_fis_res(void * s, int port, char b0, char b1, char b2)
{
    if (trace_event_get_state(TRACE_HANDLE_REG_H2D_FIS_RES) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 103 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:handle_reg_h2d_fis_res " "ahci(%p)[%d]: Reserved flags set in H2D Register FIS, FIS: 0x%02x-%02x-%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port, b0, b1, b2);
#line 2768 "trace/trace-hw_ide.h"
        } else {
#line 103 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("handle_reg_h2d_fis_res " "ahci(%p)[%d]: Reserved flags set in H2D Register FIS, FIS: 0x%02x-%02x-%02x" "\n", s, port, b0, b1, b2);
#line 2772 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_handle_reg_h2d_fis_res(void * s, int port, char b0, char b1, char b2)
{
    if (true) {
        _nocheck__trace_handle_reg_h2d_fis_res(s, port, b0, b1, b2);
    }
}

#define TRACE_HANDLE_CMD_BUSY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HANDLE_CMD_BUSY) || \
    false)

static inline void _nocheck__trace_handle_cmd_busy(void * s, int port)
{
    if (trace_event_get_state(TRACE_HANDLE_CMD_BUSY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 104 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:handle_cmd_busy " "ahci(%p)[%d]: engine busy" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port);
#line 2799 "trace/trace-hw_ide.h"
        } else {
#line 104 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("handle_cmd_busy " "ahci(%p)[%d]: engine busy" "\n", s, port);
#line 2803 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_handle_cmd_busy(void * s, int port)
{
    if (true) {
        _nocheck__trace_handle_cmd_busy(s, port);
    }
}

#define TRACE_HANDLE_CMD_NOLIST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HANDLE_CMD_NOLIST) || \
    false)

static inline void _nocheck__trace_handle_cmd_nolist(void * s, int port)
{
    if (trace_event_get_state(TRACE_HANDLE_CMD_NOLIST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 105 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:handle_cmd_nolist " "ahci(%p)[%d]: handle_cmd called without s->dev[port].lst" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port);
#line 2830 "trace/trace-hw_ide.h"
        } else {
#line 105 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("handle_cmd_nolist " "ahci(%p)[%d]: handle_cmd called without s->dev[port].lst" "\n", s, port);
#line 2834 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_handle_cmd_nolist(void * s, int port)
{
    if (true) {
        _nocheck__trace_handle_cmd_nolist(s, port);
    }
}

#define TRACE_HANDLE_CMD_BADPORT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HANDLE_CMD_BADPORT) || \
    false)

static inline void _nocheck__trace_handle_cmd_badport(void * s, int port)
{
    if (trace_event_get_state(TRACE_HANDLE_CMD_BADPORT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 106 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:handle_cmd_badport " "ahci(%p)[%d]: guest accessed unused port" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port);
#line 2861 "trace/trace-hw_ide.h"
        } else {
#line 106 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("handle_cmd_badport " "ahci(%p)[%d]: guest accessed unused port" "\n", s, port);
#line 2865 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_handle_cmd_badport(void * s, int port)
{
    if (true) {
        _nocheck__trace_handle_cmd_badport(s, port);
    }
}

#define TRACE_HANDLE_CMD_BADFIS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HANDLE_CMD_BADFIS) || \
    false)

static inline void _nocheck__trace_handle_cmd_badfis(void * s, int port)
{
    if (trace_event_get_state(TRACE_HANDLE_CMD_BADFIS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 107 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:handle_cmd_badfis " "ahci(%p)[%d]: guest provided an invalid cmd FIS" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port);
#line 2892 "trace/trace-hw_ide.h"
        } else {
#line 107 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("handle_cmd_badfis " "ahci(%p)[%d]: guest provided an invalid cmd FIS" "\n", s, port);
#line 2896 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_handle_cmd_badfis(void * s, int port)
{
    if (true) {
        _nocheck__trace_handle_cmd_badfis(s, port);
    }
}

#define TRACE_HANDLE_CMD_BADMAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HANDLE_CMD_BADMAP) || \
    false)

static inline void _nocheck__trace_handle_cmd_badmap(void * s, int port, uint64_t len)
{
    if (trace_event_get_state(TRACE_HANDLE_CMD_BADMAP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 108 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:handle_cmd_badmap " "ahci(%p)[%d]: dma_memory_map failed, 0x%02"PRIx64" != 0x80" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port, len);
#line 2923 "trace/trace-hw_ide.h"
        } else {
#line 108 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("handle_cmd_badmap " "ahci(%p)[%d]: dma_memory_map failed, 0x%02"PRIx64" != 0x80" "\n", s, port, len);
#line 2927 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_handle_cmd_badmap(void * s, int port, uint64_t len)
{
    if (true) {
        _nocheck__trace_handle_cmd_badmap(s, port, len);
    }
}

#define TRACE_HANDLE_CMD_UNHANDLED_FIS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HANDLE_CMD_UNHANDLED_FIS) || \
    false)

static inline void _nocheck__trace_handle_cmd_unhandled_fis(void * s, int port, uint8_t b0, uint8_t b1, uint8_t b2)
{
    if (trace_event_get_state(TRACE_HANDLE_CMD_UNHANDLED_FIS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 109 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:handle_cmd_unhandled_fis " "ahci(%p)[%d]: unhandled FIS type. cmd_fis: 0x%02x-%02x-%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port, b0, b1, b2);
#line 2954 "trace/trace-hw_ide.h"
        } else {
#line 109 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("handle_cmd_unhandled_fis " "ahci(%p)[%d]: unhandled FIS type. cmd_fis: 0x%02x-%02x-%02x" "\n", s, port, b0, b1, b2);
#line 2958 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_handle_cmd_unhandled_fis(void * s, int port, uint8_t b0, uint8_t b1, uint8_t b2)
{
    if (true) {
        _nocheck__trace_handle_cmd_unhandled_fis(s, port, b0, b1, b2);
    }
}

#define TRACE_AHCI_PIO_TRANSFER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_PIO_TRANSFER) || \
    false)

static inline void _nocheck__trace_ahci_pio_transfer(void * s, int port, const char * rw, uint32_t size, const char * tgt, const char * sgl)
{
    if (trace_event_get_state(TRACE_AHCI_PIO_TRANSFER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 110 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ahci_pio_transfer " "ahci(%p)[%d]: %sing %d bytes on %s w/%s sglist" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port, rw, size, tgt, sgl);
#line 2985 "trace/trace-hw_ide.h"
        } else {
#line 110 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ahci_pio_transfer " "ahci(%p)[%d]: %sing %d bytes on %s w/%s sglist" "\n", s, port, rw, size, tgt, sgl);
#line 2989 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ahci_pio_transfer(void * s, int port, const char * rw, uint32_t size, const char * tgt, const char * sgl)
{
    if (true) {
        _nocheck__trace_ahci_pio_transfer(s, port, rw, size, tgt, sgl);
    }
}

#define TRACE_AHCI_START_DMA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_START_DMA) || \
    false)

static inline void _nocheck__trace_ahci_start_dma(void * s, int port)
{
    if (trace_event_get_state(TRACE_AHCI_START_DMA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 111 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ahci_start_dma " "ahci(%p)[%d]: start dma" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port);
#line 3016 "trace/trace-hw_ide.h"
        } else {
#line 111 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ahci_start_dma " "ahci(%p)[%d]: start dma" "\n", s, port);
#line 3020 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ahci_start_dma(void * s, int port)
{
    if (true) {
        _nocheck__trace_ahci_start_dma(s, port);
    }
}

#define TRACE_AHCI_DMA_PREPARE_BUF_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_DMA_PREPARE_BUF) || \
    false)

static inline void _nocheck__trace_ahci_dma_prepare_buf(void * s, int port, int32_t io_buffer_size, int32_t limit)
{
    if (trace_event_get_state(TRACE_AHCI_DMA_PREPARE_BUF) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 112 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ahci_dma_prepare_buf " "ahci(%p)[%d]: prepare buf limit=%"PRId32" prepared=%"PRId32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port, io_buffer_size, limit);
#line 3047 "trace/trace-hw_ide.h"
        } else {
#line 112 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ahci_dma_prepare_buf " "ahci(%p)[%d]: prepare buf limit=%"PRId32" prepared=%"PRId32 "\n", s, port, io_buffer_size, limit);
#line 3051 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ahci_dma_prepare_buf(void * s, int port, int32_t io_buffer_size, int32_t limit)
{
    if (true) {
        _nocheck__trace_ahci_dma_prepare_buf(s, port, io_buffer_size, limit);
    }
}

#define TRACE_AHCI_DMA_PREPARE_BUF_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_DMA_PREPARE_BUF_FAIL) || \
    false)

static inline void _nocheck__trace_ahci_dma_prepare_buf_fail(void * s, int port)
{
    if (trace_event_get_state(TRACE_AHCI_DMA_PREPARE_BUF_FAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 113 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ahci_dma_prepare_buf_fail " "ahci(%p)[%d]: sglist population failed" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port);
#line 3078 "trace/trace-hw_ide.h"
        } else {
#line 113 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ahci_dma_prepare_buf_fail " "ahci(%p)[%d]: sglist population failed" "\n", s, port);
#line 3082 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ahci_dma_prepare_buf_fail(void * s, int port)
{
    if (true) {
        _nocheck__trace_ahci_dma_prepare_buf_fail(s, port);
    }
}

#define TRACE_AHCI_DMA_RW_BUF_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_DMA_RW_BUF) || \
    false)

static inline void _nocheck__trace_ahci_dma_rw_buf(void * s, int port, int l)
{
    if (trace_event_get_state(TRACE_AHCI_DMA_RW_BUF) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 114 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ahci_dma_rw_buf " "ahci(%p)[%d] len=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port, l);
#line 3109 "trace/trace-hw_ide.h"
        } else {
#line 114 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ahci_dma_rw_buf " "ahci(%p)[%d] len=0x%x" "\n", s, port, l);
#line 3113 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ahci_dma_rw_buf(void * s, int port, int l)
{
    if (true) {
        _nocheck__trace_ahci_dma_rw_buf(s, port, l);
    }
}

#define TRACE_AHCI_CMD_DONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_CMD_DONE) || \
    false)

static inline void _nocheck__trace_ahci_cmd_done(void * s, int port)
{
    if (trace_event_get_state(TRACE_AHCI_CMD_DONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 115 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ahci_cmd_done " "ahci(%p)[%d]: cmd done" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port);
#line 3140 "trace/trace-hw_ide.h"
        } else {
#line 115 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ahci_cmd_done " "ahci(%p)[%d]: cmd done" "\n", s, port);
#line 3144 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ahci_cmd_done(void * s, int port)
{
    if (true) {
        _nocheck__trace_ahci_cmd_done(s, port);
    }
}

#define TRACE_AHCI_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AHCI_RESET) || \
    false)

static inline void _nocheck__trace_ahci_reset(void * s)
{
    if (trace_event_get_state(TRACE_AHCI_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 116 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:ahci_reset " "ahci(%p): HBA reset" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s);
#line 3171 "trace/trace-hw_ide.h"
        } else {
#line 116 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("ahci_reset " "ahci(%p): HBA reset" "\n", s);
#line 3175 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_ahci_reset(void * s)
{
    if (true) {
        _nocheck__trace_ahci_reset(s);
    }
}

#define TRACE_HANDLE_REG_H2D_FIS_DUMP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HANDLE_REG_H2D_FIS_DUMP) || \
    false)

static inline void _nocheck__trace_handle_reg_h2d_fis_dump(void * s, int port, const char * fis)
{
    if (trace_event_get_state(TRACE_HANDLE_REG_H2D_FIS_DUMP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 119 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:handle_reg_h2d_fis_dump " "ahci(%p)[%d]: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port, fis);
#line 3202 "trace/trace-hw_ide.h"
        } else {
#line 119 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("handle_reg_h2d_fis_dump " "ahci(%p)[%d]: %s" "\n", s, port, fis);
#line 3206 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_handle_reg_h2d_fis_dump(void * s, int port, const char * fis)
{
    if (true) {
        _nocheck__trace_handle_reg_h2d_fis_dump(s, port, fis);
    }
}

#define TRACE_HANDLE_CMD_FIS_DUMP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HANDLE_CMD_FIS_DUMP) || \
    false)

static inline void _nocheck__trace_handle_cmd_fis_dump(void * s, int port, const char * fis)
{
    if (trace_event_get_state(TRACE_HANDLE_CMD_FIS_DUMP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 120 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:handle_cmd_fis_dump " "ahci(%p)[%d]: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, port, fis);
#line 3233 "trace/trace-hw_ide.h"
        } else {
#line 120 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("handle_cmd_fis_dump " "ahci(%p)[%d]: %s" "\n", s, port, fis);
#line 3237 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_handle_cmd_fis_dump(void * s, int port, const char * fis)
{
    if (true) {
        _nocheck__trace_handle_cmd_fis_dump(s, port, fis);
    }
}

#define TRACE_ALLWINNER_AHCI_MEM_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ALLWINNER_AHCI_MEM_READ) || \
    false)

static inline void _nocheck__trace_allwinner_ahci_mem_read(void * s, void * a, uint64_t addr, uint64_t val, unsigned size)
{
    if (trace_event_get_state(TRACE_ALLWINNER_AHCI_MEM_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 123 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:allwinner_ahci_mem_read " "ahci(%p): read a=%p addr=0x%"PRIx64" val=0x%"PRIx64", size=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, a, addr, val, size);
#line 3264 "trace/trace-hw_ide.h"
        } else {
#line 123 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("allwinner_ahci_mem_read " "ahci(%p): read a=%p addr=0x%"PRIx64" val=0x%"PRIx64", size=%d" "\n", s, a, addr, val, size);
#line 3268 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_allwinner_ahci_mem_read(void * s, void * a, uint64_t addr, uint64_t val, unsigned size)
{
    if (true) {
        _nocheck__trace_allwinner_ahci_mem_read(s, a, addr, val, size);
    }
}

#define TRACE_ALLWINNER_AHCI_MEM_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ALLWINNER_AHCI_MEM_WRITE) || \
    false)

static inline void _nocheck__trace_allwinner_ahci_mem_write(void * s, void * a, uint64_t addr, uint64_t val, unsigned size)
{
    if (trace_event_get_state(TRACE_ALLWINNER_AHCI_MEM_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 124 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("%d@%zu.%06zu:allwinner_ahci_mem_write " "ahci(%p): write a=%p addr=0x%"PRIx64" val=0x%"PRIx64", size=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, a, addr, val, size);
#line 3295 "trace/trace-hw_ide.h"
        } else {
#line 124 "/home/inhoinno/FEMU/hw/ide/trace-events"
            qemu_log("allwinner_ahci_mem_write " "ahci(%p): write a=%p addr=0x%"PRIx64" val=0x%"PRIx64", size=%d" "\n", s, a, addr, val, size);
#line 3299 "trace/trace-hw_ide.h"
        }
    }
}

static inline void trace_allwinner_ahci_mem_write(void * s, void * a, uint64_t addr, uint64_t val, unsigned size)
{
    if (true) {
        _nocheck__trace_allwinner_ahci_mem_write(s, a, addr, val, size);
    }
}
#endif /* TRACE_HW_IDE_GENERATED_TRACERS_H */
