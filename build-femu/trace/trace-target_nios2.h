/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_TARGET_NIOS2_GENERATED_TRACERS_H
#define TRACE_TARGET_NIOS2_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_NIOS2_MMU_TRANSLATE_MISS_EVENT;
extern TraceEvent _TRACE_NIOS2_MMU_TRANSLATE_HIT_EVENT;
extern TraceEvent _TRACE_NIOS2_MMU_FLUSH_PID_MISS_EVENT;
extern TraceEvent _TRACE_NIOS2_MMU_FLUSH_PID_HIT_EVENT;
extern TraceEvent _TRACE_NIOS2_MMU_WRITE_TLBACC_EVENT;
extern TraceEvent _TRACE_NIOS2_MMU_WRITE_TLBMISC_EVENT;
extern TraceEvent _TRACE_NIOS2_MMU_WRITE_PTEADDR_EVENT;
extern uint16_t _TRACE_NIOS2_MMU_TRANSLATE_MISS_DSTATE;
extern uint16_t _TRACE_NIOS2_MMU_TRANSLATE_HIT_DSTATE;
extern uint16_t _TRACE_NIOS2_MMU_FLUSH_PID_MISS_DSTATE;
extern uint16_t _TRACE_NIOS2_MMU_FLUSH_PID_HIT_DSTATE;
extern uint16_t _TRACE_NIOS2_MMU_WRITE_TLBACC_DSTATE;
extern uint16_t _TRACE_NIOS2_MMU_WRITE_TLBMISC_DSTATE;
extern uint16_t _TRACE_NIOS2_MMU_WRITE_PTEADDR_DSTATE;
#define TRACE_NIOS2_MMU_TRANSLATE_MISS_ENABLED 1
#define TRACE_NIOS2_MMU_TRANSLATE_HIT_ENABLED 1
#define TRACE_NIOS2_MMU_FLUSH_PID_MISS_ENABLED 1
#define TRACE_NIOS2_MMU_FLUSH_PID_HIT_ENABLED 1
#define TRACE_NIOS2_MMU_WRITE_TLBACC_ENABLED 1
#define TRACE_NIOS2_MMU_WRITE_TLBMISC_ENABLED 1
#define TRACE_NIOS2_MMU_WRITE_PTEADDR_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_NIOS2_MMU_TRANSLATE_MISS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NIOS2_MMU_TRANSLATE_MISS) || \
    false)

static inline void _nocheck__trace_nios2_mmu_translate_miss(uint32_t vaddr, uint32_t pid, uint32_t index, uint32_t tag)
{
    if (trace_event_get_state(TRACE_NIOS2_MMU_TRANSLATE_MISS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 2 "/home/inhoinno/FEMU/target/nios2/trace-events"
            qemu_log("%d@%zu.%06zu:nios2_mmu_translate_miss " "mmu_translate: MISS vaddr=0x%08x pid=%u TLB[%u] tag=0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vaddr, pid, index, tag);
#line 49 "trace/trace-target_nios2.h"
        } else {
#line 2 "/home/inhoinno/FEMU/target/nios2/trace-events"
            qemu_log("nios2_mmu_translate_miss " "mmu_translate: MISS vaddr=0x%08x pid=%u TLB[%u] tag=0x%08x" "\n", vaddr, pid, index, tag);
#line 53 "trace/trace-target_nios2.h"
        }
    }
}

static inline void trace_nios2_mmu_translate_miss(uint32_t vaddr, uint32_t pid, uint32_t index, uint32_t tag)
{
    if (true) {
        _nocheck__trace_nios2_mmu_translate_miss(vaddr, pid, index, tag);
    }
}

#define TRACE_NIOS2_MMU_TRANSLATE_HIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NIOS2_MMU_TRANSLATE_HIT) || \
    false)

static inline void _nocheck__trace_nios2_mmu_translate_hit(uint32_t vaddr, uint32_t pid, uint32_t index, uint32_t paddr, uint32_t prot)
{
    if (trace_event_get_state(TRACE_NIOS2_MMU_TRANSLATE_HIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 3 "/home/inhoinno/FEMU/target/nios2/trace-events"
            qemu_log("%d@%zu.%06zu:nios2_mmu_translate_hit " "mmu_translate: HIT vaddr=0x%08x pid=%u TLB[%u] paddr=0x%08x prot=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vaddr, pid, index, paddr, prot);
#line 80 "trace/trace-target_nios2.h"
        } else {
#line 3 "/home/inhoinno/FEMU/target/nios2/trace-events"
            qemu_log("nios2_mmu_translate_hit " "mmu_translate: HIT vaddr=0x%08x pid=%u TLB[%u] paddr=0x%08x prot=0x%x" "\n", vaddr, pid, index, paddr, prot);
#line 84 "trace/trace-target_nios2.h"
        }
    }
}

static inline void trace_nios2_mmu_translate_hit(uint32_t vaddr, uint32_t pid, uint32_t index, uint32_t paddr, uint32_t prot)
{
    if (true) {
        _nocheck__trace_nios2_mmu_translate_hit(vaddr, pid, index, paddr, prot);
    }
}

#define TRACE_NIOS2_MMU_FLUSH_PID_MISS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NIOS2_MMU_FLUSH_PID_MISS) || \
    false)

static inline void _nocheck__trace_nios2_mmu_flush_pid_miss(uint32_t pid, uint32_t index, uint32_t vaddr)
{
    if (trace_event_get_state(TRACE_NIOS2_MMU_FLUSH_PID_MISS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 5 "/home/inhoinno/FEMU/target/nios2/trace-events"
            qemu_log("%d@%zu.%06zu:nios2_mmu_flush_pid_miss " "mmu_flush: MISS pid=%u TLB[%u] tag=0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , pid, index, vaddr);
#line 111 "trace/trace-target_nios2.h"
        } else {
#line 5 "/home/inhoinno/FEMU/target/nios2/trace-events"
            qemu_log("nios2_mmu_flush_pid_miss " "mmu_flush: MISS pid=%u TLB[%u] tag=0x%08x" "\n", pid, index, vaddr);
#line 115 "trace/trace-target_nios2.h"
        }
    }
}

static inline void trace_nios2_mmu_flush_pid_miss(uint32_t pid, uint32_t index, uint32_t vaddr)
{
    if (true) {
        _nocheck__trace_nios2_mmu_flush_pid_miss(pid, index, vaddr);
    }
}

#define TRACE_NIOS2_MMU_FLUSH_PID_HIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NIOS2_MMU_FLUSH_PID_HIT) || \
    false)

static inline void _nocheck__trace_nios2_mmu_flush_pid_hit(uint32_t pid, uint32_t index, uint32_t vaddr)
{
    if (trace_event_get_state(TRACE_NIOS2_MMU_FLUSH_PID_HIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 6 "/home/inhoinno/FEMU/target/nios2/trace-events"
            qemu_log("%d@%zu.%06zu:nios2_mmu_flush_pid_hit " "mmu_flush: HIT pid=%u TLB[%u] vaddr=0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , pid, index, vaddr);
#line 142 "trace/trace-target_nios2.h"
        } else {
#line 6 "/home/inhoinno/FEMU/target/nios2/trace-events"
            qemu_log("nios2_mmu_flush_pid_hit " "mmu_flush: HIT pid=%u TLB[%u] vaddr=0x%08x" "\n", pid, index, vaddr);
#line 146 "trace/trace-target_nios2.h"
        }
    }
}

static inline void trace_nios2_mmu_flush_pid_hit(uint32_t pid, uint32_t index, uint32_t vaddr)
{
    if (true) {
        _nocheck__trace_nios2_mmu_flush_pid_hit(pid, index, vaddr);
    }
}

#define TRACE_NIOS2_MMU_WRITE_TLBACC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NIOS2_MMU_WRITE_TLBACC) || \
    false)

static inline void _nocheck__trace_nios2_mmu_write_tlbacc(uint32_t ig, char c, char r, char w, char x, char g, uint32_t pfn)
{
    if (trace_event_get_state(TRACE_NIOS2_MMU_WRITE_TLBACC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 8 "/home/inhoinno/FEMU/target/nios2/trace-events"
            qemu_log("%d@%zu.%06zu:nios2_mmu_write_tlbacc " "mmu_write_tlbacc: ig=0x%02x flags=%c%c%c%c%c pfn=0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ig, c, r, w, x, g, pfn);
#line 173 "trace/trace-target_nios2.h"
        } else {
#line 8 "/home/inhoinno/FEMU/target/nios2/trace-events"
            qemu_log("nios2_mmu_write_tlbacc " "mmu_write_tlbacc: ig=0x%02x flags=%c%c%c%c%c pfn=0x%08x" "\n", ig, c, r, w, x, g, pfn);
#line 177 "trace/trace-target_nios2.h"
        }
    }
}

static inline void trace_nios2_mmu_write_tlbacc(uint32_t ig, char c, char r, char w, char x, char g, uint32_t pfn)
{
    if (true) {
        _nocheck__trace_nios2_mmu_write_tlbacc(ig, c, r, w, x, g, pfn);
    }
}

#define TRACE_NIOS2_MMU_WRITE_TLBMISC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NIOS2_MMU_WRITE_TLBMISC) || \
    false)

static inline void _nocheck__trace_nios2_mmu_write_tlbmisc(uint32_t way, char r, char w, char t, char b, char p, char d, uint32_t pid)
{
    if (trace_event_get_state(TRACE_NIOS2_MMU_WRITE_TLBMISC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 9 "/home/inhoinno/FEMU/target/nios2/trace-events"
            qemu_log("%d@%zu.%06zu:nios2_mmu_write_tlbmisc " "mmu_write_tlbmisc: way=0x%x flags=%c%c%c%c%c%c pid=%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , way, r, w, t, b, p, d, pid);
#line 204 "trace/trace-target_nios2.h"
        } else {
#line 9 "/home/inhoinno/FEMU/target/nios2/trace-events"
            qemu_log("nios2_mmu_write_tlbmisc " "mmu_write_tlbmisc: way=0x%x flags=%c%c%c%c%c%c pid=%u" "\n", way, r, w, t, b, p, d, pid);
#line 208 "trace/trace-target_nios2.h"
        }
    }
}

static inline void trace_nios2_mmu_write_tlbmisc(uint32_t way, char r, char w, char t, char b, char p, char d, uint32_t pid)
{
    if (true) {
        _nocheck__trace_nios2_mmu_write_tlbmisc(way, r, w, t, b, p, d, pid);
    }
}

#define TRACE_NIOS2_MMU_WRITE_PTEADDR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NIOS2_MMU_WRITE_PTEADDR) || \
    false)

static inline void _nocheck__trace_nios2_mmu_write_pteaddr(uint32_t ptb, uint32_t vpn)
{
    if (trace_event_get_state(TRACE_NIOS2_MMU_WRITE_PTEADDR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 10 "/home/inhoinno/FEMU/target/nios2/trace-events"
            qemu_log("%d@%zu.%06zu:nios2_mmu_write_pteaddr " "mmu_write_pteaddr: ptbase=0x%03x vpn=0x%05x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ptb, vpn);
#line 235 "trace/trace-target_nios2.h"
        } else {
#line 10 "/home/inhoinno/FEMU/target/nios2/trace-events"
            qemu_log("nios2_mmu_write_pteaddr " "mmu_write_pteaddr: ptbase=0x%03x vpn=0x%05x" "\n", ptb, vpn);
#line 239 "trace/trace-target_nios2.h"
        }
    }
}

static inline void trace_nios2_mmu_write_pteaddr(uint32_t ptb, uint32_t vpn)
{
    if (true) {
        _nocheck__trace_nios2_mmu_write_pteaddr(ptb, vpn);
    }
}
#endif /* TRACE_TARGET_NIOS2_GENERATED_TRACERS_H */
